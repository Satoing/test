<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BFS与多源最短路径</title>
      <link href="/post/3a82e2e8.html"/>
      <url>/post/3a82e2e8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="树的层序遍历"><a href="#树的层序遍历" class="headerlink" title="树的层序遍历"></a>树的层序遍历</h1><p>树的<mark class="hl-label green">层序遍历</mark> 推广到图就是<mark class="hl-label green">广度优先搜索</mark> ，它是借助<mark class="hl-label blue">队列</mark> 这个数据结构实现的。</p><p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/5/cover.png" alt></p><p>如图，我们先将根节点放入队列中；然后<emp>队首的节点出队，将其左右孩子入队</emp>；重复这个操作（迭代），直到<mark class="hl-label pink">队列为空时，遍历结束</mark> 。</p><h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h2><details class="folding-tag" cyan><summary> 题目 </summary>              <div class="content">              <div class="note green flat"><p>给你两棵二叉树： root1 和 root2 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p>注意: 合并过程必须从两个树的根节点开始。</p></div> <p><mark class="hl-label green">示例1：</mark> 输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]  输出：[3,4,5,5,4,null,7]</p><p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/5/1.png" alt></p>              </div>            </details><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这是一道比较简单的题，但是如果我们把能想到的所有方法都首先一遍，或许这道题就没有那么简单了。题目要求我们合并两棵二叉树，我们要做的就是同时遍历这两棵树：<emp>如果两棵树对应位置的结点同时存在，则值相加；如果只有一边存在结点，则将存在结点的那棵树的对应结点挂到新树上</emp>。</p><p>而遍历一棵树的方法有四种，包括<mark class="hl-label blue">前中后三序遍历</mark> 和<mark class="hl-label blue">层序遍历</mark> 。而前面三种遍历既可以递归实现，也可以用栈实现。</p><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><p>二叉树是一种很适合递归的数据结构，因为它<mark class="hl-label green">本身的定义</mark> 就是递归的：</p><div class="note green modern"><p>一棵树或为空树，或是由一个根节点加上两棵分别称为左子树或右子树的互不相交的二叉树组成。</p></div><p>而对一棵树进行深度优先遍历的模板也很简单，以先序遍历为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    <span class="hljs-comment">//递归的终止条件</span><br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">visit</span>();<span class="hljs-comment">//先序</span><br>    <span class="hljs-built_in">preorder</span>(root-&gt;left);<br>    <span class="hljs-comment">//visit() //中序</span><br>    <span class="hljs-built_in">preorder</span>(root-&gt;right);<br>    <span class="hljs-comment">//visit() //后序</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以，需要对树进行遍历时我们可以首先思考递归的方法。</p><p>对于这道题，我们同时对两棵树进行遍历，递归的终止条件是有一棵树的结点为空，此时返回不为空的结点，就可以将它挂到新树上。当两棵树的结点都不为空时，值相加赋给新树的结点；这里的访问操作<code>visit()</code>就是将结点的值相加，所以可以将这个操作放到不同的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root1==<span class="hljs-literal">nullptr</span> || root2==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> root1==<span class="hljs-literal">nullptr</span>?root2:root1;<br>        root1-&gt;val+=root2-&gt;val;<span class="hljs-comment">//先序</span><br>        root1-&gt;left=<span class="hljs-built_in">mergeTrees</span>(root1-&gt;left,root2-&gt;left);<br>        <span class="hljs-comment">// root1-&gt;val+=root2-&gt;val;//中序</span><br>        root1-&gt;right=<span class="hljs-built_in">mergeTrees</span>(root1-&gt;right,root2-&gt;right);<br>        <span class="hljs-comment">// root1-&gt;val+=root2-&gt;val;//后序</span><br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" cyan><summary> judge </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/5/2.png" alt></p>              </div>            </details><h3 id="栈实现"><a href="#栈实现" class="headerlink" title="栈实现"></a>栈实现</h3><p>既然可以递归那么就可以用栈。我们规定先访问左子树，再访问右子树，那么压栈的顺序就是先将结点的右孩子压入栈中，再将左孩子入栈。这样的结果就是前序遍历：</p><p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/5/3.gif" alt></p><p>两棵树同时遍历同理，我们使用一个栈来存储结点对<code>pair&lt;TreeNode*,TreeNode*&gt;</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root1==<span class="hljs-literal">nullptr</span>||root2==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> root1==<span class="hljs-literal">nullptr</span>?root2:root1;<br>        stack&lt;pair&lt;TreeNode*,TreeNode*&gt; &gt; stk;<br>        stk.<span class="hljs-built_in">emplace</span>(root1,root2);<br>        <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>())&#123;<br>            TreeNode* t1=stk.<span class="hljs-built_in">top</span>().first;<br>            TreeNode* t2=stk.<span class="hljs-built_in">top</span>().second;<br>            stk.<span class="hljs-built_in">pop</span>();<br>            t1-&gt;val+=t2-&gt;val;<br>            <span class="hljs-keyword">if</span>(t1-&gt;right!=<span class="hljs-literal">nullptr</span>&amp;&amp;t2-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                stk.<span class="hljs-built_in">emplace</span>(t1-&gt;right,t2-&gt;right);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t2-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                t1-&gt;right=t2-&gt;right;<br>            <span class="hljs-keyword">if</span>(t1-&gt;left!=<span class="hljs-literal">nullptr</span>&amp;&amp;t2-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                stk.<span class="hljs-built_in">emplace</span>(t1-&gt;left,t2-&gt;left);       <br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t2-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                t1-&gt;left=t2-&gt;left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" green><summary> judge </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/5/4.png" alt></p>              </div>            </details><h3 id="队列实现"><a href="#队列实现" class="headerlink" title="队列实现"></a>队列实现</h3><p>我们使用层序遍历的方式来遍历二叉树，使用队列即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root1==<span class="hljs-literal">nullptr</span>||root2==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> root1==<span class="hljs-literal">nullptr</span>?root2:root1;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root1);<br>        que.<span class="hljs-built_in">push</span>(root2);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            TreeNode* t1=que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            TreeNode* t2=que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            t1-&gt;val+=t2-&gt;val;<br>            <span class="hljs-keyword">if</span>(t1-&gt;left!=<span class="hljs-literal">nullptr</span>&amp;&amp;t2-&gt;left!=<span class="hljs-literal">nullptr</span>)&#123;<br>                que.<span class="hljs-built_in">push</span>(t1-&gt;left);<br>                que.<span class="hljs-built_in">push</span>(t2-&gt;left);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t1-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;t2-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                t1-&gt;left=t2-&gt;left;<br><br>            <span class="hljs-keyword">if</span>(t1-&gt;right!=<span class="hljs-literal">nullptr</span>&amp;&amp;t2-&gt;right!=<span class="hljs-literal">nullptr</span>)&#123;<br>                que.<span class="hljs-built_in">push</span>(t1-&gt;right);<br>                que.<span class="hljs-built_in">push</span>(t2-&gt;right);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t1-&gt;right==<span class="hljs-literal">nullptr</span>&amp;&amp;t2-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                t1-&gt;right=t2-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" green><summary> judge </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/5/5.png" alt></p>              </div>            </details><hr><h2 id="填充每个节点的下一个右侧节点指针"><a href="#填充每个节点的下一个右侧节点指针" class="headerlink" title="填充每个节点的下一个右侧节点指针"></a>填充每个节点的下一个右侧节点指针</h2><p>二叉树结点定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>  <span class="hljs-keyword">int</span> val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>&#125;<br></code></pre></td></tr></table></figure><details class="folding-tag" orange><summary> 题目 </summary>              <div class="content">              <div class="note orange flat"><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p></div><p><mark class="hl-label orange">示例：</mark> 输入：root = [1,2,3,4,5,6,7]  输出：[1,#,2,3,#,4,5,6,7,#]</p><p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/5/6.png" alt></p>              </div>            </details><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>可以看到，<code>next</code>指针都是按层连接的，所以我们很自然地就会想到层序遍历。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">connect</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root;<br>        queue&lt;Node*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">int</span> len=que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>                Node* node=que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(i&lt;len<span class="hljs-number">-1</span>) node-&gt;next=que.<span class="hljs-built_in">front</span>();<br>                <span class="hljs-keyword">if</span>(node-&gt;left!=<span class="hljs-literal">nullptr</span>)&#123;<br>                    que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                    que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>遍历队列时按层连接<code>next</code>指针即可。要注意的是每层连接的指针数为结点数-1，所以还要添加一个判断条件<code>if(i&lt;len-1)</code>。</p><details class="folding-tag" orange><summary> judge </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/5/7.png" alt></p>              </div>            </details><h3 id="递归实现-1"><a href="#递归实现-1" class="headerlink" title="递归实现"></a>递归实现</h3><p>其实，在不是那么熟悉，或者是没有第一时间想到层序遍历的情况下，应该会先想到递归的方法，因为这更符合直觉。</p><p>分析题意可以发现：对于一个结点，我们对它的操作是将它的左孩子指向右孩子；如果该结点的<code>next</code>指针不为空的话，还要将右孩子指向右侧结点的左孩子。每个结点的操作都是如此，所以可以使用递归实现，结束的终止条件就是该结点的下一层为空。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">connect</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>||root-&gt;left==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">else</span> root-&gt;left-&gt;next=root-&gt;right;<br>        <span class="hljs-keyword">if</span>(root-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>            root-&gt;right-&gt;next=root-&gt;next-&gt;left;<br>        <span class="hljs-built_in">connect</span>(root-&gt;left);<br>        <span class="hljs-built_in">connect</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" orange><summary> judge </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/5/8.png" alt></p>              </div>            </details><hr><h1 id="多源最短路径"><a href="#多源最短路径" class="headerlink" title="多源最短路径"></a>多源最短路径</h1><p>在<mark class="hl-label pink">《数据结构与算法》</mark> 这门课程中，我们学过<mark class="hl-label blue">单源最短路径Dijkestra算法</mark> ，也学过<mark class="hl-label blue">多源最短路径Floyd算法</mark> ——这两种算法是针对带权图的一般性的做法，如果是<emp>无权图，或者说每一步权值都是1</emp>，那么就可以使用<mark class="hl-label green">广度优先搜索</mark> 。</p><h2 id="01矩阵"><a href="#01矩阵" class="headerlink" title="01矩阵"></a>01矩阵</h2><details class="folding-tag" blue><summary> 题目 </summary>              <div class="content">              <div class="note blue flat"><p>给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。</p><p>两个相邻元素间的距离为 1 。</p></div><p><mark class="hl-label blue">示例：</mark> 输入：mat = [[0,0,0],[0,1,0],[1,1,1]]  输出：[[0,0,0],[0,1,0],[1,2,1]]</p><p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/5/9.JPEG" alt></p>              </div>            </details><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>看到这道题，一般的想法是遍历数组，如果是1，那么就对其进行BFS，计算到最近的0的距离。</p><p>但是，如果我们再分析一下这种方法的时间复杂度就会发现，这其实是一种极不可取的做法！那么我们换个角度，对所有的0进行多源BFS。每进行一轮BFS，步数加一。</p><h3 id="使用flag数组"><a href="#使用flag数组" class="headerlink" title="使用flag数组"></a>使用flag数组</h3><p>过程图如下：</p><p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/5/10.gif" alt></p><ol><li>遍历矩阵，找到其中的0并入队，同时将其dist修改为0，flag修改为T；</li><li>搜索队列中元素的上下左右四个方向，如果发现了1，且其flag=F，即还没有遍历到这个元素，那么就将dist相应位置更新为源点+1，flag更新为T；（BFS）</li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; mat) &#123;<br>        <span class="hljs-keyword">int</span> row=mat.<span class="hljs-built_in">size</span>(),column=mat[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; dir[<span class="hljs-number">4</span>]=&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dist</span>(row, vector&lt;<span class="hljs-keyword">int</span>&gt;(column,row));<br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-built_in">flag</span>(row, vector&lt;<span class="hljs-keyword">bool</span>&gt;(column,<span class="hljs-literal">false</span>));<br>        queue&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; que;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;row;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;column;j++)&#123;<br>                <span class="hljs-keyword">if</span>(mat[i][j]==<span class="hljs-number">0</span>)&#123;<br>                    dist[i][j]=<span class="hljs-number">0</span>;<br>                    flag[i][j]=<span class="hljs-literal">true</span>;<br>                    que.<span class="hljs-built_in">emplace</span>(i,j);<br>                &#125;<br>            &#125;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">auto</span> p=que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:dir)&#123;<br>                <span class="hljs-keyword">int</span> r=p.first+i.second;<br>                <span class="hljs-keyword">int</span> c=p.second+i.first;<br>                <span class="hljs-keyword">if</span>(r&lt;<span class="hljs-number">0</span>||r&gt;=row||c&lt;<span class="hljs-number">0</span>||c&gt;=column) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(flag[r][c]==<span class="hljs-literal">false</span>)&#123;<br>                    dist[r][c]=dist[p.first][p.second]+<span class="hljs-number">1</span>;<br>                    flag[r][c]=<span class="hljs-literal">true</span>;<br>                    que.<span class="hljs-built_in">emplace</span>(r,c);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dist;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" blue><summary> judge </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/5/11.png" alt></p>              </div>            </details><p>看起来效果并不是很理想。进一步分析发现，falg数组完全是多余的！</p><h3 id="不用falg数组"><a href="#不用falg数组" class="headerlink" title="不用falg数组"></a>不用falg数组</h3><p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/5/10.gif" alt></p><p>从这个图可以很好地发现，当dist是无穷或一个很大的数时，对应的元素就没有遍历过。它和flag的更新时同步的，所以我们根据dist来判断即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; mat) &#123;<br>        <span class="hljs-keyword">int</span> row=mat.<span class="hljs-built_in">size</span>(),column=mat[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; dir[<span class="hljs-number">4</span>]=&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dist</span>(row, vector&lt;<span class="hljs-keyword">int</span>&gt;(column,<span class="hljs-number">10000</span>));<br>        queue&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; que;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;row;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;column;j++)&#123;<br>                <span class="hljs-keyword">if</span>(mat[i][j]==<span class="hljs-number">0</span>)&#123;<br>                    dist[i][j]=<span class="hljs-number">0</span>;<br>                    que.<span class="hljs-built_in">emplace</span>(i,j);<br>                &#125;<br>            &#125;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">auto</span> [i,j]=que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> d:dir)&#123;<br>                <span class="hljs-keyword">int</span> r=i+d.second;<br>                <span class="hljs-keyword">int</span> c=j+d.first;<br>                <span class="hljs-keyword">if</span>(r&lt;<span class="hljs-number">0</span>||r&gt;=row||c&lt;<span class="hljs-number">0</span>||c&gt;=column) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(dist[r][c]==<span class="hljs-number">10000</span>)&#123;<br>                    dist[r][c]=dist[i][j]+<span class="hljs-number">1</span>;<br>                    que.<span class="hljs-built_in">emplace</span>(r,c);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dist;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" blue><summary> judge </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/5/12.png" alt></p>              </div>            </details><p>这个做法的效率已经不错了，但是还有更优的做法——动态规划。不过我现在还并不想做DP问题，这个方法之后再说吧……</p><hr><h2 id="腐烂的橘子"><a href="#腐烂的橘子" class="headerlink" title="腐烂的橘子"></a>腐烂的橘子</h2><details class="folding-tag" orange><summary> 题目 </summary>              <div class="content">              <div class="note orange flat"><p>在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：</p><ul><li>值 0 代表空单元格；</li><li>值 1 代表新鲜橘子；</li><li>值 2 代表腐烂的橘子。</li></ul><p>每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。</p><p>返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。</p></div><p><mark class="hl-label orange">示例：</mark> 输入：grid = [[2,1,1],[1,1,0],[0,1,1]]  输出：4</p><p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/5/13.png" alt></p>              </div>            </details><mark class="hl-label orange">分析：</mark> 这道题和上一道题不能说是完全相同只能说是一模一样。腐烂的橘子就是源点，然后进行多源BFS，每次都将矩阵中的1（新鲜橘子）更新为0（腐烂橘子），同时记录BFS的层数。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">orangesRotting</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> row=grid.<span class="hljs-built_in">size</span>(),column=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(),fresh=<span class="hljs-number">0</span>,round=<span class="hljs-number">0</span>;<br>        pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; dir[<span class="hljs-number">4</span>]=&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>        queue&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; que;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;row;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;column;j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">2</span>) que.<span class="hljs-built_in">emplace</span>(i,j);<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>) fresh++;<br>            &#125;<br>        <span class="hljs-keyword">while</span>(fresh&gt;<span class="hljs-number">0</span>&amp;&amp;!que.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">int</span> len=que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;len;k++)&#123;<br>                <span class="hljs-keyword">auto</span> [i,j]=que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> d:dir)&#123;<br>                    <span class="hljs-keyword">int</span> r=i+d.second,c=j+d.first;<br>                    <span class="hljs-keyword">if</span>(r&lt;<span class="hljs-number">0</span>||r&gt;=row||c&lt;<span class="hljs-number">0</span>||c&gt;=column) <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-keyword">if</span>(grid[r][c]==<span class="hljs-number">1</span>)&#123;<br>                        fresh--;<br>                        grid[r][c]=<span class="hljs-number">2</span>;<br>                        que.<span class="hljs-built_in">emplace</span>(r,c);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            round++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(fresh&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> round;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><details class="folding-tag" orange><summary> judge </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/5/14.png" alt></p>              </div>            </details><hr>]]></content>
      
      
      <categories>
          
          <category> 大二下 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法学习 </tag>
            
            <tag> weekly算法训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python语法基础</title>
      <link href="/post/138da4b4.html"/>
      <url>/post/138da4b4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Python真的是一门很优雅且富有哲理的语言。我这里便以<mark class="hl-label orange">python之禅</mark> 中的几句作为这篇文章的开始：</p><div class="note info simple"><p>Beautiful is better than ugly.</p></div><div class="note default simple"><p>Simple is better than complex.</p></div><div class="note primary simple"><p>Complex is better than complicated.</p></div><div class="note warning simple"><p>Readability counts.</p></div><div class="note success simple"><p>Now is better than never.</p></div><hr><h1 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h1><p>python和C、C++等编译型语言不同，而和matlab类似：它可以<emp>在解释器中一行一行交互式地运行</emp>，也可以<emp>编写成脚本文件来运行</emp>——是一门<mark class="hl-label green">解释型语言</mark> 。</p><p>解释型语言的优点是简单，方便，可以化繁就简；缺点是相比编译型语言，运行<mark class="hl-label orange">速度比较慢</mark> ，而且<mark class="hl-label default">运行时报错</mark> ，不利于提前发现<mark class="hl-label red">BUG</mark> 。</p><p>一般的开发行业，如游戏行业等，基本上不会用python。但是由于python的应用面广，编程效率高，在不是那么注重程序运行速度的领域，如数据分析、机器学习等领域则备受青睐。</p><div class="note warning flat"><p>说现实点，学校实验室收人基本上都要求会python（大嘘。</p></div><hr><h1 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h1><div class="tip "><p>python是一种<mark class="hl-label orange">动态类型语言</mark> ，或者说它可以自动推导出变量的类型，而不需要我们再专门去声明，就和C++11中的<mark class="hl-label pink">auto</mark> 一样。</p></div><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><div class="note green flat"><p>python和C语言不同，它支持字符串类型。而且python的字符串类型和C++的<code>string</code>类型很相似，都内置了诸多方法以方便对字符串的操作。</p></div><h3 id="字符串的表示"><a href="#字符串的表示" class="headerlink" title="字符串的表示"></a>字符串的表示</h3><p>python中的字符串可以用单引号或双引号括出，所以用法可以很灵活，<emp>按照不同情况可以选择不同引号</emp>。</p><p>如果一个字符串中出现了单引号，那么就选用双引号括出；如果字符串中出现了双引号，那么就选用单引号括出。但是<emp>单双引号一定要匹配，不能混用！</emp></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;I&#x27;m Sato.&quot;</span> <span class="hljs-comment"># 情况一</span><br><span class="hljs-string">&#x27;I told him,&quot;Hei,hurry up!&quot;&#x27;</span> <span class="hljs-comment"># 情况二</span><br></code></pre></td></tr></table></figure><h3 id="字符串的操作"><a href="#字符串的操作" class="headerlink" title="字符串的操作"></a>字符串的操作</h3><blockquote><p>前面说了python中字符串支持很多操作，我这里选择几个比较常用的来讲。</p></blockquote><h4 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h4><p>先定义一个字符串，然后使用<mark class="hl-label default">字符串变量.函数</mark> 即可调用对应的方法。示例程序如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">company=<span class="hljs-string">&#x27;yuzusoft Sour&#x27;</span><br><span class="hljs-built_in">print</span>(company.title()) <span class="hljs-comment"># 操作一</span><br><span class="hljs-built_in">print</span>(company.upper()) <span class="hljs-comment"># 操作二</span><br><span class="hljs-built_in">print</span>(company.lower()) <span class="hljs-comment"># 操作三</span><br><span class="hljs-built_in">print</span>(company) <span class="hljs-comment">#检查是否改变</span><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 输出">Yuzusoft Sour # 操作一<br>YUZUSOFT SOUR # 操作二<br>yuzusoft sour # 操作三<br>yuzusoft Sour # 检查<br></code></pre></td></tr></table></figure><details class="folding-tag" open cyan><summary> 通过这段示例程序可以看出： </summary>              <div class="content">              <p><code>title()</code>可将字符串中的每个单词首字母大写；<code>upper()</code>可将字符串的所有字符大写；<code>lower()</code>则将所有字符小写。但是<emp>这个字符串最终没有改变</emp>，用C语言来理解就是通过返回值来传递结果，而不改变其本身。</p>              </div>            </details><h4 id="合并字符串"><a href="#合并字符串" class="headerlink" title="合并字符串"></a>合并字符串</h4><p>python中可以使用<code>+</code>来将字符串连接起来，在C++中相当于对<code>+</code>进行了重载。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello&quot;</span>+<span class="hljs-string">&quot;,python&quot;</span>+<span class="hljs-string">&#x27;!&#x27;</span>)<br></code></pre></td></tr></table></figure><p>要注意连接的每一项都是字符串！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">age=<span class="hljs-number">18</span><br><span class="hljs-comment"># print(&quot;I&#x27;m &quot;+age+&#x27; years old.&#x27;) 报错，因为age不是字符串</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I&#x27;m &quot;</span>+<span class="hljs-built_in">str</span>(age)+<span class="hljs-string">&#x27; years old.&#x27;</span>) <span class="hljs-comment"># 强制类型转换</span><br></code></pre></td></tr></table></figure><p>更多字符串的操作请前往编辑器自行查看：</p><p><img src="https://cloud.fullcomb.top/private/source/image/python/1.png" alt></p><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><div class="tip "><p>python中的数字只分为<mark class="hl-label pink">整数和浮点数</mark> 两种</p></div><p>数字的运算支持<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>运算，而且python会尽可能精确地表示出结果：</p><ol><li>结果小数位数有限且比较少，则只表示到最小位数，不显示多余的0：<code>7/2=3.5</code></li><li>无限不循环小数，尽可能显示多的小数位数：<code>1/3=0.3333333333333333</code></li><li>很大的数进行运算，python将自动采用高精度算法，所以结果不会溢出：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">8301830182912908982</span>*<span class="hljs-number">27189371872987981</span><br><span class="hljs-number">225721548069614912986831433032945342</span><br></code></pre></td></tr></table></figure><p>由于python计算精确且可以在解释器中交互运行，所以可以很好地拿来做数值计算（<psw>计算器</psw>）。</p><p>而这个计算拿到C++中就是这样：</p><p><img src="https://cloud.fullcomb.top/private/source/image/python/2.png" alt></p><p>所以，让我们高呼：<mark class="hl-label blue">Python，YES!</mark> （bushi，逐渐发出了C语言</p><hr><h1 id="列表及其操作"><a href="#列表及其操作" class="headerlink" title="列表及其操作"></a>列表及其操作</h1><div class="note info modern"><p>python中的列表是一个很神奇的数据类型。它可以作为C语言中的数组、结构体，C++中的vector，也可以作为数据结构中的栈、队列……用好了就会觉得list真的太有用了！</p></div><h2 id="列表的定义及访问"><a href="#列表的定义及访问" class="headerlink" title="列表的定义及访问"></a>列表的定义及访问</h2><p>列表有一系列<emp>按特定顺序排列</emp>的元素组成，而且列表中<emp>可以包含不同元素</emp>。因为列表元素有顺序，所以它像C语言的数组；因为元素可以是不同类型，所以又像结构体。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">info=[<span class="hljs-string">&#x27;Sato&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&#x27;male&#x27;</span>] <span class="hljs-comment"># 这是合法的</span><br><span class="hljs-built_in">print</span>(info[<span class="hljs-number">1</span>]) <span class="hljs-comment"># 打印18</span><br><span class="hljs-built_in">print</span>(info[-<span class="hljs-number">1</span>]) <span class="hljs-comment"># 打印最后一个元素</span><br></code></pre></td></tr></table></figure><p>列表用<mark class="hl-label pink">方括号[]</mark> 来表示，并且用逗号依次分隔其中的元素。访问的时候通过下标来访问即可。<mark class="hl-label blue">更方便的是可以通过下标-1直接访问到最后一个元素</mark> </p><h2 id="添加和删除元素"><a href="#添加和删除元素" class="headerlink" title="添加和删除元素"></a>添加和删除元素</h2><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>python中的列表可以<mark class="hl-label green">动态增长</mark> ，所以又像C++中的vector。</p><ol><li>使用<mark class="hl-label orange">append</mark> 向<emp>列表末尾</emp>添加元素</li><li>使用<mark class="hl-label pink">insert</mark> 向<emp>列表任意位置</emp>添加元素</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">games=[<span class="hljs-string">&#x27;Senren*Banka&#x27;</span>,<span class="hljs-string">&#x27;RIDDLE JOKER&#x27;</span>]<br>games.append[<span class="hljs-string">&#x27;Cafe Stella&#x27;</span>]<br><span class="hljs-built_in">print</span>(games)<br>games.insert(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Sabbat of the Witch&#x27;</span>)<br><span class="hljs-built_in">print</span>(games)<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs >>">[&#x27;Senren*Banka&#x27;, &#x27;RIDDLE JOKER&#x27;, &#x27;Cafe Stella&#x27;]<br>[&#x27;Senren*Banka&#x27;, &#x27;Sabbat of the Witch&#x27;, &#x27;RIDDLE JOKER&#x27;, &#x27;Cafe Stella&#x27;]<br></code></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>和添加元素一样，删除列表元素也有很多方式：</p><ol><li>使用<mark class="hl-label pink">del</mark> 语句删除指定下标的元素</li><li>使用<mark class="hl-label blue">pop</mark> 弹出列表最后一个元素</li><li>使用<mark class="hl-label orange">pop</mark> 弹出列表任意位置的元素</li><li>使用<mark class="hl-label green">remove</mark> 根据值删除元素</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">games=[<span class="hljs-string">&#x27;Senren&#x27;</span>, <span class="hljs-string">&#x27;Sabbat&#x27;</span>, <span class="hljs-string">&#x27;JOKER&#x27;</span>, <span class="hljs-string">&#x27;Cafe&#x27;</span>,<span class="hljs-string">&#x27;Stella&#x27;</span>]<br><span class="hljs-comment"># 使用下面三种方法都可以删除最后一个元素</span><br><span class="hljs-keyword">del</span> games[-<span class="hljs-number">1</span>]<br>games.pop()<br>games.pop(-<span class="hljs-number">1</span>)<br><span class="hljs-comment"># 根据值删除元素</span><br>games.remove(<span class="hljs-string">&#x27;Senren&#x27;</span>)<br></code></pre></td></tr></table></figure><p>因为列表是一种顺序存储的结构，所以前三种按地址查找的时间复杂度为O(1)，是很快的；而第四种按值查找的时间复杂度为则O(n)。</p><div class="note warning modern"><p>经测试，当列表中有重复的元素时，使用remove方法删除该元素只会删除前面的那一个元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">games=[<span class="hljs-string">&#x27;Senren&#x27;</span>, <span class="hljs-string">&#x27;Sabbat&#x27;</span>,<span class="hljs-string">&#x27;Senren&#x27;</span>]<br>games.remove(<span class="hljs-string">&#x27;Senren&#x27;</span>)<br><span class="hljs-built_in">print</span>(games)<br><span class="hljs-comment"># 打印[&#x27;Sabbat&#x27;, &#x27;Senren&#x27;]</span><br></code></pre></td></tr></table></figure></div><h2 id="列表切片"><a href="#列表切片" class="headerlink" title="列表切片"></a>列表切片</h2><h3 id="使用列表的一部分"><a href="#使用列表的一部分" class="headerlink" title="使用列表的一部分"></a>使用列表的一部分</h3><p>如果我们只需要取出列表的一部分，那么就可以使用<mark class="hl-label pink">切片</mark> 的方法。通过<emp>指定列表下标的范围</emp>，即可获得对应下标范围的那一部分列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">games=[<span class="hljs-string">&#x27;Senren&#x27;</span>, <span class="hljs-string">&#x27;Sabbat&#x27;</span>,<span class="hljs-string">&#x27;Senren&#x27;</span>]<br><span class="hljs-built_in">print</span>(games[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]) <span class="hljs-comment"># 1</span><br><span class="hljs-built_in">print</span>(games[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]) <span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 1 打印[&#x27;Senren&#x27;, &#x27;Sabbat&#x27;]</span><br><span class="hljs-comment"># 2 打印[&#x27;Sabbat&#x27;, &#x27;Senren&#x27;]</span><br></code></pre></td></tr></table></figure><p>通过这段程序我们可以观察出来，这个下标范围相当于一个<mark class="hl-label orange">左闭右开区间</mark> ，<emp>切片的列表范围从左边的下标开始取到右边的下标-1</emp>。（实际上，计算机中对区间范围的约定很多也是左闭右开）</p><div class="note blue modern"><p>对于列表切片，如果省略左边的下标，那么就会从第一个元素开始访问；如果省略右边的下标，那么就会一直访问到最后一个元素；如果两个都省略，那么就会访问整个列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">games=[<span class="hljs-string">&#x27;Senren&#x27;</span>, <span class="hljs-string">&#x27;Sabbat&#x27;</span>,<span class="hljs-string">&#x27;Senren&#x27;</span>]<br><span class="hljs-built_in">print</span>(games[:<span class="hljs-number">2</span>]) <span class="hljs-comment"># 1</span><br><span class="hljs-built_in">print</span>(games[<span class="hljs-number">1</span>:]) <span class="hljs-comment"># 2</span><br><span class="hljs-built_in">print</span>(games[:])  <span class="hljs-comment"># 3</span><br><span class="hljs-comment"># 1 打印[&#x27;Senren&#x27;, &#x27;Sabbat&#x27;]</span><br><span class="hljs-comment"># 2 打印[&#x27;Sabbat&#x27;, &#x27;Senren&#x27;]</span><br><span class="hljs-comment"># 3 打印[&#x27;Senren&#x27;, &#x27;Sabbat&#x27;, &#x27;Senren&#x27;]</span><br></code></pre></td></tr></table></figure></div>。<div class="tip "><p>值得注意的是，列表切片并不改变列表本身，相当于是通过返回值进行传参。</p></div><h3 id="复制列表"><a href="#复制列表" class="headerlink" title="复制列表"></a>复制列表</h3><p>如果想要获得一个<emp>和已有列表完全一样，但又相互独立的另一个列表</emp>，你打算怎么做呢？</p><p>这时我们一般会想到<mark class="hl-label blue">赋值运算符</mark> 。毕竟python对字符串的<code>+</code>都进行了重载，再重载一下<code>=</code>也不过分吧？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">games=[<span class="hljs-string">&#x27;Senren&#x27;</span>, <span class="hljs-string">&#x27;Sabbat&#x27;</span>,<span class="hljs-string">&#x27;Senren&#x27;</span>]<br>playlist=games<br>playlist.pop()<br><span class="hljs-built_in">print</span>(games)<br><span class="hljs-comment"># 打印[&#x27;Senren&#x27;, &#x27;Sabbat&#x27;]</span><br></code></pre></td></tr></table></figure><p>可以看到，修改另一个列表时，原本的列表也改变了。这是因为两个列表并不独立，通过赋值操作赋值的是列表的地址，这样<mark class="hl-label pink">另一个列表就相当于原本列表的引用</mark> 。</p><p>要想根据已有列表创建一个与之独立的列表，就需要用到上面的<mark class="hl-label green">列表切片</mark> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">games=[<span class="hljs-string">&#x27;Senren&#x27;</span>, <span class="hljs-string">&#x27;Sabbat&#x27;</span>,<span class="hljs-string">&#x27;Senren&#x27;</span>]<br>playlist=games[:]<br>playlist.pop()<br><span class="hljs-built_in">print</span>(games)<br><span class="hljs-comment"># 打印[&#x27;Senren&#x27;, &#x27;Sabbat&#x27;, &#x27;Senren&#x27;]</span><br></code></pre></td></tr></table></figure><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>列表的元素是可变的，要使元素不可变就要用<mark class="hl-label pink">元组</mark> 。</p><p>元组使用<mark class="hl-label blue">圆括号()</mark> 进行标识。除了元素不能改变外，其他操作和列表相同，所以不多赘述。一旦使用改变元组本身的操作，python就会报错说：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">AttributeError: <span class="hljs-string">&#x27;tuple&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;pop&#x27;</span><br><span class="hljs-comment"># 其他同理</span><br></code></pre></td></tr></table></figure><hr><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>字典，顾名思义，其中的元素就是<mark class="hl-label pink">索引(key)</mark> 和<mark class="hl-label blue">值(value)</mark> 。python中的字典和C++中的<code>map</code>很相似，可以将元素哈希化后进行存储，<emp>很有实用性</emp>。</p><h2 id="字典的定义和使用"><a href="#字典的定义和使用" class="headerlink" title="字典的定义和使用"></a>字典的定义和使用</h2><p>字典用放在<mark class="hl-label orange">花括号{}</mark> 中的一系列键-值对表示，通过键可以访问到相应的值，字典中存放元素的顺序无关紧要。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">settings=&#123;<span class="hljs-string">&#x27;model&#x27;</span>:<span class="hljs-string">&#x27;easy&#x27;</span>,<span class="hljs-string">&#x27;speed&#x27;</span>:<span class="hljs-string">&#x27;fast&#x27;</span>&#125;<br><span class="hljs-built_in">print</span>(settings[<span class="hljs-string">&#x27;speed&#x27;</span>])<br><span class="hljs-comment"># 打印fast</span><br></code></pre></td></tr></table></figure><div class="tip "><p>现在我们把三种括号都用完了：[]对应列表、()对应元组、{}对应字典。</p></div><h2 id="字典的操作"><a href="#字典的操作" class="headerlink" title="字典的操作"></a>字典的操作</h2><p>字典的操作并没有列表那么多，涉及到的操作无非就是<emp>添加、修改和删除元素</emp>，示例见下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">settings=&#123;<span class="hljs-string">&#x27;model&#x27;</span>:<span class="hljs-string">&#x27;easy&#x27;</span>,<span class="hljs-string">&#x27;speed&#x27;</span>:<span class="hljs-string">&#x27;fast&#x27;</span>&#125;<br><span class="hljs-comment"># 添加元素</span><br>settings[<span class="hljs-string">&#x27;voice&#x27;</span>]=<span class="hljs-string">&#x27;open&#x27;</span><br><span class="hljs-comment"># 修改元素</span><br>settings[<span class="hljs-string">&#x27;model&#x27;</span>]=<span class="hljs-string">&#x27;peace&#x27;</span><br><span class="hljs-comment"># 删除元素</span><br><span class="hljs-keyword">del</span> settings[<span class="hljs-string">&#x27;speed&#x27;</span>]<br></code></pre></td></tr></table></figure><p>可以看出，添加元素和修改元素的方式相同，区别就是键在字典中是否已经存在了：如果存在了就是修改。<mark class="hl-label blue">字典允许值重复，但键是不能重复的</mark> ！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">settings=&#123;<span class="hljs-string">&#x27;model&#x27;</span>:<span class="hljs-string">&#x27;easy&#x27;</span>,<span class="hljs-string">&#x27;speed&#x27;</span>:<span class="hljs-string">&#x27;peace&#x27;</span>,<span class="hljs-string">&#x27;model&#x27;</span>:<span class="hljs-string">&#x27;peace&#x27;</span>&#125;<br><span class="hljs-built_in">print</span>(settings)<br><span class="hljs-comment"># 打印&#123;&#x27;model&#x27;: &#x27;peace&#x27;, &#x27;speed&#x27;: &#x27;peace&#x27;&#125;</span><br></code></pre></td></tr></table></figure><p>上面的程序中键重复了，所以后面的就覆盖掉了前面的——这就和修改的原理一样了。</p><hr><h1 id="循环与判断"><a href="#循环与判断" class="headerlink" title="循环与判断"></a>循环与判断</h1><p>python的循环<emp>逻辑和C语言大致相同</emp>，区别就是<emp>写法上有一些不同</emp>。所以这一部分也会过得很快。</p><div class="note warning flat"><p>python在写法上更加注重缩进，用缩进来表示一个代码块。比如说for循环的循环体就要缩进<mark class="hl-label pink">一个tab</mark> 或<mark class="hl-label green">四个空格</mark> ，循环体结束就取消缩进。<mark class="hl-label orange">注意不要漏写冒号！</mark> </p></div><h2 id="使用for循环遍历"><a href="#使用for循环遍历" class="headerlink" title="使用for循环遍历"></a>使用for循环遍历</h2><p>python中的for循环比C语言更加精简，更像C++11中<mark class="hl-label orange">基于范围的for循环</mark> 。</p><h3 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">settings=[<span class="hljs-string">&#x27;model&#x27;</span>,<span class="hljs-string">&#x27;speed&#x27;</span>,<span class="hljs-string">&#x27;screen&#x27;</span>]<br><span class="hljs-keyword">for</span> setting <span class="hljs-keyword">in</span> settings:<br>    <span class="hljs-built_in">print</span>(setting)<br></code></pre></td></tr></table></figure><p>for循环通过这样的方式<mark class="hl-label blue">每次从列表中按顺序取一个元素</mark> ，直到取完所有元素。</p><p>通过<code>range()</code>的方式可以快速定义一个区间，然后可以使用for循环遍历：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">settings=[<span class="hljs-string">&#x27;model&#x27;</span>,<span class="hljs-string">&#x27;speed&#x27;</span>,<span class="hljs-string">&#x27;screen&#x27;</span>]<br><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>):<br>    <span class="hljs-built_in">print</span>(settings[num])<br></code></pre></td></tr></table></figure><p>这样可以获得和之前程序一样的结果。</p><blockquote><p>还可以给range函数定义步长：<code>range(0,5,2)</code>就是从0~4，步长为2的一系列数据：0,2,4。</p></blockquote><h3 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h3><p>字典的每一项都是一个键值对，所以遍历相对列表要复杂一些。</p><h4 id="遍历字典的键"><a href="#遍历字典的键" class="headerlink" title="遍历字典的键"></a>遍历字典的键</h4><p>使用<mark class="hl-label pink">keys()</mark> 方法可以将字典的键以列表的形式返回，再用for循环遍历这列表即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">settings=&#123;<span class="hljs-string">&#x27;model&#x27;</span>:<span class="hljs-string">&#x27;easy&#x27;</span>,<span class="hljs-string">&#x27;speed&#x27;</span>:<span class="hljs-string">&#x27;fast&#x27;</span>&#125;<br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> settings.keys():<br>    <span class="hljs-built_in">print</span>(key)<br><span class="hljs-comment"># 打印model \n speed</span><br></code></pre></td></tr></table></figure><p>实际上，我们对字典进行遍历，<emp>python默认我们遍历的是字典的键</emp>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">settings=&#123;<span class="hljs-string">&#x27;model&#x27;</span>:<span class="hljs-string">&#x27;easy&#x27;</span>,<span class="hljs-string">&#x27;speed&#x27;</span>:<span class="hljs-string">&#x27;fast&#x27;</span>&#125;<br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> settings:<br>    <span class="hljs-built_in">print</span>(key)<br><span class="hljs-comment"># 输出和上面的程序一样</span><br></code></pre></td></tr></table></figure><h4 id="遍历字典的值"><a href="#遍历字典的值" class="headerlink" title="遍历字典的值"></a>遍历字典的值</h4><p>同理，使用<mark class="hl-label blue">values()</mark> 方法可以将字典的值以列表的形式返回，再用for循环遍历这列表即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">settings=&#123;<span class="hljs-string">&#x27;model&#x27;</span>:<span class="hljs-string">&#x27;easy&#x27;</span>,<span class="hljs-string">&#x27;speed&#x27;</span>:<span class="hljs-string">&#x27;fast&#x27;</span>&#125;<br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> settings.values():<br>    <span class="hljs-built_in">print</span>(value)<br><span class="hljs-comment"># 打印easy \n fast</span><br></code></pre></td></tr></table></figure><h4 id="遍历字典的键值"><a href="#遍历字典的键值" class="headerlink" title="遍历字典的键值"></a>遍历字典的键值</h4><p>使用<mark class="hl-label green">items()</mark> 方法可以将字典的键值对作为元组以列表的形式返回：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">settings=&#123;<span class="hljs-string">&#x27;model&#x27;</span>:<span class="hljs-string">&#x27;easy&#x27;</span>,<span class="hljs-string">&#x27;speed&#x27;</span>:<span class="hljs-string">&#x27;fast&#x27;</span>&#125;<br><span class="hljs-built_in">print</span>(settings.items())<br><span class="hljs-comment"># 打印[(&#x27;model&#x27;, &#x27;easy&#x27;), (&#x27;speed&#x27;, &#x27;fast&#x27;)]</span><br></code></pre></td></tr></table></figure><p>可以在for循环中使用两个参数来分别接收键和值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">settings=&#123;<span class="hljs-string">&#x27;model&#x27;</span>:<span class="hljs-string">&#x27;easy&#x27;</span>,<span class="hljs-string">&#x27;speed&#x27;</span>:<span class="hljs-string">&#x27;fast&#x27;</span>&#125;<br><span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> settings.items():<br>    <span class="hljs-built_in">print</span>(k+<span class="hljs-string">&#x27; &#x27;</span>+v)<br><span class="hljs-comment"># 打印model easy \n speed fast</span><br></code></pre></td></tr></table></figure><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>python中while循环真的和C语言差不多了，后面都是一个<mark class="hl-label blue">逻辑表达式</mark> ，<code>True</code>则继续，<code>False</code>则退出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">msg=<span class="hljs-string">&#x27;Hello!&#x27;</span><br><span class="hljs-keyword">while</span> msg!=<span class="hljs-string">&#x27;quit&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(msg)<br>    msg=<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;Please enter a word:&#x27;</span>)<br></code></pre></td></tr></table></figure><div class="note blue modern"><p><mark class="hl-label blue">这里还涉及到两个知识点：</mark> </p><ol><li>python中表示正误的为<code>True</code>和<code>False</code>，相当于C++中的<span class="p red">bool类型</span>，但<span class="p red">开头字母都要大写</span>。</li><li>python中使用<span class="p green">input函数</span>来接受输入。括号中的字符串为<span class="p green">输入提示</span>。</li></ol><p>和C语言一样，python还可以通过<mark class="hl-label blue">break</mark> 和<mark class="hl-label blue">continue</mark> 关键字进行循环控制，因为用法一样，所以就不介绍了。</p></div><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><div class="tip "><p>if语句也是后面加一个条件表达式和冒号即可，和C语言类似。下面讲一些和C有区别的用法。</p></div><h3 id="多个条件"><a href="#多个条件" class="headerlink" title="多个条件"></a>多个条件</h3><p>C语言中可以使用<code>&amp;&amp;</code>和<code>||</code>对多个逻辑表达式进行运算，python则使用的是<mark class="hl-label blue">and</mark> 和<mark class="hl-label blue">or</mark> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">info=&#123;<span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">18</span>,<span class="hljs-string">&#x27;sex&#x27;</span>:<span class="hljs-string">&#x27;male&#x27;</span>&#125;<br><span class="hljs-keyword">if</span> info[<span class="hljs-string">&#x27;age&#x27;</span>]&gt;=<span class="hljs-number">18</span> <span class="hljs-keyword">and</span> info[<span class="hljs-string">&#x27;sex&#x27;</span>]==<span class="hljs-string">&#x27;male&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Welcome,master!&#x27;</span>)<span class="hljs-comment"># 不对劲</span><br></code></pre></td></tr></table></figure><h3 id="if-else结构"><a href="#if-else结构" class="headerlink" title="if-else结构"></a>if-else结构</h3><p>C语言用的是<code>else if</code>，而python使用的是<code>elif</code>。<code>else</code>都是一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">info=&#123;<span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">18</span>,<span class="hljs-string">&#x27;sex&#x27;</span>:<span class="hljs-string">&#x27;male&#x27;</span>&#125;<br><span class="hljs-keyword">if</span> info[<span class="hljs-string">&#x27;age&#x27;</span>]&gt;=<span class="hljs-number">18</span> <span class="hljs-keyword">and</span> info[<span class="hljs-string">&#x27;sex&#x27;</span>]==<span class="hljs-string">&#x27;male&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Welcome,master!&#x27;</span>)<span class="hljs-comment"># 不对劲</span><br><span class="hljs-keyword">elif</span> info[<span class="hljs-string">&#x27;age&#x27;</span>]&gt;=<span class="hljs-number">18</span> <span class="hljs-keyword">and</span> info[<span class="hljs-string">&#x27;sex&#x27;</span>]==<span class="hljs-string">&#x27;female&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Miss, come this way, please&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Welcome to the amusement park!&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="判断列表元素"><a href="#判断列表元素" class="headerlink" title="判断列表元素"></a>判断列表元素</h3><p>使用<code>in</code>和<code>not in</code>可以判断元素是否在列表中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">games=[<span class="hljs-string">&#x27;Senren&#x27;</span>, <span class="hljs-string">&#x27;Sabbat&#x27;</span>, <span class="hljs-string">&#x27;Senren&#x27;</span>]<br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;Senren&#x27;</span> <span class="hljs-keyword">in</span> games:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;决定了，今天就玩千恋万花！&#x27;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;Cafe&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> games:<br>    games.append(<span class="hljs-string">&#x27;Cafe&#x27;</span>)<br></code></pre></td></tr></table></figure><hr><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><div class="note info modern"><p>一个C程序可以看成由函数组成，程序从主函数作为入口开始运行，主函数可以调用其他函数，其他函数之间也可以相互调用。函数之外的全局区则可以定义一些宏和全局变量等。</p><p>而python是一种脚本语言，不存在什么主函数，你写一句程序便运行一句。此时，函数则可看成一个语句块。但是，python的函数调用也并非直接替换那么简单。比如，你在函数外面定义的一个变量，如果不传递给函数的话，函数是访问不到的。下面我们将细讲python中的函数。</p></div><h2 id="函数的定义和使用"><a href="#函数的定义和使用" class="headerlink" title="函数的定义和使用"></a>函数的定义和使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello,&#x27;</span>+name.title()+<span class="hljs-string">&#x27;!&#x27;</span>)<br>greet(<span class="hljs-string">&#x27;sato&#x27;</span>)<br></code></pre></td></tr></table></figure><p>上面就是定义和使用函数的基本姿势。<code>def</code>代表这是一个函数，紧跟函数名的括号里面的是<mark class="hl-label default">形参列表</mark> 。通过冒号引出这个函数，缩进的部分就是函数体。此外<emp>函数调用必须在函数定义之后</emp>。</p><h3 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h3><p>python函数的传递实参的方式和C语言可以有一些不同，可以使用<mark class="hl-label blue">位置实参</mark> ，也可以使用<mark class="hl-label pink">关键字实参</mark> 。</p><h4 id="位置实参"><a href="#位置实参" class="headerlink" title="位置实参"></a>位置实参</h4><p>调用函数时，需要<emp>将每个实参都关联到相应的形参</emp>。<mark class="hl-label orange">基于实参顺序传递参数</mark> 的关联方式就是位置实参。<emp>C语言中传参的方式就可以看成使用位置实参</emp>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span>(<span class="hljs-params">msg,name</span>):</span><br>    <span class="hljs-built_in">print</span>(msg.title()+<span class="hljs-string">&#x27;,&#x27;</span>+name.title()+<span class="hljs-string">&#x27;!&#x27;</span>)<br>greet(<span class="hljs-string">&#x27;goodby&#x27;</span>,<span class="hljs-string">&#x27;sato&#x27;</span>)<br></code></pre></td></tr></table></figure><p>上面程序将<code>&#39;goodby&#39;</code>传递给<code>msg</code>,<code>&#39;sato&#39;</code>传递给<code>name</code>，是按照实参顺序传递的。</p><h4 id="关键字实参"><a href="#关键字实参" class="headerlink" title="关键字实参"></a>关键字实参</h4><p>关键字实参是传递给函数的<mark class="hl-label blue">形参名-实参对</mark> 。通过<emp>在实参列表中指定形参名</emp>，从而将实参与相应形参关联起来。这样我们就<span class="p red">无需考虑函数中实参的调用顺序了</span>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span>(<span class="hljs-params">msg,name</span>):</span><br>    <span class="hljs-built_in">print</span>(msg.title()+<span class="hljs-string">&#x27;,&#x27;</span>+name.title()+<span class="hljs-string">&#x27;!&#x27;</span>)<br>greet(name=<span class="hljs-string">&#x27;sato&#x27;</span>,msg=<span class="hljs-string">&#x27;hello&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="形参默认值"><a href="#形参默认值" class="headerlink" title="形参默认值"></a>形参默认值</h4><p>和C++的缺省参数一样，我们可以<mark class="hl-label pink">给函数形参一个默认值</mark> 。<span class="p red">当我们没有给这个形参传递值时，该形参将采用预先设定的默认值</span>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span>(<span class="hljs-params">msg=<span class="hljs-string">&#x27;hello&#x27;</span>,name=<span class="hljs-string">&#x27;Li Hua&#x27;</span></span>):</span><br>    <span class="hljs-built_in">print</span>(msg.title()+<span class="hljs-string">&#x27;,&#x27;</span>+name.title()+<span class="hljs-string">&#x27;!&#x27;</span>)<br>greet(name=<span class="hljs-string">&#x27;sato&#x27;</span>)<br></code></pre></td></tr></table></figure><p>由于python可以使用关键字实参，不要求实参列表的顺序和形参列表相同，<emp>所以默认形参可以放在形参列表的任意位置</emp>，而不必像C++一样必须把默认形参放在形参列表的后面。</p><div class="note info flat"><p><span class="p center small">使用关键字实参怎么知道形参名有哪些？</span></p><p>当使用自己的函数时，形参名自己当然清楚。但是调用其他人的函数时，我们怎么知道这个函数的形参名有哪些呢？</p><p>其实很简单的说，自己去翻一下那个文件不就知道了吗。当然，这一步一般编辑器就帮我们做了，我们只需要看编辑器给出的提示即可。</p><p><img src="https://cloud.fullcomb.top/private/source/image/python/3.png" alt></p></div><h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>在上面的函数提示中，我们看到了这样的提示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">(function) greet: (msg: <span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;hello&#x27;</span>, name: <span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;Li Hua&#x27;</span>) -&gt; <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>前面的还好理解，后面的<code>-&gt;None</code>是什么意思呢？其实，这里的<code>None</code>指的就是函数的返回值。</p><p>和C语言一样，函数通过<code>return</code>关键字来传递返回值。所以我们用函数返回值来改写一下之前的程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span>(<span class="hljs-params">msg=<span class="hljs-string">&#x27;hello&#x27;</span>,name=<span class="hljs-string">&#x27;Li Hua&#x27;</span></span>):</span><br>    <span class="hljs-keyword">return</span>(msg.title()+<span class="hljs-string">&#x27;,&#x27;</span>+name.title()+<span class="hljs-string">&#x27;!&#x27;</span>)<br><span class="hljs-built_in">print</span>(greet(name=<span class="hljs-string">&#x27;sato&#x27;</span>))<br></code></pre></td></tr></table></figure><h3 id="禁止修改函数列表"><a href="#禁止修改函数列表" class="headerlink" title="禁止修改函数列表"></a>禁止修改函数列表</h3><p>前面我们讲过，将一个列表用<code>=</code>复制给另一个变量，<emp>相当于复制列表的地址</emp>，最后该变量相当于是原来列表的<mark class="hl-label pink">引用</mark> 。</p><p>同理，如果我们<span class="p blue">直接将列表作为实参传递给函数</span>，那么<mark class="hl-label blue">对应的形参相当于也是该列表的引用</mark> ，函数中对列表的修改将直接改变列表本身。</p><p>所以，和之前一样，我们使用列表切片来复制列表的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span>(<span class="hljs-params">info</span>):</span><br>    info[<span class="hljs-number">0</span>]=<span class="hljs-string">&#x27;goodby&#x27;</span><br>    <span class="hljs-built_in">print</span>(info)<br>info=[<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;sato&#x27;</span>]<br>greet(info[:])<br><span class="hljs-built_in">print</span>(info)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[<span class="hljs-string">&#x27;goodby&#x27;</span>, <span class="hljs-string">&#x27;sato&#x27;</span>]<br>[<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;sato&#x27;</span>]<br></code></pre></td></tr></table></figure><p>但是如果函数中不涉及到修改列表值的问题的话，我们直接传递列表即可。特别是列表元素很多的时候，列表的拷贝会花很多时间。</p><h2 id="多文件编程"><a href="#多文件编程" class="headerlink" title="多文件编程"></a>多文件编程</h2><div class="note info flat"><p>在C语言中，我们<span class="p red">多文件编程</span>的方式是把函数声明放在头文件中，函数实现放在c或cpp文件中。分别编译后再将生成的.obj文件链接起来即可。</p></div><p><emp>使用python进行多文件编程更为简单</emp>，因为它没有函数声明之类复杂的东西。我们把函数写在一个文件中，这个文件就称为<mark class="hl-label blue">模块</mark> 。当需要这函数的时候，使用<mark class="hl-label pink">import</mark> 引入这个函数即可。</p><h3 id="导入整个模块"><a href="#导入整个模块" class="headerlink" title="导入整个模块"></a>导入整个模块</h3><p>使用<mark class="hl-label default">import&nbsp模块名</mark> 即可将整个模块导入：</p><p><img src="https://cloud.fullcomb.top/private/source/image/python/4.png" alt></p><p>注意这种导入方式还存在一个<mark class="hl-label orange">作用域</mark> 的问题，即<emp>调用的函数前面需要加上模块的名字</emp>。</p><h3 id="导入指定函数"><a href="#导入指定函数" class="headerlink" title="导入指定函数"></a>导入指定函数</h3><p>我们可以只从那个模块中导入指定的一个或几个函数，<mark class="hl-label green">这时就不需要作用域了</mark> 。</p><p><img src="https://cloud.fullcomb.top/private/source/image/python/5.png" alt></p><p>如果我们想要导入整个模块的所有函数，而不想加上作用域<psw>（就是懒）</psw>，那么就可以使用<code>*</code>这个符号。</p><p><img src="https://cloud.fullcomb.top/private/source/image/python/6.png" alt></p><p>但是要求就是现在文件中已有的函数<emp>不能与导入的函数同名</emp>。</p><h3 id="为模块指定别名"><a href="#为模块指定别名" class="headerlink" title="为模块指定别名"></a>为模块指定别名</h3><p>使用<mark class="hl-label pink">as</mark> 可以为模块指定别名，这在一定程度上可以减少输入的字数（笑</p><p><img src="https://cloud.fullcomb.top/private/source/image/python/7.png" alt></p><hr><p>现在python还差<mark class="hl-label blue">类</mark> 的内容没有讲，这部分我打算放在《python和C++面向对象》的另外一篇文章来讲。</p><p>此外，我打算之后还学习python的编码规范，还会在另一篇文章里介绍<emp>怎样写出格式优美的python代码</emp>。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 大二下 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【例题】广搜与深搜</title>
      <link href="/post/b0310c2.html"/>
      <url>/post/b0310c2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="tip "><p>这次先从一道经典题说起。先通过理解这道题的思路，体会BFS与DFS算法的思想后，再对BFS和DFS做进一步讨论。</p></div><h1 id="图像渲染"><a href="#图像渲染" class="headerlink" title="图像渲染"></a>图像渲染</h1><details class="folding-tag" green><summary> 题目 </summary>              <div class="content">              <div class="note green flat"><p>有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。</p><p>给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。</p><p>为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。</p><p>最后返回经过上色渲染后的图像。</p></div><p><mark class="hl-label blue">示例：</mark> </p><blockquote><p>输入: image = [[1,1,1],[1,1,0],[1,0,1]],sr = 1, sc = 1, newColor = 2<br>    输出: [[2,2,2],[2,2,0],[2,0,1]]</p></blockquote><p>如果觉得题目不好理解，可以到原题的讨论区看一下：</p><div class="tag link"><a class="link-card" title="flood-fill" href="https://leetcode-cn.com/problems/flood-fill/"><div class="left"><img src="https://static.leetcode-cn.com/cn-mono-assets/production/assets/logo-dark-cn.c42314a8.svg"></div><div class="right"><p class="text">flood-fill</p><p class="url">https://leetcode-cn.com/problems/flood-fill/</p></div></a></div>              </div>            </details><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>我们首先要得到这个图的边界，使用<code>vector::size()</code>即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> row=image.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">int</span> column=image[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<span class="hljs-comment">//这个比较妙，学一学</span><br><span class="hljs-comment">//int column=sizeof(image)/(sizeof(int)*row)</span><br><span class="hljs-comment">//这个low得一批👆</span><br></code></pre></td></tr></table></figure><p>然后把<code>image[sr][sc]</code>改为新的数字。问题是我们要通过怎样的方式来访问和(sr,sc)颜色相同的所有点？</p><p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/4/1.png" alt></p><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><div class="note info modern"><p>我们这里就这道题来梳理BFS的思路。</p></div><details class="folding-tag" blue open><summary> 思路图解，引用自力扣 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/4/3.gif" alt></p>              </div>            </details><p>这里用到了队列的数据结构：首先要把(sr,sc)这个点入队。然后访问队首元素，如果它上下左右的点和它值相同，那么这个点也入队，最后队首元素出队；<emp>一直循环，直到队列为空</emp>。</p><p>用<mark class="hl-label blue">队列来表示</mark> 就是这样的：</p><p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/4/4.gif" alt></p><p>按照这个思路，就可以写出下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">floodFill</span>(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; image, <span class="hljs-keyword">int</span> sr, <span class="hljs-keyword">int</span> sc, <span class="hljs-keyword">int</span> newColor) &#123;<br>        <span class="hljs-keyword">int</span> flag=image[sr][sc];<br>        <span class="hljs-keyword">if</span>(flag==newColor) <span class="hljs-keyword">return</span> image;<br>        image[sr][sc]=newColor;<br>        <span class="hljs-keyword">int</span> row=image.<span class="hljs-built_in">size</span>(),column=image[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; dir[<span class="hljs-number">4</span>]=&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;;<br>        queue&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; que;<br>        que.<span class="hljs-built_in">emplace</span>(sr,sc);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:dir)&#123;<br>                <span class="hljs-keyword">int</span> r=que.<span class="hljs-built_in">front</span>().first+i.second;<br>                <span class="hljs-keyword">int</span> c=que.<span class="hljs-built_in">front</span>().second+i.first;<br>                <span class="hljs-keyword">if</span>(r&lt;<span class="hljs-number">0</span>||r&gt;=row||c&lt;<span class="hljs-number">0</span>||c&gt;=column) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(image[r][c]==flag)&#123;<br>                    que.<span class="hljs-built_in">emplace</span>(r,c);<br>                    image[r][c]=newColor;<br>                &#125;<br>            &#125;<br>            que.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> image;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里我用<code>pair</code>来表示坐标，<code>pair::first</code>就是横坐标，<code>pair::second</code>就是纵坐标；用<code>pair&lt;int,int&gt;</code>类型的数组来管理左、上、右、下四个方向。每次要访问一个点的这四个方向时，直接使用<mark class="hl-label pink">基于范围的for循环</mark> 即可。</p><details class="folding-tag" blue><summary> judge </summary>              <div class="content">              <p>起伏还比较大，这里我选用比较平均的一个结果：</p><p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/4/2.png" alt></p><p>看来性能并不是特别好……</p>              </div>            </details><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><div class="note info modern"><p>我们这里就这道题来梳理DFS的思路。</p></div><details class="folding-tag" open blue><summary> 思路图解，自己仿照上面BFS的图用PPT做的 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/4/5.gif" alt></p>              </div>            </details><p>可以用栈的数据结构来表示：首先把(sr,sc)这个点入栈，然后依次访问其左、上、右、下四个点，如果它的值为1，那么这个点入栈；如果四个方向都访问了，那么这个点出栈。当栈为空的时候，结束。</p><p>用<mark class="hl-label blue">队列来表示</mark> 就是这样的：</p><p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/4/6.gif" alt></p><p>于是按照这个思路，可以写出下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">floodFill</span>(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; image, <span class="hljs-keyword">int</span> sr, <span class="hljs-keyword">int</span> sc, <span class="hljs-keyword">int</span> newColor) &#123;<br>        <span class="hljs-keyword">int</span> flag=image[sr][sc];<br>        <span class="hljs-keyword">if</span>(flag==newColor) <span class="hljs-keyword">return</span> image;<br>        image[sr][sc]=newColor;<br>        <span class="hljs-keyword">int</span> row=image.<span class="hljs-built_in">size</span>(),column=image[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; dir[]=&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;;<br>        stack&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; stk;<br>        stk.<span class="hljs-built_in">emplace</span>(sr,sc);<br>        <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:dir)&#123;<br>                <span class="hljs-keyword">int</span> r=stk.<span class="hljs-built_in">top</span>().first+i.second;<br>                <span class="hljs-keyword">int</span> c=stk.<span class="hljs-built_in">top</span>().second+i.first;<br>                <span class="hljs-keyword">if</span>(i.first==<span class="hljs-number">0</span> &amp;&amp; i.second==<span class="hljs-number">-1</span>) stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(r&lt;<span class="hljs-number">0</span>||r&gt;=row||c&lt;<span class="hljs-number">0</span>||c&gt;=column) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(image[r][c]==flag)&#123;<br>                    image[r][c]=newColor;<br>                    stk.<span class="hljs-built_in">emplace</span>(r,c);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> image;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" blue><summary> judge </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/4/7.png" alt></p><p>看起来比之前的做法并没有好到哪里去……</p>              </div>            </details><h2 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h2><div class="tip "><p>众所周知，可以写成递归形式的程序，也可以用栈来写。实际上，DFS就可以写成递归。</p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; image, <span class="hljs-keyword">int</span> sr, <span class="hljs-keyword">int</span> sc, <span class="hljs-keyword">int</span> newColor)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> row=image.<span class="hljs-built_in">size</span>(),column=image[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> flag=image[sr][sc];<br>        image[sr][sc]=newColor;<br>        pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; dir[]=&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:dir)&#123;<br>            <span class="hljs-keyword">int</span> r=sr+i.second,c=sc+i.first;<br>            <span class="hljs-keyword">if</span>(r&lt;<span class="hljs-number">0</span>||r&gt;=row||c&lt;<span class="hljs-number">0</span>||c&gt;column) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(image[r][c]==flag) <span class="hljs-built_in">DFS</span>(image,r,c,newColor);<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">floodFill</span>(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; image, <span class="hljs-keyword">int</span> sr, <span class="hljs-keyword">int</span> sc, <span class="hljs-keyword">int</span> newColor)&#123;<br>        <span class="hljs-keyword">if</span>(image[sr][sc]!=newColor)<br>            <span class="hljs-built_in">DFS</span>(image,sr,sc,newColor);<br>        <span class="hljs-keyword">return</span> image;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>感觉递归形式其实还更好理解，<psw>（也更好写，毕竟一遍过</psw></p><details class="folding-tag" cyan><summary> judge </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/4/8.png" alt></p><p>看来性能比非递归形式的要好一些……</p><p>我一般认为递归应该会慢一些来着，因为有函数调用的额外开销。但是这道题就有点反我的常理了，下次去问一下老师递归好还是非递归好。</p>              </div>            </details><h1 id="BFS与DFS"><a href="#BFS与DFS" class="headerlink" title="BFS与DFS"></a>BFS与DFS</h1><div class="tip "><p>至此，我们可以总结一下广度优先搜索(BFS)和深度优先搜索(DFS)算法了。</p></div><ol><li><p>这两个算法都是图的算法，对于树就类似于<emp>层序遍历</emp>和<emp>前中后三序遍历</emp>（当然也有区别，比如遍历和搜索不是一个概念。<mark class="hl-label pink">遍历可以看成所有点都满足条件的搜索</mark> ）。</p></li><li><p>BFS用到了队列的数据结构，DFS用到了栈的数据结构，也可以写成递归的形式。</p></li><li>上面的题可以看成一个四叉树的模型，一个点的四个方向就是四个孩子，如果那个方向超过边缘了就相当于对应孩子为空。</li></ol><h1 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a>岛屿的最大面积</h1><details class="folding-tag" cyan><summary> 题目 </summary>              <div class="content">              <div class="note orange flat"><p>给你一个大小为 m x n 的二进制矩阵 grid 。</p><p>岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p><p>岛屿的面积是岛上值为 1 的单元格的数目。</p><p>计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。</p></div><p><mark class="hl-label blue">示例：</mark> </p><blockquote><p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/4/9.jpg" alt><br>输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]<br>输出：6</p></blockquote>              </div>            </details><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们可以从上往下，从左往右遍历这张图。如果碰到了1，那么就进行广度优先/深度优先搜索，并且将统计了的1改为0，这样就不会在一块上遍历多次了。</p><h2 id="广度优先搜索-1"><a href="#广度优先搜索-1" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getAreaofIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid,pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; p)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> area=<span class="hljs-number">1</span>,row=grid.<span class="hljs-built_in">size</span>(),column=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        queue&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &gt; que;<br>        pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; dir[]=&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;;<br>        que.<span class="hljs-built_in">push</span>(p);<br>        grid[p.first][p.second]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:dir)&#123;<br>                <span class="hljs-keyword">int</span> r=que.<span class="hljs-built_in">front</span>().first+i.second;<br>                <span class="hljs-keyword">int</span> c=que.<span class="hljs-built_in">front</span>().second+i.first;<br>                <span class="hljs-keyword">if</span>(r&lt;<span class="hljs-number">0</span>||r&gt;=row||c&lt;<span class="hljs-number">0</span>||c&gt;=column) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(grid[r][c]!=<span class="hljs-number">0</span>)&#123;<br>                    grid[r][c]=<span class="hljs-number">0</span>;<br>                    que.<span class="hljs-built_in">emplace</span>(r,c);<br>                    area++;<br>                &#125;<br>            &#125;<br>            que.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> area;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> row=grid.<span class="hljs-built_in">size</span>(),column=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(),Max=<span class="hljs-number">0</span>;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;row;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;column;j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>) <br>                    Max=<span class="hljs-built_in">max</span>(Max,<span class="hljs-built_in">getAreaofIsland</span>(grid,&#123;i,j&#125;));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Max;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" yellow><summary> judge </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/4/10.png" alt></p><p>性能并不是很好……</p>              </div>            </details><h2 id="深度优先搜索-1"><a href="#深度优先搜索-1" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getAreaofIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid,pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; p)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> area=<span class="hljs-number">1</span>,row=grid.<span class="hljs-built_in">size</span>(),column=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        stack&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; stk;<br>        pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; dir[]=&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;;<br>        stk.<span class="hljs-built_in">push</span>(p);<br>        grid[p.first][p.second]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:dir)&#123;<br>                <span class="hljs-keyword">int</span> r=stk.<span class="hljs-built_in">top</span>().first+i.second;<br>                <span class="hljs-keyword">int</span> c=stk.<span class="hljs-built_in">top</span>().second+i.first;<br>                <span class="hljs-keyword">if</span>(i.first==<span class="hljs-number">0</span>&amp;&amp;i.second==<span class="hljs-number">-1</span>) stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(r&lt;<span class="hljs-number">0</span>||r&gt;=row||c&lt;<span class="hljs-number">0</span>||c&gt;=column) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(grid[r][c]==<span class="hljs-number">1</span>)&#123;<br>                    grid[r][c]=<span class="hljs-number">0</span>;<br>                    stk.<span class="hljs-built_in">push</span>(&#123;r,c&#125;);<br>                    area++;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> area;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> row=grid.<span class="hljs-built_in">size</span>(),column=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(),Max=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;row;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;column;j++)<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>) <br>                    Max=<span class="hljs-built_in">max</span>(Max,<span class="hljs-built_in">getAreaofIsland</span>(grid,&#123;i,j&#125;));<br>        <span class="hljs-keyword">return</span> Max;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" yellow><summary> judge </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/4/11.png" alt></p><p>和之前的解法依旧旗鼓相当……</p>              </div>            </details><h2 id="DFS的递归形式"><a href="#DFS的递归形式" class="headerlink" title="DFS的递归形式"></a>DFS的递归形式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getAreaofIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid,pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; p)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> area=<span class="hljs-number">1</span>,row=grid.<span class="hljs-built_in">size</span>(),column=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        grid[p.first][p.second]=<span class="hljs-number">0</span>;<br>        pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; dir[]=&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:dir)&#123;<br>            <span class="hljs-keyword">int</span> r=p.first+i.second,c=p.second+i.first;<br>            <span class="hljs-keyword">if</span>(r&lt;<span class="hljs-number">0</span>||r&gt;=row||c&lt;<span class="hljs-number">0</span>||c&gt;=column) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(grid[r][c]==<span class="hljs-number">1</span>)<br>                area+=<span class="hljs-built_in">getAreaofIsland</span>(grid,&#123;r,c&#125;);<br>        &#125;<br>        <span class="hljs-keyword">return</span> area;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> row=grid.<span class="hljs-built_in">size</span>(),column=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(),Max=<span class="hljs-number">0</span>;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;row;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;column;j++)<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>) <br>                    Max=<span class="hljs-built_in">max</span>(Max,<span class="hljs-built_in">getAreaofIsland</span>(grid,&#123;i,j&#125;));<br>        <span class="hljs-keyword">return</span> Max;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" yellow><summary> judge </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/4/12.png" alt></p>              </div>            </details><hr>]]></content>
      
      
      <categories>
          
          <category> 大二下 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法学习 </tag>
            
            <tag> weekly算法训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STL】函数模板与类模板</title>
      <link href="/post/49edfbdb.html"/>
      <url>/post/49edfbdb.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>从万能的<mark class="hl-label blue">《C++&nbspPrimer&nbspPlus》</mark> 里引用这样一段话：</p><div class="tip "><p>在C++发展的早期，大多数人都没有想到模板函数和模板类会有这么强大而有用，他们甚至没有就这个主题发挥想象力。但聪明而专注的程序员挑战模板技术的极限，阐述了各种可能性。根据熟悉模板的程序员提供的反馈，C++98标准做了相应的修改，并添加了相应的标准模板库。从此以后，模板程序员在不断探索各种可能性，并消除模板的局限性。</p></div><p>“template”的曲折历史和程序员们的”laziness”可见一斑（笑）。譬如，我们在做算法题的时候，<emp>使用标准模板库中的容器类</emp>可以极大地减少代码量，提高做题效率。</p><div class="note orange flat"><p>在这个专题中，我打算用几篇的内容，对模板的定义与使用，算法竞赛常用的STL，以及C++11的一些新特性进行简要的讲解（或许只能算作介绍）。希望能对即将到来的蓝桥杯省赛和ACM校赛有些许帮助。</p></div><hr><h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><h2 id="使用函数模板的原因"><a href="#使用函数模板的原因" class="headerlink" title="使用函数模板的原因"></a>使用函数模板的原因</h2><p>之前我们讲了函数重载。使用函数重载，可以减少函数名称的冗余。但是我们仍要对各重载函数一一进行实现，尽管这几个函数都基本一样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp; a,<span class="hljs-keyword">int</span> &amp; b)</span></span>&#123;<br>    a=a+b;<br>    b=a-b;<br>    a=a-b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(<span class="hljs-keyword">float</span> &amp; a,<span class="hljs-keyword">float</span> &amp; b)</span></span>&#123;<br>    a=a+b;<br>    b=a-b;<br>    a=a-b;<br>&#125;<br><span class="hljs-comment">//double,char等同理</span><br></code></pre></td></tr></table></figure><div class="note warning modern"><p>显然函数重载仍然存在有冗余！那么我们可不可以把这几个函数都写在一起，只用写一遍即可？<span class="p red"><strong>这时我们就要用到函数模板！</strong></span></p></div><h2 id="函数模板的声明和定义"><a href="#函数模板的声明和定义" class="headerlink" title="函数模板的声明和定义"></a>函数模板的声明和定义</h2><mark class="hl-label blue">《C++&nbspPrimer&nbspPlus》</mark> 上对函数模板的说明为：<div class="note info modern"><p>使用泛型来定义函数。当泛型用具体的类型替换，即将类型作为参数传入函数模板后，编译器就会自动生成相应的函数。</p></div><p>这里泛型的意思就是不是特指某一种类型，而可以是多种类型。</p><h3 id="定义函数模板"><a href="#定义函数模板" class="headerlink" title="定义函数模板"></a>定义函数模板</h3><p>我们先尝试使用函数模板来解决上面函数重载冗余的问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(T &amp; a,T &amp; b)</span></span>&#123;<br>    a=a+b;<br>    b=a-b;<br>    a=a-b;<br>&#125;<br></code></pre></td></tr></table></figure><emp>这就是定义一个函数模板的形式。</emp><div class="note red simple"><p><code>template &lt;typename T&gt;</code>告诉编译器这是一个函数模板，称为<mark class="hl-label pink">模板头</mark> ；其中的<code>typename</code>可以用<code>class</code>替换，但<code>class</code>可能与类在理解上产生歧义，所以更建议用<code>typename</code>；<code>T</code>则是自定义的类型名，和变量的命名方式相同，但<code>T</code>是一个比较常用的命名，我们遵循这个习惯就好啦。</p></div><h3 id="使用函数模板"><a href="#使用函数模板" class="headerlink" title="使用函数模板"></a>使用函数模板</h3><div class="note info modern"><p>我们定义的模板只是一个程式，并不是函数。所以使用函数模板的时候还要有相应的函数才行！即进行<mark class="hl-label blue">实例化</mark> 。</p></div><h4 id="隐式实例化"><a href="#隐式实例化" class="headerlink" title="隐式实例化"></a>隐式实例化</h4><p>当我们<mark class="hl-label green">向函数模板传入类型作为参数</mark> 时，编译器就会自动生成一个相应类型的函数。示例程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(T &amp; a,T &amp; b)</span></span>&#123;<br>    a=a+b;<br>    b=a-b;<br>    a=a-b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a=<span class="hljs-number">1</span>,b=<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">char</span> c=<span class="hljs-string">&#x27;A&#x27;</span>,d=<span class="hljs-string">&#x27;B&#x27;</span>;<br>    std::cout&lt;&lt;a&lt;&lt;b&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;c&lt;&lt;d&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-built_in">Swap</span>(a,b);<span class="hljs-built_in">Swap</span>(c,d);<br>    std::cout&lt;&lt;a&lt;&lt;b&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;c&lt;&lt;d;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>正确输出：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">12 </span>AB<br><span class="hljs-symbol">21 </span>BA<br></code></pre></td></tr></table></figure><p>此处<emp>编译器隐式地为我们生成了两个相应的函数</emp>。这里编译器做了两件事，<mark class="hl-label blue">一是匹配参数类型[1]</mark> ，<mark class="hl-label green">二是生成相应函数[2]</mark> 。当然，我们也可以自己显示地从模板生成函数实例👇</p><h4 id="显示实例化"><a href="#显示实例化" class="headerlink" title="显示实例化"></a>显示实例化</h4><p>使用时在函数模板名后添加类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Swap&lt;<span class="hljs-keyword">int</span>&gt;(a,b);<br></code></pre></td></tr></table></figure><p>这样就不用编译器来帮我们推断参数类型了，相当于我们自己完成了上面的<mark class="hl-label blue">[1]</mark> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> Swap&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">int</span>&amp;,<span class="hljs-keyword">int</span>&amp;);<br></code></pre></td></tr></table></figure><p>通过这种方式就在函数外创建了一个传入参数为<code>int</code>的函数模板的实例，然后使用时直接<code>Swap(a,b)</code>即可。这就相当于我们自己完成了上面的<mark class="hl-label green">[2]</mark> 。</p><p>当然上面两个都可以用上，那就没编译器啥事了（bushi</p><h3 id="函数模板的声明"><a href="#函数模板的声明" class="headerlink" title="函数模板的声明"></a>函数模板的声明</h3><p>和一般的函数一样，我们也可以<emp>把函数模板的声明放在前面，函数模板的实现放在程序的后面</emp>；或<emp>函数模板声明放在.h头文件中，实现放在cpp文件中</emp>。</p><p>如，上面的程序我们可以这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(T&amp;,T&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a=<span class="hljs-number">1</span>,b=<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">char</span> c=<span class="hljs-string">&#x27;A&#x27;</span>,d=<span class="hljs-string">&#x27;B&#x27;</span>;<br>    std::cout&lt;&lt;a&lt;&lt;b&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;c&lt;&lt;d&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-built_in">Swap</span>(a,b);<span class="hljs-built_in">Swap</span>(c,d);<br>    std::cout&lt;&lt;a&lt;&lt;b&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;c&lt;&lt;d;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(T &amp; a,T &amp; b)</span></span>&#123;<br>    a=a+b;<br>    b=a-b;<br>    a=a-b;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<mark class="hl-label pink">函数模板声明的形式如下：</mark> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(T&amp;,T&amp;)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="函数模板的具体化"><a href="#函数模板的具体化" class="headerlink" title="函数模板的具体化"></a>函数模板的具体化</h2><mark class="hl-label orange">我们先来分析一下函数模板的缺陷：</mark> <div class="note warning flat"><p>比如写一个比大小的函数模板。如果传入的类型为<code>int</code>，那一般是没问题的；如果传入的类型为<code>vector&lt;int&gt;</code>，那就是比较的数组的长短。但如果我们实际想要比较的是数组第一个元素的大小呢？这样就会产生和我们的预期不一样的结果。</p></div><p>总结一下，函数模板的问题就是<mark class="hl-label blue">因使用情况而异，对某些类型的处理可能不通用。</mark> 我们的想法就是<emp>单独为这种类型写一个模板作为该函数模板的特例</emp>，这就是函数模板的<mark class="hl-label pink">具体化</mark> 。</p><p>如下面的程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">short</span> <span class="hljs-title">judge</span><span class="hljs-params">(T a,T b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a&gt;b) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a&lt;b) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; a=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,b=&#123;<span class="hljs-number">1</span>&#125;;<br>    cout&lt;&lt;<span class="hljs-built_in">judge</span>(a,b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>它比较的是两个整型数组的长短。如果想要比较整型第一个元素的大小同时不影响其他类型的比较，我们就要为<code>vector&lt;int&gt;</code>提供函数模板的具体化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">short</span> <span class="hljs-title">judge</span><span class="hljs-params">(T a,T b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a&gt;b) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a&lt;b) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-function"><span class="hljs-keyword">short</span> <span class="hljs-title">judge</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; a,vector&lt;<span class="hljs-keyword">int</span>&gt; b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]&gt;b[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]&lt;b[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; a=&#123;<span class="hljs-number">1</span>&#125;,b=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>    cout&lt;&lt;<span class="hljs-built_in">judge</span>(a,b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样遇到<code>vector&lt;int&gt;</code>类型，就会优先执行具体化的函数模板。即<mark class="hl-label orange">优先级：具体化的函数模板>一般的函数模板</mark> 。</p><div class="tip "><p>函数模板还支持重载，但<mark class="hl-label blue">前提是不能有歧义</mark> 。重载的方式和一般的函数相同，所以不展开叙述。</p></div><h1 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h1><div class="note info flat"><p>因为类可以对数据结构进行封装，而数据结构是对数据的组织方式，与数据类型关系不大，所以在类中引入泛型则是很有意义的。可以说，类模板更能体现出模板的强大之处。</p></div><h2 id="模板类的定义"><a href="#模板类的定义" class="headerlink" title="模板类的定义"></a>模板类的定义</h2><p>请先观察下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    T data;<br>    ListNode* next;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ListNode</span>();<span class="hljs-comment">//构造函数</span><br>    <span class="hljs-comment">//对链表节点的操作</span><br>&#125;<br><span class="hljs-comment">//构造函数的实现，注意写法！</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>ListNode&lt;T&gt;::<span class="hljs-built_in">ListNode</span>()&#123;&#125;<br><span class="hljs-comment">//其他函数的实现同理</span><br></code></pre></td></tr></table></figure><p>和函数模板一样，模板头都是<code>template &lt;typename T&gt;</code>，同时在类中用<code>T</code>来表示泛型。值得注意的是（上面的代码以构造函数为例），成员函数如果要在类外实现的话，<mark class="hl-label pink">作用域</mark> 需要这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>ListNode&lt;T&gt;::<span class="hljs-built_in">ListNode</span>()&#123;&#125;<br></code></pre></td></tr></table></figure><p>即先加上模板头<emp>表示是模板类中的成员函数</emp>；再再类名后加上<code>&lt;T&gt;</code><emp>表示类名</emp>（可以理解为类名）。</p><h2 id="模板类的使用"><a href="#模板类的使用" class="headerlink" title="模板类的使用"></a>模板类的使用</h2><p>和函数模板一样，类模板在使用前也要先<mark class="hl-label pink">实例化</mark> ！</p><div class="tip "><p>注意类模板的实例化和类的实例化的区别：<span class="p yellow">类模板实例化得到类；类实例化得到对象</span>。</p></div><h3 id="隐式实例化-1"><a href="#隐式实例化-1" class="headerlink" title="隐式实例化"></a>隐式实例化</h3><emp>我们一般都使用隐式实例化</emp>：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ListNode&lt;<span class="hljs-keyword">int</span>&gt; listNodei;<br></code></pre></td></tr></table></figure><p>我们传入类型参数给类模板，编译器就会自动生成对应类型的类。</p><h3 id="显示实例化-1"><a href="#显示实例化-1" class="headerlink" title="显示实例化"></a>显示实例化</h3><p>我们也可以事先”手动”将模板类实例化为类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//将模板类实例化为类</span><br><span class="hljs-keyword">template</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>&lt;</span><span class="hljs-keyword">int</span>&gt;;<br><span class="hljs-comment">//使用实例化后的类生成对象</span><br>ListNode&lt;<span class="hljs-keyword">int</span>&gt; listNodei;<br></code></pre></td></tr></table></figure><h2 id="多类型参数和非类型参数"><a href="#多类型参数和非类型参数" class="headerlink" title="多类型参数和非类型参数"></a>多类型参数和非类型参数</h2><h3 id="多类型参数"><a href="#多类型参数" class="headerlink" title="多类型参数"></a>多类型参数</h3><p>如果一个模板类需要自定义多个参数类型，那么就可以使用多类型参数，即<mark class="hl-label green">一次性传入多个参数</mark> ，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T,U&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Map</span>&#123;</span><br>    T key;<br>    U value;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="非模板参数"><a href="#非模板参数" class="headerlink" title="非模板参数"></a>非模板参数</h3><p>如果类中有一个数组，我们还需要自定义数组的大小，那么就可以<mark class="hl-label blue">在传入类型参数时也传入非类型参数：</mark> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">int</span> n&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span>&#123;</span><br>    <span class="hljs-keyword">char</span> str[n]; <br>&#125;<br></code></pre></td></tr></table></figure><div class="tip "><p>实际上，也可以使用构造函数实现数组大小的初始化，两种方式各有优劣：</p><ol><li>使用构造函数的速度比使用非模板参数要慢一些。因为构造函数用到的是堆空间，而非模板参数遇到的是栈空间。</li><li>但使用非模板参数时，即使<code>T</code>是相同的，如果<code>n</code>不同，那么编译器就会隐式生成不同的类；而构造函数<code>n</code>不同，类依然只有一个。</li></ol></div><hr><p>函数模板和类模板的简要介绍就是这些。</p><div class="note green modern"><p>你已经学会了模板的基本语法，来写一个STL吧！（x）</p><p>你已经学会了基本的与或非门，来做一台电脑吧！😁（√）</p></div><p>揩烷哮的，要自己写STL，还需要了解迭代器，分配器等知识。这又是另一个故事……(to be continued)</p>]]></content>
      
      
      <categories>
          
          <category> 大二下 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++程序设计 </tag>
            
            <tag> STL </tag>
            
            <tag> 算法竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【分享】基于云盘搭建图床和个人影音库</title>
      <link href="/post/46399fd8.html"/>
      <url>/post/46399fd8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><div class="note info modern"><p>实现本文提到的所有功能，只需要一个云服务器(配置无所谓)和一个阿里云盘，还有自己的电脑即可。如果你有这个配置（<psw>穷逼配置</psw>,一般都有吧？），那么不妨看看这篇文章。<mark class="hl-label red">多图警告⚠</mark> </p></div><p>之前阿里云盘不是火起来了嘛，自己也用了阿里云盘好久，感觉还是挺不错的（<psw>除了一些特殊的文件被和谐了以外……</psw>），而且新的玩法也层出不穷。这篇文章<mark class="hl-label pink">介绍</mark> 如何以阿里云盘为核心，实现以下功能：</p><ol><li>基于<mark class="hl-label blue">阿里云盘</mark> 和<mark class="hl-label pink">OneManager</mark> 搭建网盘外链分享程序用于不限速文件分享和博客图床。</li><li>使用<mark class="hl-label green">CloudDrive</mark> 将阿里云盘本地化，用于搭建PLEX影音库。</li><li>使用<mark class="hl-label default">Zerotier</mark> 作为VPN实现P2P内网穿透，同时使用<mark class="hl-label orange">云服务器</mark> 作为moon节点加速打洞。</li></ol><blockquote><p>总结一下，它们相互之间的关系可以用下面这张图来表示：（有点潦草，大佬轻喷）<img src="https://cloud.fullcomb.top/private/source/image/share/cover.png" alt></p></blockquote><div class="tip "><p>网盘并不是完全可靠的。<emp>首先重要文件千万不要放网盘里</emp>！就我上面的使用而言，图床还好，毕竟这些图片没什么大问题，阿里不可能随便和谐。但是真要搭建影音库的话，还是得上大硬盘甚至NAS，因为电影等可能涉及到版权问题，阿里删不删说不清。</p></div><h1 id="OneManager搭建网盘目录"><a href="#OneManager搭建网盘目录" class="headerlink" title="OneManager搭建网盘目录"></a>OneManager搭建网盘目录</h1><div class="note pink flat"><p><span class="p center small"><strong>效果预览</strong></span></p><div class="tag link"><a class="link-card" title="OneManager" href="https://cloud.fullcomb.top/public"><div class="left"><img src="https://cloud.fullcomb.top/favicon.ico"></div><div class="right"><p class="text">OneManager</p><p class="url">https://cloud.fullcomb.top/public</p></div></a></div></div><div class="tip warning"><p>前置步骤:建议安装宝塔面板，装好LNMP环境(推荐使用Nginx)。下面以宝塔面板上的操作为演示。</p></div><ol><li><p>点击网站，点击添加站点，去创建一个网站：</p><p><img src="https://cloud.fullcomb.top/private/source/image/share/1/1.png" alt></p></li><li><p>添加站点，填入自己的域名(二级域名任取，等会去解析)，无需数据库，PHP版本选择现有的就行：</p><p><img src="https://cloud.fullcomb.top/private/source/image/share/1/2.png" alt></p></li><li><p>进入创建网站的根目录，将下面的压缩包放进去并解压到该根目录。</p><div class="tag link"><a class="link-card" title="Github Release" href="https://github.com/qkqpttgf/OneManager-php/releases"><div class="left"><img src="https://cloud.fullcomb.top/private/source/image/share/1/3.png"></div><div class="right"><p class="text">Github Release</p><p class="url">https://github.com/qkqpttgf/OneManager-php/releases</p></div></a></div><p>如果github下载不是很给力就直接<a href="https://cloud.fullcomb.top/public/%E5%B7%A5%E5%85%B7/OneManager/OneManager-php-v3.5.tar.gz">点击这里下载</a>。</p><p>解压后大概就是这样：(注意目录)</p><p><img src="https://cloud.fullcomb.top/private/source/image/share/1/4.png" alt></p></li><li><p>权限改写为<mark class="hl-label orange">777</mark> ：</p><p><img src="https://cloud.fullcomb.top/private/source/image/share/1/5.png" alt></p></li><li><p>添加伪静态。在网站-&gt;伪静态 处写入：（这是Nginx的伪静态规则，Apache的不一样）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^/(?!.well-known)(.*)$</span> /index.php?/<span class="hljs-variable">$1</span> <span class="hljs-literal">last</span>;<br></code></pre></td></tr></table></figure><p><img src="https://cloud.fullcomb.top/private/source/image/share/1/7.png" alt></p></li><li><p>域名解析。将二级域名解析到你的服务器ip：</p><p><img src="https://cloud.fullcomb.top/private/source/image/share/1/6.png" alt></p></li><li><p>打开你设置的域名，初始化OneManager即可（这个照说明着做就行了）。</p></li><li><p>OneManager挂载阿里云盘。OneManager挂载阿里云盘需要使用refresh_token进行登录。下面演示如何获取refresh_token：</p><div class="tag link"><a class="link-card" title="refresh_token" href="https://media.cooluc.com/decode_token/"><div class="left"><img src="/post/46399fd8/link.png"></div><div class="right"><p class="text">refresh_token</p><p class="url">https://media.cooluc.com/decode_token/</p></div></a></div><p>进入上面的网站，点击进入移动端网页登录入口，全程调出开发者工具，登录：</p><p><img src="https://cloud.fullcomb.top/private/source/image/share/1/8.png" alt></p><p><img src="https://cloud.fullcomb.top/private/source/image/share/1/9.png" alt></p><p>回到刚才的网站，解码，即可获得refresh_token。</p><div class="tip warning"><p>阿里云盘每次改密码后refresh_token都会改变，所以不建议经常改密码。</p></div></li><li><p>给域名添加SSL证书建立安全连接。</p></li></ol><div class="tip "><p>这也正好解决了阿里云盘部分文件格式不能分享的问题。图片的直链就可作为博客图床，因为阿里云盘是不限速的，所以图片加载还挺快的（应该……）。缺点是有的时候图片不是很稳定，偶尔会出现图片挂掉的情况。但若图片完好一会儿就能恢复。</p></div><h1 id="阿里云盘搭建PLEX影音库"><a href="#阿里云盘搭建PLEX影音库" class="headerlink" title="阿里云盘搭建PLEX影音库"></a>阿里云盘搭建PLEX影音库</h1><div class="note pink modern"><p>很简单，只需两步，有手就行。</p></div><h2 id="阿里云盘挂载本地"><a href="#阿里云盘挂载本地" class="headerlink" title="阿里云盘挂载本地"></a>阿里云盘挂载本地</h2><ol><li><a href="https://cloud.fullcomb.top/public/%E5%B7%A5%E5%85%B7/CloudDrive/CloudDrive_1.1.50.1_64bit_Setup.exe">下载cloud drive</a></li><li>进入cd，登录阿里云盘(建议使用refresh_token避免登录失效)</li><li>挂载为本地硬盘，盘符自定。</li></ol><p><img src="https://cloud.fullcomb.top/private/source/image/share/1/11.png" alt></p><blockquote><p>值得一提的是，挂载到本地后文件上传的速度(和网速无<del>有</del>关)稳定在800MB/s，比在阿里云盘客户端上传文件的速度(5~6MB/s)快了不知道多少倍，<mark class="hl-label blue">不适合</mark> 用来传输大文件。（原因见下）</p><p><img src="https://cloud.fullcomb.top/private/source/image/share/1/22.png" alt></p><p>后补：不要被表面给迷惑了！这里文件似乎已经上传过去了，但实际上此时文件还不在阿里云盘里面。这里几百M/s是硬盘的大文件读写速度，其原理应该是先把要传输的文件缓存在硬盘的一个临时空间里面，然后调用阿里云盘的上传接口一直上传直到传输完成，临时空间中的文件才会被删除。相当于是让你的硬盘加了个班，实际上到阿里云盘客户端去上传的话并不需要。所以，为了硬盘着想，还是多麻烦一下，点开阿里云盘客户端吧。毕竟硬盘也想放个假，能有什么坏心眼呢……</p></blockquote><h2 id="Plex获取云盘影音"><a href="#Plex获取云盘影音" class="headerlink" title="Plex获取云盘影音"></a>Plex获取云盘影音</h2><p>打开plex media server，在添加媒体库处选择阿里云盘的路径即可。</p><p><img src="https://cloud.fullcomb.top/private/source/image/share/1/12.png" alt></p><h1 id="PLEX使用注意事项"><a href="#PLEX使用注意事项" class="headerlink" title="PLEX使用注意事项"></a>PLEX使用注意事项</h1><div class="tip "><p>使用PLEX的关键在于让它能够很好的识别或刮削到正确的影音信息。</p></div><h2 id="电影库"><a href="#电影库" class="headerlink" title="电影库"></a>电影库</h2><p>PLEX电影信息的数据库为<mark class="hl-label default">TMDB</mark> 。这个数据库由所有用户共同维护，所以电影信息比较全面，即使是刚上映的电影也有比较全的信息（评论、评分当然还暂时没有）。<emp>一般我们只需要将将电影名作为文件名即可被正确识别</emp>。</p><p>电脑端效果：</p><div class="fj-gallery"><p><img src="https://cloud.fullcomb.top/private/source/image/share/1/13.png" alt></p><p><img src="https://cloud.fullcomb.top/private/source/image/share/1/14.png" alt></p>          </div><p>iPad端效果：</p><div class="fj-gallery"><p><img src="https://cloud.fullcomb.top/private/source/image/share/1/15.PNG" alt></p><p><img src="https://cloud.fullcomb.top/private/source/image/share/1/16.PNG" alt></p>          </div><div class="tip success"><p>看得出来PLEX对电影的支持还是很好的。</p></div><hr><h2 id="音乐库"><a href="#音乐库" class="headerlink" title="音乐库"></a>音乐库</h2><div class="note orange flat"><p>但是PLEX对音乐的支持就不是那么好了，特别是华语。这时我们需要自己给音乐打标签。</p></div><p>一般我们下载下来的歌曲都是打好标签的，所以这样就没有多麻烦了。我们只需要爬取歌词即可。推荐下面两个软件2，结合使用。</p><ol><li><mark class="hl-label pink">MP3tag</mark> 。可以批量地给音乐打上专辑标签。<a href="https://cloud.fullcomb.top/public/%E5%B7%A5%E5%85%B7/Mp3tag/mp3tagv312setup.exe">点击下载</a></li><li><mark class="hl-label blue">音乐标签</mark> 。可以从网易云批量地爬取歌词，且带翻译。<a href="https://cloud.fullcomb.top/public/%E5%B7%A5%E5%85%B7/MusicTag/MusicTag%20v1.0.8.0.7z">点击下载</a></li></ol><p>PLEX上推荐添加一个插件<mark class="hl-label red">wangyiyun</mark> ，就可在添加音乐时根据音乐标签刮削到相关的信息。</p><p><img src="https://cloud.fullcomb.top/private/source/image/share/1/21.png" alt></p><p>并且，PLEX有众多专门的音乐播放器app（官方和民间的都有），极大提高了PLEX音乐库的体验。下面展示iPhone端二者的效果：(音乐主要在手机上听，且一般都在外网使用，下图手机开流量已在外网下)</p><div class="fj-gallery"><p><img src="https://cloud.fullcomb.top/private/source/image/share/1/17.PNG" alt></p><p><img src="https://cloud.fullcomb.top/private/source/image/share/1/18.PNG" alt></p><p><img src="https://cloud.fullcomb.top/private/source/image/share/1/19.PNG" alt></p><p><img src="https://cloud.fullcomb.top/private/source/image/share/1/20.PNG" alt></p>          </div><p>左为<emp>PLEX自带播放器</emp><img no-lazy class="inline" src="https://cloud.fullcomb.top/private/source/image/share/1/plex.png" style="height:1.5em">，右为<emp>Prism播放器</emp><img no-lazy class="inline" src="https://cloud.fullcomb.top/private/source/image/share/1/prism.png" style="height:1.5em">。实际体验Prism更为丝滑。</p><div class="tip "><p>上面的介绍略显简陋，之后我还打算写一篇文章来系统总结一下自己PLEX的使用，有生之年吧……</p></div><h1 id="Zerotier内网穿透"><a href="#Zerotier内网穿透" class="headerlink" title="Zerotier内网穿透"></a>Zerotier内网穿透</h1><ol><li><p>在需要使用的设备上都下载Zerotier。</p><blockquote><span class="p center small">苹果设备需要国外的账号下载Zerotier，参考教程</span><div class="tag link"><a class="link-card" title="注册美区账号" href="https://appledi.com/appleid/"><div class="left"><img src="/post/46399fd8/link.png"></div><div class="right"><p class="text">注册美区账号</p><p class="url">https://appledi.com/appleid/</p></div></a></div><p>滑稽的是，注册国外账号必须要ios设备，而在ios设备上注册国外账号需要梯子，但国区app store没有梯子……这就好比是先有鸡还是先有蛋的问题。</p></blockquote></li><li><p>前往<a href="https://my.zerotier.com/">Zerotier官网</a>注册一个账号并添加一个组网。</p></li><li><p>所有设备均连接到该组网下，即可实现设备间的通讯。</p></li><li><p>利用好自己的云服务器，将其作为moon节点进行加速。</p></li></ol><div class="note info flat"><p>搭建moon服务器节点的推荐教程：</p></div><style>.bbplayer{width: 100%; max-width: 850px; margin: auto}</style><div class="bbplayer"><iframe class="bbplayer" id="mmedia-IfTYzhWioQmrWiQs" src="https://player.bilibili.com/player.html?bvid=BV1RA411x7CL&page=1&high_quality=1&danmaku=true" allowfullscreen="allowfullscreen" scrolling="no" border="0" frameborder="0" framespacing="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts allow-popups"></iframe></div><script> document.getElementById("mmedia-IfTYzhWioQmrWiQs").style.height=document.getElementById("mmedia-IfTYzhWioQmrWiQs").scrollWidth*0.76+"px";    window.onresize = function(){      document.getElementById("mmedia-IfTYzhWioQmrWiQs").style.height=document.getElementById("mmedia-IfTYzhWioQmrWiQs").scrollWidth*0.76+"px";    }; </script><div class="note success modern"><p>至此，我们在外网下也可以访问到本机的Plex服务器——这样就可以随时随地使用自己的音乐库了(内网穿透的主要需求)。 另外，Zerotier用来和朋友点对点Minecraft联机还挺不错的，延迟很低，配合服务器管理模组食用，体验绝佳。</p></div><hr>]]></content>
      
      
      <categories>
          
          <category> 常识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阿里云盘 </tag>
            
            <tag> Plex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【闲谈】新春快乐！</title>
      <link href="/post/af65d530.html"/>
      <url>/post/af65d530.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js metin="meting" server="netease" type="song" id="525201280"></meting-js><span class="p center logo large">「爆竹声中一岁除，春风送暖入屠苏」</span><span class="p center small">首先在这里祝可能路过的人们新年愉快！</span><hr><p>说到过年，今天总算有过年的感觉了：<del>在耳边叨叨的人更多了</del>。嘛，这也是一年一度才有的情形，一家人在一起热热闹闹的也很温馨。</p><p>既然是新年，必做清单上当然有<mark class="hl-label red">思考「一年的计划」</mark> ！</p><hr><p>回想去年，我从大一下开始学习C语言，从开始的一知半解，不断叩问自己学习编程的意义，到现在有了大致的方向，了解了很多方面的知识——确实是经历了很多，也收获了很多。</p><p>一年不知不觉就过去了，转眼间就是大二下了，不由得感叹时光飞逝。哀吾生之渺小的同时，便觉得更应发奋图强。<mark class="hl-label pink">所以，flag来啦：</mark> </p><details class="folding-tag" red><summary> flag </summary>              <div class="content">              <ol><li>认真学习下学期的计网、计组、数据库三大件。</li><li>学习python。</li><li>学习ACM，四月份的蓝桥杯争取拿省一。</li><li>学习Unix/Linux。</li><li>继续学习OpenGL三维图形编程。</li><li><p>学习汇编语言，主要掌握x86汇编指令。</p></li><li><p>期中的时候补选数学竞赛，希望这次能吸取昨年的经验。额，至少在校赛出头吧……</p></li></ol><div class="note warning modern"><p>上面都是大二下的课程，所以不存在放置play的问题。但是我还是希望能在原有课程的基础上学得更深入一些。</p></div><ol><li><p>希望大三的时候尽可能靠自己加入学院某工作室进行科研。</p></li><li><p>希望大三的时候自己有能力加入学校与腾讯联动的菁英班，学习以下内容，如果可以去腾讯实习就更好了……</p><p><img src="https://cloud.fullcomb.top/private/source/image/mc/newyear/1.png" alt></p></li></ol><p>目前想到的就是这些了。</p>              </div>            </details><hr><p>春风依旧，只可惜，爆竹不在。</p><p>那么，今晚，Minecraft，放烟花，不见不散！</p><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src="https://cloud.fullcomb.top/private/source/image/mc/newyear/5.png" alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">开始</div>  <p>拉到了一个朋友来陪无聊的我放烟花</p>  <a href="/"></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src="https://cloud.fullcomb.top/private/source/image/mc/newyear/2.png" alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">放烟花</div>  <p>紫色和蓝色的烟花</p>  <a href="/"></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src="https://cloud.fullcomb.top/private/source/image/mc/newyear/3.png" alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">放烟花</div>  <p>橙色和绿色的烟花</p>  <a href="/"></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src="https://cloud.fullcomb.top/private/source/image/mc/newyear/6.png" alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">唱</div>  <p>自拍自拍</p>  <a href="/"></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src="https://cloud.fullcomb.top/private/source/image/mc/newyear/7.png" alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">跳</div>  <p>自拍自拍</p>  <a href="/"></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src="https://cloud.fullcomb.top/private/source/image/mc/newyear/8.png" alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">结束</div>  <p>不知东方之既白</p>  <a href="/"></a>  </figcaption>  </figure>  </div><hr><p>刚才看完了小潮Team的MC拜年祭，实实实在令我心潮澎湃yyyya！！！每一个节目都既精彩又有意义，让我不禁感叹这样的节目不能上春晚实在是太可惜了。</p><style>.bbplayer{width: 100%; max-width: 850px; margin: auto}</style><div class="bbplayer"><iframe class="bbplayer" id="mmedia-UoMSrUTbbMbNzdhs" src="https://player.bilibili.com/player.html?bvid=BV1kq4y1F7Uh&page=1&high_quality=1&danmaku=true" allowfullscreen="allowfullscreen" scrolling="no" border="0" frameborder="0" framespacing="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts allow-popups"></iframe></div><script> document.getElementById("mmedia-UoMSrUTbbMbNzdhs").style.height=document.getElementById("mmedia-UoMSrUTbbMbNzdhs").scrollWidth*0.76+"px";    window.onresize = function(){      document.getElementById("mmedia-UoMSrUTbbMbNzdhs").style.height=document.getElementById("mmedia-UoMSrUTbbMbNzdhs").scrollWidth*0.76+"px";    }; </script><hr><mark class="hl-label pink">当一个游戏深入人心时，它就不仅仅是一个游戏了。</mark> <div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src="https://cloud.fullcomb.top/private/source/image/mc/newyear/9.png" alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">奇迹再现</div>  <p>制作/后期：大不6仙，策划：小潮院长</p>  <a href="/"></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src="https://cloud.fullcomb.top/private/source/image/mc/newyear/10.png" alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">奇迹再现</div>  <p>制作/后期：大不6仙，策划：小潮院长</p>  <a href="/"></a>  </figcaption>  </figure>  </div><p>第一个节目（大概……）是用MC角色音效演奏的迪加奥特曼OP《奇迹再现》。迪加奥特曼是我童年最喜欢的“动画”之一，<psw>当然有些地方今天才看懂（笑）</psw>。《奇迹再现》这首歌一直以来也被我的很多“中二病”同学拿来当战歌（笑）。还真想念被各位鬼畜们魔音穿脑的日子啊！</p><p>然后感谢各区的UP主们在MC拜年祭里的新年祝福。这让我感到不仅MC是一个大家庭，整个B站，不同分区，兴趣爱好各不相同的人们，也是一个大家庭。</p><hr><mark class="hl-label orange">我们无法抵抗命运，但灯塔将永远被铭记。</mark> <div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src="https://cloud.fullcomb.top/private/source/image/mc/newyear/11.png" alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">稻香-连锁反应</div>  <p>剪辑：小潮院长，动画：仙儿、朝曦，导演/策划：羊头人</p>  <a href="/"></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src="https://cloud.fullcomb.top/private/source/image/mc/newyear/12.png" alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">稻香-连锁反应</div>  <p>剪辑：小潮院长，动画：仙儿、朝曦，导演/策划：羊头人</p>  <a href="/"></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src="https://cloud.fullcomb.top/private/source/image/mc/newyear/13.png" alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">稻香-连锁反应</div>  <p>剪辑：小潮院长，动画：仙儿、朝曦，导演/策划：羊头人</p>  <a href="/"></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src="https://cloud.fullcomb.top/private/source/image/mc/newyear/14.png" alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">稻香-连锁反应</div>  <p>剪辑：小潮院长，动画：仙儿、朝曦，导演/策划：羊头人</p>  <a href="/"></a>  </figcaption>  </figure>  </div><p>万丈高楼平地起，但孰不知，民以食为天，解决人民的温饱才是国之根基。有这样一位巨人，他以奉献祖国和人民为目标，一辈子躬耕田野，脚踏实地把科技论文写在祖国大地上。但就在昨年，这位巨人陨落了。</p><p>当我看到两个小车一个在前，一个在后，而前面的车却把收获的粮食全部给予给后面的小车，到最后出来的只有那个满载而归的小车时，我的眼角突然湿润了。袁老正是如此，将自己的一生献给了国家和人民，造福了千万家。但是，他崇高的精神火焰也将如同他的伟大贡献一样，一直延续下去，世世代代，薪火相传！</p><hr><mark class="hl-label green">以诚挚之心，领岁月教诲，敬少年热诚！</mark> <div class="fj-gallery"><p><img src="https://cloud.fullcomb.top/private/source/image/mc/newyear/15.png" alt></p><p><img src="https://cloud.fullcomb.top/private/source/image/mc/newyear/16.png" alt></p><p><img src="https://cloud.fullcomb.top/private/source/image/mc/newyear/17.png" alt></p><p><img src="https://cloud.fullcomb.top/private/source/image/mc/newyear/18.png" alt></p>          </div><p>地图组的各位大佬让我再次见识到了我的(<del>别人的</del>)世界的广阔（<psw>少拿现实来骗我了</psw>）。还有这转场太舒服了，真的是德芙，不对，是丝滑本体。感谢那些无名的地图组成员们，每一帧背后简直都是无数的心血！</p><p>此时，我不禁感叹到：MC就如一块画布，任君挥洒，恰如人生。</p><hr><mark class="hl-label red">我们的目标是星辰大海！</mark> <div class="fj-gallery"><p><img src="https://cloud.fullcomb.top/private/source/image/mc/newyear/26.png" alt></p><p><img src="https://cloud.fullcomb.top/private/source/image/mc/newyear/27.png" alt></p><p><img src="https://cloud.fullcomb.top/private/source/image/mc/newyear/19.png" alt></p><p><img src="https://cloud.fullcomb.top/private/source/image/mc/newyear/20.png" alt></p><p><img src="https://cloud.fullcomb.top/private/source/image/mc/newyear/21.png" alt></p><p><img src="https://cloud.fullcomb.top/private/source/image/mc/newyear/22.png" alt></p><p><img src="https://cloud.fullcomb.top/private/source/image/mc/newyear/23.png" alt></p><p><img src="https://cloud.fullcomb.top/private/source/image/mc/newyear/24.png" alt></p><p><img src="https://cloud.fullcomb.top/private/source/image/mc/newyear/25.png" alt></p>          </div><span class="p red">壮哉，祖国的大好山河！壮哉，中华儿女的伟大征程！</span><p>至此，我已经完全震惊于MC的创造性了，而更令我震撼的是祖国的宏伟建筑与壮丽山河。中华民族一路走来，自强不息，凭借自己的努力，改天换地。</p><p>当我看到火箭在天宫空间站成功对接时，我简直感动得热泪盈眶了。我们对太空的探索的发展虽然比美国，俄罗斯这些发达国家要晚，但是我们的每一个脚步却都是最稳的，这离不开从顶尖的科学家到底层的技术人员们的不懈努力。我们也可以自信地喊出：<strong>我们的目标是星辰大海！</strong></p><span class="p red">壮哉，中华盛世，昂首东方！</span><img no-lazy class="inline" src="https://cloud.fullcomb.top/private/source/image/mc/newyear/28.png" style="height:1.5em"><span class="p logo center large">我爱你，中国！</span><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Minecraft </tag>
            
            <tag> 闲谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【刷题】滑动窗口</title>
      <link href="/post/5d74451a.html"/>
      <url>/post/5d74451a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h1><details class="folding-tag" blue><summary> 题目 </summary>              <div class="content">              <div class="note blue flat"><p>给定一个字符串 s ，请你找出其中不含有重复字符的<span class="nota" data-nota="区别子序列：子串必须是连续的！">最长子串</span> 的长度。</p></div><ol><li>示例 1：输入: s = “abcabcbb”  输出: 3 </li><li>示例 2：输入: s = “bbbbb”  输出: 1</li><li>示例 3：输入: s = “pwwkew”  输出: 3</li><li>示例 4：输入: s = “”  输出: 0</li></ol>              </div>            </details><div class="note blue modern"><p><span class="p center small"><strong>分析该题的滑动窗口模型</strong></span></p><p>初始时两个指针都指向字符串的开头。此时子串中只有一个字符，满足子串中字符不重复这条件，<strong>但是还不是最优的</strong>。</p><p><mark class="hl-label blue">我们使用滑动窗口的思想来计算最优解：</mark> 若右指针的下一个字符与该子串中的字符不重复，则右指针右移，增大窗口边界；若重复了，则左指针右移重新检测子串，直到右指针移动到字符串末尾。用两指针之差来计算字符串长度。</p></div><p>然后这道题的关键就是<mark class="hl-label blue">如何检测右指针的下一个字符是否与子串中的字符重复</mark> 。</p><mark class="hl-label pink">第一个想法</mark> 是再遍历一次子串，判断是否重复。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(string &amp;s,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;r;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=r;j&gt;i;j--)<br>                <span class="hljs-keyword">if</span>(s[i]==s[j]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> len=<span class="hljs-number">0</span>,l=<span class="hljs-number">0</span>,r=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(r+<span class="hljs-number">1</span>&lt;s.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(s,l,r+<span class="hljs-number">1</span>)) r++;<br>            <span class="hljs-keyword">else</span> l++;<br>            <span class="hljs-keyword">if</span>(r-l+<span class="hljs-number">1</span>&gt;len) len=r-l+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" blue><summary> judge1 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/3/1.png" alt></p>              </div>            </details><p>典型以时间换空间了。不行！</p><mark class="hl-label pink">第二个想法是</mark> 构造一个无序的集合来储存已经出现的字符。利用`unordered_set`的`count()`函数来检测一个字符是否在子串中出现。出现返回1，否则为0。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        unordered_set&lt;<span class="hljs-keyword">char</span>&gt; usc;<br>        <span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>,r=<span class="hljs-number">0</span>,ans=<span class="hljs-number">0</span>;<br>        usc.<span class="hljs-built_in">insert</span>(s[r]);<br>        <span class="hljs-keyword">while</span>(r+<span class="hljs-number">1</span>&lt;s.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">if</span>(!usc.<span class="hljs-built_in">count</span>(s[r+<span class="hljs-number">1</span>]))&#123;<br>                r++;<br>                usc.<span class="hljs-built_in">insert</span>(s[r]);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                ans=<span class="hljs-built_in">max</span>(ans,r-l+<span class="hljs-number">1</span>);<br>                usc.<span class="hljs-built_in">erase</span>(s[l]);<br>                l++;<br>            &#125;<br>        &#125;<br>        ans=<span class="hljs-built_in">max</span>(ans,r-l+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" blue><summary> judge2 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/3/2.png" alt></p>              </div>            </details><p>看来性能还是一般般，还有更好的方法！这个方法的缺陷就是从无序集合中查找元素还会消耗一些时间。那么我们能不能无需查找就直到该元素的位置？这时应该想到数组的查地址查找，时间复杂度$O(n)$。</p><mark class="hl-label pink">第三个想法是</mark> 构造一个下标0~127的整型数组，用来储存数组下标所对应的字符的出现次数。若一个字符对应下标为0，则在子串中没有出现，反之出现。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string&amp; s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len=s.<span class="hljs-built_in">size</span>(),l=<span class="hljs-number">0</span>,r=<span class="hljs-number">0</span>,ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">vc</span><span class="hljs-params">(<span class="hljs-number">128</span>,<span class="hljs-number">0</span>)</span></span>;<br>        vc[s[r]]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(r+<span class="hljs-number">1</span>&lt;len)&#123;<br>            <span class="hljs-keyword">if</span>(!vc[s[r+<span class="hljs-number">1</span>]])&#123;<br>                r++;<br>                vc[s[r]]=<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                vc[s[l]]=<span class="hljs-number">0</span>;<br>                ans=<span class="hljs-built_in">max</span>(ans,r-l+<span class="hljs-number">1</span>);<br>                l++;<br>            &#125;<br>        &#125;<br>        ans=<span class="hljs-built_in">max</span>(ans,r-l+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" blue><summary> judge3 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/3/3.png" alt></p>              </div>            </details><p>有一说一，这个算法牛逼。然而我写的代码并不是很优美，所以看起来很长。但是换个角度来说可读性还是不错的，希望以后还能看懂🙏。</p><h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><details class="folding-tag" red><summary> 题目 </summary>              <div class="content">              <p>给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。<strong>换句话说，s1 的排列之一是 s2 的 子串 。</strong></p><ol><li>示例 1：输入：s1 = “ab” s2 = “eid<strong>ba</strong>ooo”  输出：true</li><li>示例 2：输入：s1 = “ab” s2 = “eidboaoo”  输出：false</li></ol><div class="note info flat"><p>提示：s1 和 s2 仅包含小写字母</p></div>              </div>            </details><div class="note pink modern"><p><span class="p center small"><strong>分析该题的滑动窗口模型</strong></span></p><p><mark class="hl-label pink">我们在s2上维护一个和s1相同大小的窗口。</mark> </p><p>要判断s1的排列之一是否是s2的子串，只需要不断地比较s1和s2窗口对应的子串即可。如果s1的一个排列和该子串相同，则返回true；否则该窗口向右移动，重新判断，直到窗口到达s2边界。</p></div><p>于是，解决这道题的关键就是<mark class="hl-label pink">如何判断s2的子串是s1的一个排列。</mark> </p><p>现在我们吸收上一题的经验，使用一个数组来记录字符串中字母出现的次数。</p><mark class="hl-label blue">想法：</mark> 先记录s1中字母出现的次数，然后不断判断地用另一个数组记录s2窗口中字符出现的次数。如果两个数组相等，那么s1 的排列之一就是 s2 的 子串，返回true；否则窗口右移。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(string&amp; s1, string&amp; s2)</span></span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">vi</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> j:s1) vi[j<span class="hljs-number">-97</span>]++;<br>        <span class="hljs-keyword">int</span> len=s1.<span class="hljs-built_in">size</span>(),i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i+len&lt;=s2.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;i+len;j++) v[s2[j]<span class="hljs-number">-97</span>]++;<br>            <span class="hljs-keyword">if</span>(v==vi) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>很可惜，这个想法的思路是没有问题的，但是时间复杂度为$O(mn)$，性能很低！</p><details class="folding-tag" red><summary> judge1 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/3/4.png" alt></p>              </div>            </details><p>我们来分析一下上面做法的问题：窗口每次向右移动时，只会向右移动一格的距离，但是我们却重新遍历了一遍窗口中的字符，耗掉了很多时间。实际上我们只需要更新端点即可：原窗口最左边的字符出现次数-1，新窗口最右边字符出现的次数+1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(string&amp; s1, string&amp; s2)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> len1=s1.<span class="hljs-built_in">size</span>(),len2=s2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(len1&gt;len2) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">vi</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span>,<span class="hljs-title">vj</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span>,i</span>=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(;i&lt;len1;i++)&#123;<br>            vi[s1[i]<span class="hljs-number">-97</span>]++;<br>            vj[s2[i]<span class="hljs-number">-97</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(vj==vi) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;;<br>        <span class="hljs-keyword">for</span>(;i&lt;len2;i++)&#123;<br>            vj[s2[i]<span class="hljs-number">-97</span>]++;<br>            vj[s2[i-len1]<span class="hljs-number">-97</span>]--;<br>            <span class="hljs-keyword">if</span>(vj==vi) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" red><summary> judge2 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/3/5.png" alt></p>              </div>            </details><p>这下性能就很不错了啊~</p><details class="folding-tag" red open><summary> 总结 </summary>              <div class="content">              <ol><li>掌握滑动窗口的基本思想：左右移动窗口或缩放窗口，寻找可行解或最优解。</li><li>滑动窗口可以看成模型。在此基础上，我们还要思考如何寻找比较好的算法来优化判断条件。这个需要我们多练习来熟悉常用的方法。</li></ol>              </div>            </details><hr>]]></content>
      
      
      <categories>
          
          <category> 大二上 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【刷题】双指针强化</title>
      <link href="/post/a0588053.html"/>
      <url>/post/a0588053.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h2><details class="folding-tag" cyan><summary> 题目 </summary>              <div class="content">              <div class="note green flat"><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p></div><ol><li>示例 1：输入: nums = [0,1,0,3,12]  输出: [1,3,12,0,0]</li><li>示例 2：输入: nums = [0]  输出: [0]</li></ol>              </div>            </details><mark class="hl-label pink">分析一：</mark> 我们可以把这道题视为排序的变形：0为大数，其他为小数。我们需要将0排在后面且保持非零数的顺序不变，所以应该选择稳定的排序算法。<br>我们使用<mark class="hl-label blue">插入排序</mark> ：从头遍历数组，遇到0即将其删去，然后插入到末尾。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> flag=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(flag&lt;nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[flag]!=<span class="hljs-number">0</span>) flag++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=flag+<span class="hljs-number">1</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)<br>            <span class="hljs-keyword">if</span>(nums[i]!=<span class="hljs-number">0</span>) <span class="hljs-built_in">swap</span>(nums[flag++],nums[i]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" cyan><summary> jugdge1 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/2/2.png" alt></p><p>不对劲！！！这个算法肯定不行！寻找其他思路。</p>              </div>            </details><mark class="hl-label pink">分析二：</mark> 我们刚才其实忽略了一点：对于非零数的排序必须是稳定的，而对于0的排序则可以不稳定。所以我们可以借鉴快速排序的思想（但有修改）：<br>使用两个指针，第一个指针始终指向第一个0，第二个指针遍历数组。<emp>若第二个指针指向的数不是0，则交换两指针指向的值，然后第一个指针前移</emp>；否则第一个指针不移动。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> flag=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(flag&lt;nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[flag]!=<span class="hljs-number">0</span>) flag++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=flag+<span class="hljs-number">1</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)<br>            <span class="hljs-keyword">if</span>(nums[i]!=<span class="hljs-number">0</span>) <span class="hljs-built_in">swap</span>(nums[flag++],nums[i]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" cyan><summary> judge2 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/2/1.png" alt></p>              </div>            </details><details class="folding-tag" open cyan><summary> 总结 </summary>              <div class="content">              <p>回顾排序算法：//todo</p>              </div>            </details><h2 id="两数之和Ⅱ-输入有序数组"><a href="#两数之和Ⅱ-输入有序数组" class="headerlink" title="两数之和Ⅱ - 输入有序数组"></a>两数之和Ⅱ - 输入有序数组</h2><details class="folding-tag" orange><summary> 题目 </summary>              <div class="content">              <div class="note orange flat"><p>给定一个已按照<mark class="hl-label orange">非递减顺序排列</mark> 的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。</p><p>函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。</p><p>你可以假设每个输入<mark class="hl-label orange">有且仅有唯一的答案</mark> ，而且你不可以重复使用相同的元素。</p></div><ol><li>示例 1：输入：numbers = [2,7,11,15], target = 9  输出：[1,2]</li><li>示例 2：输入：numbers = [2,3,4], target = 6  输出：[1,3]</li><li>示例 3：输入：numbers = [-1,0], target = -1  输出：[1,2]</li></ol>              </div>            </details><mark class="hl-label orange">思路：</mark> 根据之前的经验，我们需要寻找一个中间值，将待查找数的分为两份。1. 第一个想法是找到<mark class="hl-label blue">target/2</mark> 的位置，它将数组分为两份：左边的小，右边的大，然后左右两边分别一个for循环。然而其时间复杂度依旧为$O(n)$​​，在某组奇葩的测试样例上运行超时。​2. 第二个想法(<psw>看了答案之后</psw>)是<mark class="hl-label green">使用双指针向中间靠拢</mark> 。如果两个指针指向的值之和小于target，则左指针右移；如果两个指针指向的值之和大于target，则右指针左移。<emp>该做法把数组两端值之和作为中间值</emp>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]+nums[j]==target) <span class="hljs-keyword">return</span> &#123;i+<span class="hljs-number">1</span>,j+<span class="hljs-number">1</span>&#125;;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i]+nums[j]&lt;target) i++;<br>            <span class="hljs-keyword">else</span> j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" orange><summary> judge </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/2/3.png" alt></p>              </div>            </details><details class="folding-tag" open orange><summary> 总结 </summary>              <div class="content">              <p>有序数组<mark class="hl-label pink">使用双指针指向其首尾</mark> 也是很常见的模型。</p><p>特点之一是<emp>左指针右移和增大；右指针左移和减小</emp>。</p>              </div>            </details><h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><details class="folding-tag" red><summary> 题目 </summary>              <div class="content">              <div class="note pink flat"><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p></div><ol><li>示例 1：输入：s = [“h”,”e”,”l”,”l”,”o”]  输出：[“o”,”l”,”l”,”e”,”h”]</li><li>示例 2：输入：s = [“H”,”a”,”n”,”n”,”a”,”h”]  输出：[“h”,”a”,”n”,”n”,”a”,”H”]</li></ol>              </div>            </details><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">char</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&lt;j;i++,j--)<br>            <span class="hljs-built_in">swap</span>(s[i],s[j]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当然也可以直接用<mark class="hl-label pink">STL中的reverse()函数</mark> ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">char</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" red><summary> judeg </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/2/4.png" alt></p>              </div>            </details><details class="folding-tag" red open><summary> 总结 </summary>              <div class="content">              <p>和上面的题一样，双指针向中间靠拢直至二者相遇。</p>              </div>            </details><h2 id="反转字符串中的单词Ⅲ"><a href="#反转字符串中的单词Ⅲ" class="headerlink" title="反转字符串中的单词Ⅲ"></a>反转字符串中的单词Ⅲ</h2><details class="folding-tag" green><summary> 题目 </summary>              <div class="content">              <div class="note green flat"><p>给定一个字符串 s ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p></div><ol><li>示例 1：输入：s = “Let’s take LeetCode contest”  输出：”s’teL ekat edoCteeL tsetnoc”</li><li>示例 2：输入： s = “God Ding”  输出：”doG gniD”</li></ol>              </div>            </details><p>思路：一个一个单词地交换就行了。把直接传参改为引用传参空间开销会小一些。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string&amp; s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; length) &#123;<br>            <span class="hljs-keyword">int</span> start = i;<br>            <span class="hljs-keyword">while</span> (i &lt; length &amp;&amp; s[i] != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">int</span> left = start, right = i - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                <span class="hljs-built_in">swap</span>(s[left], s[right]);<br>                left++;<br>                right--;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (i &lt; length &amp;&amp; s[i] == <span class="hljs-string">&#x27; &#x27;</span>) i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" green><summary> judge </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/2/5.png" alt></p>              </div>            </details><h2 id="链表的中间结点"><a href="#链表的中间结点" class="headerlink" title="链表的中间结点"></a>链表的中间结点</h2><details class="folding-tag" red><summary> 题目 </summary>              <div class="content">              <div class="note pink flat"><p>给定一个头结点为 head 的非空单链表，返回链表的<span class="nota" data-nota="顾名思义，最中间的结点">中间结点</span>。</p><p>如果有两个中间结点，则返回第二个中间结点。</p></div><ol><li>示例 1：输入：[1,2,3,4,5] 输出：此列表中的结点 3 (序列化形式：[3,4,5])</li><li>示例 2：输入：[1,2,3,4,5,6] 输出：此列表中的结点 4 (序列化形式：[4,5,6])</li></ol>              </div>            </details><mark class="hl-label pink">方法一：</mark> 先遍历一遍链表，得到结点个数；第二次指针移动到链表中间即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(ListNode* p=head;p!=<span class="hljs-literal">nullptr</span>;p=p-&gt;next) n++;<br>        n=n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>        ListNode* p=head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) p=p-&gt;next;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" red><summary> judge </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/2/6.png" alt></p>              </div>            </details><mark class="hl-label default">方法二：快慢指针</mark> 。慢指针每移动一步，快指针就移动两步。这样快指针到尾的时候慢指针正好再链表中间。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* slow=head,*fast=head;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">nullptr</span> &amp;&amp; fast-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;<br>            slow=slow-&gt;next;<br>            fast=fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" red><summary> judge </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/2/7.png" alt></p>              </div>            </details><details class="folding-tag" red open><summary> 总结 </summary>              <div class="content">              <p>掌握这道题<mark class="hl-label pink">快慢指针</mark> 的方法。</p>              </div>            </details><h2 id="删除链表的倒数第N个结点"><a href="#删除链表的倒数第N个结点" class="headerlink" title="删除链表的倒数第N个结点"></a>删除链表的倒数第N个结点</h2><details class="folding-tag" blue><summary> 题目 </summary>              <div class="content">              <div class="note blue flat"><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p></div><ol><li>示例二：输入：head = [1,2,3,4,5], n = 2  输出：[1,2,3,5]</li><li>示例 2：输入：head = [1], n = 1  输出：[]</li><li>示例 3：输入：head = [1,2], n = 1  输出：[1]</li></ol>              </div>            </details><mark class="hl-label blue">思路一：</mark> 先遍历一遍链表，得到链表结点个数。第二次遍历的时候再删除倒数第N个结点。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(ListNode* p=head;p!=<span class="hljs-literal">nullptr</span>;p=p-&gt;next) i++;<br>        ListNode* p=head;<br>        <span class="hljs-keyword">if</span>(n==i) <span class="hljs-keyword">return</span> p-&gt;next;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;i-n;j++) p=p-&gt;next;<br>        <span class="hljs-keyword">if</span>(p-&gt;next!=<span class="hljs-literal">nullptr</span>) p-&gt;next=p-&gt;next-&gt;next;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" blue><summary> judge </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/2/8.png" alt></p>              </div>            </details><mark class="hl-label blue">思路二：</mark> 使用快慢指针。一个指针再前，另一个指针在其后N个结点的位置处。两个指针一起移动，直至前指针到达表尾。<psw>没想到……被前面快慢指针的思维固化了</psw><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        ListNode* first = head;<br>        ListNode* second = dummy;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            first = first-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (first) &#123;<br>            first = first-&gt;next;<br>            second = second-&gt;next;<br>        &#125;<br>        second-&gt;next = second-&gt;next-&gt;next;<br>        ListNode* ans = dummy-&gt;next;<br>        <span class="hljs-keyword">delete</span> dummy;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" open blue><summary> 总结 </summary>              <div class="content">              <div class="note blue modern"><p><span class="p center small"><strong>快慢指针</strong></span></p><p>两个指针一起移动：</p><ol><li>快指针比慢指针每次移动的步数更长；</li><li>快指针在前，慢指针在后。</li></ol></div>              </div>            </details><hr>]]></content>
      
      
      <categories>
          
          <category> 大二上 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【刷题】二分查找与双指针</title>
      <link href="/post/48834655.html"/>
      <url>/post/48834655.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><details class="folding-tag" open cyan><summary> 二分查找/折半查找的基本方法 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/1/2.png" alt></p>              </div>            </details><h2 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h2><details class="folding-tag" cyan><summary> 题目 </summary>              <div class="content">              <div class="note blue flat"><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p></div><ol><li><p>示例 1:</p><p>输入: nums = [-1,0,3,5,9,12], target = 9  输出: 4</p></li><li><p>示例 2:</p><p>输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1</p></li></ol><div class="note green flat"><ol><li>你可以假设 nums 中的所有元素是不重复的。</li><li>n 将在 [1, 10000]之间。</li><li>nums 的每个元素都将在 [-9999, 9999]之间。</li></ol></div>              </div>            </details><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>]==target) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(nums[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]==target) <span class="hljs-keyword">return</span> (nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">int</span> pre=<span class="hljs-number">0</span>,pos=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,mid=(pre+pos)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span>(nums[mid]!=target)&#123;<br>            <span class="hljs-keyword">if</span>(nums[mid]&lt;target) pre=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> pos=mid<span class="hljs-number">-1</span>;<br>            mid=(pre+pos)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(pre&gt;pos) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" cyan><summary> judge </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/1/1.png" alt></p>              </div>            </details><details class="folding-tag" open cyan><summary> 总结 </summary>              <div class="content">              <ol><li>vector属于C++ STL的container，相当于栈这种数据结构，实用性很强，需要掌握！这里涉及到的有vector的<mark class="hl-label pink">随机访问</mark> (下标从0开始)和<mark class="hl-label blue">vector.size()</mark> 的方法。</li><li>二分查找使用到了<mark class="hl-label green">三个指针变量</mark> 。三个指针起名为<code>low</code>、<code>mid</code>、<code>high</code>更为规范。</li></ol>              </div>            </details><h2 id="第一个错误的版本"><a href="#第一个错误的版本" class="headerlink" title="第一个错误的版本"></a>第一个错误的版本</h2><details class="folding-tag" green><summary> 题目 </summary>              <div class="content">              <div class="note green flat"><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，<emp>所以错误的版本之后的所有版本都是错的</emp>。</p><p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。你可以通过调用 <mark class="hl-label isBadVersion(version)">bool</mark>  接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。<emp>你应该尽量减少对调用 API 的次数</emp>。</p></div><ol><li><p>示例 1：输入：n = 5, bad = 4 输出：4</p></li><li><p>示例 2：输入：n = 1, bad = 1 输出：1</p></li></ol><div class="note pink flat"><p>提示：1 &lt;= bad &lt;= n &lt;= 231 - 1</p></div>              </div>            </details><mark class="hl-label pink">最初的想法：</mark> 在二分查找的基础上，修改查命中的条件为<mark class="hl-label blue">!(isBadVersion(mid)&&isBadVersion(mid-1))</mark> (即终止条件为<emp>mid指向错误的版本且靠近mid左边的第一个版本是正确的版本</emp>)。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstBadVersion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> low=<span class="hljs-number">1</span>,high=n,mid=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isBadVersion</span>(mid)||<span class="hljs-built_in">isBadVersion</span>(mid<span class="hljs-number">-1</span>))&#123;<br>            mid=low+(high-low)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isBadVersion</span>(mid)) high=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span> low=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" green><summary> judge1 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/1/3.png" alt></p><p>看起来结果还算不赖，但是每次循环都会调用3次API，显然，与题目要求尽可能减少API的调用不符!</p>              </div>            </details><mark class="hl-label pink">改进的做法：</mark> <mark class="hl-label blue">不断地缩小边界至三个指针重合，这时候要查找的一定就是三个指针重合时指向的值</mark> 。这样每次循环只调用一次API。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstBadVersion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> low = <span class="hljs-number">1</span>, high = n, mid = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (low&lt;high)&#123;<br>            mid = low + ((high - low)/<span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isBadVersion</span>(mid)) high = mid;<br>            <span class="hljs-keyword">else</span> low = mid + <span class="hljs-number">1</span>;<br>        &#125;         <br>        <span class="hljs-keyword">return</span> low;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" green><summary> judge2 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/1/4.png" alt></p><p>这个做法确实比之前高明一些，但是也有例外。因为这个算法时间复杂度是妥妥的$O(logn)$，但之前的做法是最坏时间复杂度为$O(logn)$</p>              </div>            </details><details class="folding-tag" open green><summary> 总结 </summary>              <div class="content">              <ol><li>学习对<mark class="hl-label pink">(low+high)/2</mark> 可能溢出的处理：使用<mark class="hl-label blue">low+(high-low)/2</mark> 。</li><li>注意方法二<emp>缩小右边界时</emp>应该是<mark class="hl-label green">high=mid</mark> 而不是<mark class="hl-label pink">high=mid-1</mark> ！因为如果此时mid刚好指向第一个错误的版本，那么high=mid-1之后，mid就永远不可能再指向这个值了，最终返回的就是一个错误的值！<psw>(这甚至让我一度怀疑算法的正确性……)</psw></li></ol>              </div>            </details><h2 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h2><blockquote><p>本题相当于是第一题二分算法的补充，额外研究了当查找失败时target应该插入的位置。</p></blockquote><details class="folding-tag" red><summary> 题目 </summary>              <div class="content">              <div class="note pink flat"><p>给定一个<emp>排序数组</emp>和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请务必使用时间复杂度为 O(log n) 的算法。</p></div><ol><li>示例 1：输入: nums = [1,3,5,6], target = 5 输出: 2</li><li>示例 2：输入: nums = [1,3,5,6], target = 2 输出: 1</li><li>示例 3：输入: nums = [1,3,5,6], target = 7 输出: 4</li><li>示例 4：输入: nums = [1,3,5,6], target = 0 输出: 0</li><li>示例 5：输入: nums = [1], target = 0 输出: 0</li></ol><div class="note green flat"><ol><li><p>1 &lt;= nums.length &lt;= $10^4$​</p></li><li><p>$-10^4$&lt;= nums[i] &lt;= $10^4$</p></li><li>nums 为无重复元素的升序排列数组 </li><li>$-10^4$​ &lt;= target &lt;= $10^4$​​</li></ol><p>……总之就是不用考虑溢出。</p></div>              </div>            </details><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> low=<span class="hljs-number">0</span>,high=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,mid=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(nums[mid]!=target)&#123;<br>            mid=(low+high)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&lt;target) low=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> high=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">if</span>(low&gt;high) <span class="hljs-keyword">return</span> low;<br>        &#125;<br>        <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" red><summary> jugde </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/1/5.png" alt></p>              </div>            </details><details class="folding-tag" red><summary> 总结 </summary>              <div class="content">              <p><mark class="hl-label pink">·思考为什么查失败时应该返回low而不是high或mid。</mark> </p><p><psw>伪</psw>证明：由low和high指针的对称性，可知查失败的情况下当low=mid=high时，<emp>nums[mid]可能小于target，也可能大于targe</emp>。</p><ol><li><p>若nums[mid]&lt;target，那么low=mid+1；而target应该插入到nums[mid]之后的一位，即low。</p></li><li><p>若nums[mid]&gt;target，那么high=mid-1；而target应该插入到nums[mid]所在的位置，即low。</p></li></ol><p>所以，导致插入位置不对称的原因是插入的值要和前后的值满足一定的大小关系……这么说可能会有点抽象……总而言之就和上面是一个意思。</p>              </div>            </details><hr><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><blockquote><p>怎么说呢，这种题就像脑筋急转弯，想到了正确的做法就能做对，没有固定的解法。但是，掌握更多的技巧，有助于拓宽解题思路，在更短的时间内想出更为高效的算法。</p></blockquote><h2 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h2><details class="folding-tag" orange><summary> 题目 </summary>              <div class="content">              <div class="note orange flat"><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p></div><ol><li>示例 1：输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100]</li><li>示例 2：输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]</li></ol>              </div>            </details><mark class="hl-label pink">思路一：</mark> 从正负分界处切断，两段的平方都是有序的。再利用<mark class="hl-label orange">归并排序</mark> 的思想对两段进行合并。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; vi;<br>        <span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>,len=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(j&lt;len &amp;&amp; nums[j]&lt;<span class="hljs-number">0</span>) j++;<br>        <span class="hljs-keyword">int</span> i=j<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span> || j&lt;len)&#123;<br>            <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>)&#123;<br>                vi.<span class="hljs-built_in">push_back</span>(nums[j]*nums[j]);<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j&gt;=len)&#123;<br>                vi.<span class="hljs-built_in">push_back</span>(nums[i]*nums[i]);<br>                i--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((nums[i]+nums[j])&lt;<span class="hljs-number">0</span>)&#123;<br>                vi.<span class="hljs-built_in">push_back</span>(nums[j]*nums[j]);<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                vi.<span class="hljs-built_in">push_back</span>(nums[i]*nums[i]);<br>                i--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> vi;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" orange><summary> judge1 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/1/6.jpg" alt></p>              </div>            </details><mark class="hl-label blue">思路二：</mark> 从两端开始，往中间收拢，性能极高。<psw>这个方法我一开始没有想到，看到题解之后就去试了试这个思路，然后看了看跑分，直呼卧槽！</psw><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,flag=j;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">vi</span><span class="hljs-params">(j+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">while</span>(flag&gt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(nums[i])&gt;<span class="hljs-built_in">abs</span>(nums[j]))&#123;<br>                vi[flag]=(nums[i]*nums[i]);<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                vi[flag]=(nums[j]*nums[j]);<br>                j--;<br>            &#125;<br>            flag--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> vi;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><details class="folding-tag" orange><summary> judge2 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/1/6.png" alt></p>              </div>            </details><details class="folding-tag" open orange><summary> 总结 </summary>              <div class="content">              <ol><li>对比第一种和第二种方法，两者时间的差别主要在于是否去寻找了分段点。显然，这一步操作的时间复杂度也是$O(n)$。</li><li>双指针的思想主要就是两个指针像两边移动或向中间靠拢，然后达到边界条件。</li></ol>              </div>            </details><h2 id="轮转数组"><a href="#轮转数组" class="headerlink" title="轮转数组"></a>轮转数组</h2><details class="folding-tag" blue><summary> 题目 </summary>              <div class="content">              <div class="note blue flat"><p>给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p></div><ol><li>示例 1：输入: nums = [1,2,3,4,5,6,7], k = 3  输出: [5,6,7,1,2,3,4]</li><li>示例 2：输入：nums = [-1,-100,3,99], k = 2  输出：[3,99,-1,-100]</li></ol>              </div>            </details><mark class="hl-label blue">方法：</mark> 双指针，使用递归。<psw>为了这递归我想了好久，然而发现性能并不怎么样……</psw>。而且还在参数列表处额外加了一个默认参数，有点<psw>不讲武德</psw>……<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> n=nums.<span class="hljs-built_in">size</span>(),i=pos;<br>        k=k%n;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span>(;i&lt;n-k;i++)<br>            <span class="hljs-built_in">swap</span>(nums[i],nums[n+(i-pos)%k-k]);<br>        <span class="hljs-keyword">if</span>(i==n+(i-pos)%k-k) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">rotate</span>(nums,k-(i-pos)%k,n-k);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><mark>解释：</mark>两个指针，左指针一直往右移动，右指针在一个区域内循环移动，每一步都交换两指针指向的值。</p><p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/1/9.png" alt></p><details class="folding-tag" blue><summary> judge </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/leetcode/1/7.png" alt></p>              </div>            </details><hr>]]></content>
      
      
      <categories>
          
          <category> 大二上 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Minecraft mod服搭建(踩坑向)</title>
      <link href="/post/338db5e.html"/>
      <url>/post/338db5e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info flat"><p>作为从古老版本的MC穿越过来的萌新，搭建自己的Minecraft服务器的确是一件很令人兴奋的事。本篇将重点讲解如何在Linux上借助宝塔面板搭建自己的MC服务器(原生服&amp;mod服)，之后的文章还会讲解再一些mod服上进阶操作及模组推荐（摸索中……）。</p></div><h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><ol><li>我的服务器的配置是<mark class="hl-label blue">1核2G&nbsp1Mbps</mark> 。经测试,原生服大约能<mark class="hl-label pink">同时容纳5人</mark> 不卡；mod服的话装5~6个模组基本上就只能供你和你的基友<mark class="hl-label green">二人联机</mark> 了。如果和我的VPS是一样的配置，选用原生服或是mod服请读者自行斟酌。</li><li>服务器的系统为<emp>Ubuntu 20.04.3 LTS</emp>。因为主要在<mark class="hl-label green">宝塔面板</mark> 上进行操作，所以使用centos应该差别不大。</li><li>我选择的MC版本为1.12.2。该版本为较为精简且功能完善，是当前MC服务器的主流版本，比较符合需求。想要使用其他版本的读者请自行修改。</li><li>我搭建MC服务器时踩的坑也会尽可能地分享出来，希望能给被某个问题困扰的读者一些帮助。</li><li>MC服务器搭建主要参考教程(特别感谢这位大佬)：<div class="tag link"><a class="link-card" title="Linux宝塔MC我的世界开服" href="https://bolg.cv0.cn/?p=23"><div class="left"><img src="/post/338db5e/link.png"></div><div class="right"><p class="text">Linux宝塔MC我的世界开服</p><p class="url">https://bolg.cv0.cn/?p=23</p></div></a></div></li></ol><hr><div class="tip "><p>默认读者已经有了服务器并安装了宝塔Linux面板。那么，开始搭建自己的MC服务器吧！</p></div><h1 id="相关文件的获取"><a href="#相关文件的获取" class="headerlink" title="相关文件的获取"></a>相关文件的获取</h1><div class="note warning modern"><p>该操作在自己的电脑上做。下载好相关文件后再一并上传到服务器。</p></div><h2 id="下载服务器核心"><a href="#下载服务器核心" class="headerlink" title="下载服务器核心"></a>下载服务器核心</h2><p>前往<a href="https://mcversions.net/">官网</a>下载相应版本的服务器核心。我想运行的版本是1.12.2，那么就下载：</p><p><img src="https://cloud.fullcomb.top/private/source/image/mc/vps/1.jpg" alt></p><div class="tip warning"><p>将下载得到的<mark class="hl-label pink">server.jar</mark> 重命名为<mark class="hl-label pink">minecraft_server.1.12.2.jar</mark> </p></div><h2 id="下载forge"><a href="#下载forge" class="headerlink" title="下载forge"></a>下载forge</h2><div class="tip "><p>仅mod服需要，原生服请跳过。</p></div><p>前往<a href="https://files.minecraftforge.net/net/minecraftforge/forge/">forge官网</a>下载对应版本的forge，1.12.2则下载：</p><p><img src="https://cloud.fullcomb.top/private/source/image/mc/vps/2.jpg" alt></p><p>下载后得到<mark class="hl-label green">forge-1.12.2-14.23.5.2860-universal.jar</mark> 。</p><h2 id="获取客户端配置文件"><a href="#获取客户端配置文件" class="headerlink" title="获取客户端配置文件"></a>获取客户端配置文件</h2><p>打开启动器(以HMCL为例，PCL Ⅱ同理)，按下图所示安装，保持服务端和客户端版本相同：</p><p><img src="https://cloud.fullcomb.top/private/source/image/mc/vps/3.jpg" alt></p><p>安装完成后，进入启动器目录下的.minecraft文件夹，将<mark class="hl-label blue">libraries</mark> 文件夹解压备用。</p><div class="note pink modern"><p>以上的文件已打包至云盘，懒人自取：</p><div class="tag link"><a class="link-card" title="onemanager" href="https://cloud.fullcomb.top/public/Minecraft/vps/"><div class="left"><img src="/post/338db5e/link.png"></div><div class="right"><p class="text">onemanager</p><p class="url">https://cloud.fullcomb.top/public/Minecraft/vps/</p></div></a></div></div><hr><h1 id="运行环境构建"><a href="#运行环境构建" class="headerlink" title="运行环境构建"></a>运行环境构建</h1><div class="note warning modern"><p>以下操作均在服务器的宝塔linux面板上操作。</p></div><h2 id="安装Java环境"><a href="#安装Java环境" class="headerlink" title="安装Java环境"></a>安装Java环境</h2><p>Java是Minecraft Java版运行的必要环境，进入终端，分别输入以下两条指令(ubuntu)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt install openjdk-11-jre-headless<br></code></pre></td></tr></table></figure><p>确认自己的Java环境是否安装好，输入<mark class="hl-label blue">java&nbsp-version</mark> ，若出现版本号，则安装成功。</p><h2 id="安装screen"><a href="#安装screen" class="headerlink" title="安装screen"></a>安装screen</h2><div class="note blue modern"><p>每当我们按下ctrl+c或退出远程连接的终端就会停止当前的进程。为了使自己的MC服务器能够24小时运行，我们总不可能一直开着终端吧！所以安装screen，让我们在退出终端后也能保证当前进程的稳定运行。</p></div><p>输入下面的指令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt install screen<br></code></pre></td></tr></table></figure><h2 id="构建文件目录"><a href="#构建文件目录" class="headerlink" title="构建文件目录"></a>构建文件目录</h2><p>点击左边的文件选项，推荐在<mark class="hl-label blue">/www/wwwroot/</mark> 下面创建mc文件夹。<emp>路径和文件夹名字无关紧要</emp>，读者根据自己的喜好来创建即可。</p><p>将刚才在本机上下好的文件拖拽上传到mc文件夹，并解压libraries.zip：</p><p><img src="https://cloud.fullcomb.top/private/source/image/mc/vps/4.jpg" alt></p><h2 id="创建脚本文件"><a href="#创建脚本文件" class="headerlink" title="创建脚本文件"></a>创建脚本文件</h2><p>在mc目录下创建一个sh脚本文件<mark class="hl-label pink">mc.sh</mark> ，写入以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br>java -Xmx2086M -Xms2086M -jar minecraft_server.1.12.2.jar<br></code></pre></td></tr></table></figure><div class="tip warning"><p>一定要逐行复制粘贴到mc.sh，不然有可能会出现一些问题。</p></div><hr><h1 id="开启原生服务器"><a href="#开启原生服务器" class="headerlink" title="开启原生服务器"></a>开启原生服务器</h1><h2 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h2><p>打开终端，进入mc文件夹所在的路径，我这里是/www/wwwroot/mc，那么输入<mark class="hl-label default">cd&nbsp/www/wwwroot/mc</mark> 后执行脚本文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /www/wwwroot/mc<br>./mc.sh<br></code></pre></td></tr></table></figure><p>如果执行<code>./mc.sh</code>报错：</p><p><img src="https://cloud.fullcomb.top/private/source/image/mc/vps/5.jpg" alt></p><div class="note warning flat"><p><span class="p red">那么大概率就是没有按照我上面说的逐行复制粘贴</span></p></div><div class="tip "><p>正常的情况应该像下面这样：</p></div><p><img src="https://cloud.fullcomb.top/private/source/image/mc/vps/6.jpg" alt></p><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>这时候我们生产了配置文件的mc文件夹应该像下面这样：</p><p><img src="https://cloud.fullcomb.top/private/source/image/mc/vps/7.jpg" alt></p><div class="note pink flat"><p>修改eula.txt文件，将<emp>eula=false改为eula=true</emp>。</p></div><p><img src="https://cloud.fullcomb.top/private/source/image/mc/vps/8.jpg" alt></p><h2 id="生成server-properties"><a href="#生成server-properties" class="headerlink" title="生成server.properties"></a>生成server.properties</h2><div class="note info flat"><p>这时候我们会发现server.properties还是空的，我们在去终端运行mc.sh脚本来更新server.properties的内容。</p></div><p>进入终端，重新运行以下mc.sh脚本，即输入下面的指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /www/wwwroot/mc<br>./mc.sh<br></code></pre></td></tr></table></figure><p>下面就是正常启动的结果，至此，<mark class="hl-label pink">原生服务器已经搭建成功！</mark> <psw>是不是很简单？</psw></p><p><img src="https://cloud.fullcomb.top/private/source/image/mc/vps/9.jpg" alt></p><div class="tip "><p>但是，现在的服务器还是默认配置，包括但不限于<mark class="hl-label pink">进行正版验证</mark> 。所以，我们还要对配置文件server.properties进行一些修改。</p></div><h2 id="修改server-properties"><a href="#修改server-properties" class="headerlink" title="修改server.properties"></a>修改server.properties</h2><p>如果读者使用的是离线登录的话，那么需要关闭正版验证：</p><p><img src="https://cloud.fullcomb.top/private/source/image/mc/vps/10.jpg" alt></p><div class="tip success"><p>其他选项请读者参考WIKI自己酌情修改：</p></div><div class="tag link"><a class="link-card" title="server.properties" href="https://minecraft.fandom.com/zh/wiki/Server.properties"><div class="left"><img src="/post/338db5e/link.png"></div><div class="right"><p class="text">server.properties</p><p class="url">https://minecraft.fandom.com/zh/wiki/Server.properties</p></div></a></div><h2 id="再次运行服务器"><a href="#再次运行服务器" class="headerlink" title="再次运行服务器"></a>再次运行服务器</h2><blockquote><p>配置文件修改完毕，我们就可以开启自己的原生服了。</p></blockquote><mark class="hl-label pink">这次我们开启screen，并将这个窗口命名为mc</mark> ；然后就是和之前一样的操作啦：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen -R mc<br><span class="hljs-built_in">cd</span> /www/wwwroot/mc<br>./mc.sh<br></code></pre></td></tr></table></figure><details class="folding-tag" cyan><summary> 阿里云用户请看 </summary>              <div class="content">              <p>对于阿里云的服务器，我们还需要配置安全组，开放25565端口给任意用户(或者指定ip)：</p><p><img src="https://cloud.fullcomb.top/private/source/image/mc/vps/11.jpg" alt></p>              </div>            </details><h2 id="客户端连接服务器"><a href="#客户端连接服务器" class="headerlink" title="客户端连接服务器"></a>客户端连接服务器</h2><p>接下来，我们在尝试连接这个服务器。</p><p>在添加服务器处，输入你服务器的<mark class="hl-label pink">[公网ip]:25565</mark> ，看能否搜索到你的服务器。成功的话应该是这样：</p><p><img src="https://cloud.fullcomb.top/private/source/image/mc/vps/12.jpg" alt></p><div class="tip success"><p>那么让你的好友加入服务器一起玩耍吧！</p></div><mark class="hl-label orange">重要的事情说三遍：</mark> <div class="note warning flat"><p>如果不想泄露自己的服务器公网ip,可以给自己的服务器的25565端口绑定一个域名(二级域名)，这样直接在添加服务器处输入你绑定的域名也可以解析到你的MC服务器。</p></div><div class="note warning flat"><p>如果不想泄露自己的服务器公网ip,可以给自己的服务器的25565端口绑定一个域名(二级域名)，这样直接在添加服务器处输入你绑定的域名也可以解析到你的MC服务器。</p></div><div class="note warning flat"><p>如果不想泄露自己的服务器公网ip,可以给自己的服务器的25565端口绑定一个域名(二级域名)，这样直接在添加服务器处输入你绑定的域名也可以解析到你的MC服务器。</p></div><psw>这个朋友就是逊啦~</psw><hr><h1 id="开启mod服务器"><a href="#开启mod服务器" class="headerlink" title="开启mod服务器"></a>开启mod服务器</h1><p>按下ctrl+c停止MC服务器当前进程。我们去修改一下<mark class="hl-label blue">mc.sh</mark> 脚本文件。</p><p>如下，将第二行注释掉，换成第三行的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><span class="hljs-comment">#java -Xmx2086M -Xms2086M -jar minecraft_server.1.12.2.jar</span><br>java -Xmx2086M -Xms2086M -jar forge-1.12.2-14.23.5.2860-universal.jar<br></code></pre></td></tr></table></figure><div class="tip warning"><p>仍然一行一行地复制粘贴，注意自己的forge版本号是否和上面一致。</p></div><p>然后到终端运行mc.sh：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /www/wwwroot/mc<br>./mc.sh<br></code></pre></td></tr></table></figure><p>再按ctrl+c结束进程，回到mc目录。如果目录下面出现了<mark class="hl-label green">mods</mark> 文件夹，那么即代表开启Mod服务器成功!</p><div class="note warning modern"><p>如果这一步遇到了问题，请见下文↓</p></div><hr><h1 id="mod服可能遇到的问题"><a href="#mod服可能遇到的问题" class="headerlink" title="mod服可能遇到的问题"></a>mod服可能遇到的问题</h1><div class="tip "><p>由于Forge只支持Java 8开发工具包，所以直接安装的Java可能会因为版本过高而导致mod服务器启动失败。这时，<mark class="hl-label pink">我们应该将Java的版本切换为Java8。</mark> </p></div><p>终端输入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo update-alternatives --config java<br></code></pre></td></tr></table></figure><p><img src="https://cloud.fullcomb.top/private/source/image/mc/vps/14.jpg" alt></p><blockquote><p><mark class="hl-label blue">选择2</mark> 即可将Java版本切换为Java8。</p></blockquote><hr><h1 id="mod服基本操作"><a href="#mod服基本操作" class="headerlink" title="mod服基本操作"></a>mod服基本操作</h1><ol><li>在终端输入/op [用户名]即可添加管理员</li><li>管理员可以使用MC里面的作弊命令，权限可以在server.properties进行设置。</li><li>安装模组，只需要将mod放进mods文件夹，同时客户端也要和服务端有相同的模组。<emp>否则会加载不出来</emp></li><li>开个坑，以后想到了继续补充。</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> 游戏与3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Minecraft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.3构造函数和析构函数</title>
      <link href="/post/83b4811f.html"/>
      <url>/post/83b4811f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>上一节中我们举了这样一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> _a;<br>    <span class="hljs-keyword">char</span> _b;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> (_a+_b);<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    MyClass m,n;<br>    m._a=<span class="hljs-number">1</span>;<br>    m._b=<span class="hljs-number">2</span>;<br>    n._a=<span class="hljs-number">3</span>;<br>    n._b=<span class="hljs-number">4</span>;<br>    std::cout&lt;&lt;m.<span class="hljs-built_in">add</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们是<mark class="hl-label pink">一个一个地将对象的成员进行初始化的</mark> 。<emp>这样不仅</emp><mark class="hl-label red">麻烦</mark> <emp>，而且使代码显得太长</emp>。</p><p>或许我们可以<mark class="hl-label blue">在类中定义一个初始化的函数</mark> ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">char</span> b)</span></span>&#123;<br>        _a=a;<br>        _b=b;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> _a;<br>    <span class="hljs-keyword">char</span> _b;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后我们再调用<code>init</code>函数就能将对象进行初始化。但这样不免还是有些<mark class="hl-label red">不智能</mark> 。</p><p>我们更希望在<emp>实例化对象的同时赋予一些值，就能进行类的初始化</emp>，就像<code>int a=1</code>这样，而不需要再手动调用初始化函数进行赋值。</p><div class="tip "><p>C++中，我们就要用到构造函数。</p></div><hr><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h2 id="构造函数的定义"><a href="#构造函数的定义" class="headerlink" title="构造函数的定义"></a>构造函数的定义</h2><div class="note green modern"><p>构造函数是一个特殊的<mark class="hl-label green">成员函数</mark> ，名字和类名相同。实例化类时，在生成相应的对象时<mark class="hl-label green">编译器会自动调用该函数</mark> ，保证每个对象都有一个合适的初始值。它在对象的生命周期内<mark class="hl-label green">只调用一次</mark> 。</p></div><div class="note green simple"><p>我们要<mark class="hl-label red">注意</mark> 定义中的这几点：</p><ol><li>构造函数的函数名与类名相同。</li><li>无返回值，所以不写返回值。</li><li>编译器会在实例化时自动调用。</li></ol></div><p>下面我们使用构造函数来简化上面例子中对象的初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> _a;<br>    <span class="hljs-keyword">char</span> _b;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> (_a+_b);<br>    &#125;<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">char</span> b)&#123;<br>        _a=a;<br>        _b=b;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">m</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span>,<span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span></span>;<br>    std::cout&lt;&lt;m.<span class="hljs-built_in">add</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note warning modern"><p>值得注意的是，构造函数必须是<mark class="hl-label pink">public成员</mark> ，不然编译器会报错！</p></div><blockquote><p>当然，构造函数不仅可以进行成员变量的初始化。任何你想在实例化类时进行的操作都可以放在构造函数里面。</p></blockquote><h2 id="使用初始化列表"><a href="#使用初始化列表" class="headerlink" title="使用初始化列表"></a>使用初始化列表</h2><p>对类中的成员进行初始化，上面的构造函数还是有些不简洁。<emp>使用初始化列表将初始化类中的成员和其他操作分开，可以提高程序的简洁性和可读性</emp>。</p><p>还是上面的例子，下面是使用初始化列表的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">MyClass</span>(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">char</span> b):_a(a),_b(b)&#123;<span class="hljs-comment">/*其他操作*/</span>&#125;<br></code></pre></td></tr></table></figure><p>这样构造函数看起来就很简洁。</p><div class="tip warning"><p>使用初始化列表要注意初始化的顺序<mark class="hl-label pink">只和成员变量在类中声明的顺序有关</mark> ，和列表中变量的顺序无关，如下面的程序：</p></div><div class="note orange simple"><p><img src="https://cloud.fullcomb.top/private/source/image/cpp/2/9.jpg" alt></p><p>上面的程序按理来说应该输出1，但是实际结果与预想的不同。</p><details class="folding-tag" orange><summary> 先想想为什么 </summary>              <div class="content">              <p>由于<code>_a</code>在类中先声明，所以先被初始化的应该是<code>_a</code>。这时候将还没有初始化<code>_b</code>的值赋给<code>_a</code>，所以最后输出的就是初始化前<code>_b</code>的值，是一个随机的值。</p>              </div>            </details></div><h2 id="重载和缺省参数"><a href="#重载和缺省参数" class="headerlink" title="重载和缺省参数"></a>重载和缺省参数</h2><div class="tip "><p>构造函数是支持<mark>重载和缺省参数</mark>的，这使得它的用法更加灵活。</p></div><h3 id="构造函数的重载"><a href="#构造函数的重载" class="headerlink" title="构造函数的重载"></a>构造函数的重载</h3><p>我们可以定义多个构造函数，它们<emp>必须有不同的形参列表</emp>！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> _a;<br>    <span class="hljs-keyword">char</span> _b;<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">char</span> b):_a(a),_b(b)&#123;&#125;<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-keyword">int</span> a):_a(a),_b(<span class="hljs-number">2</span>)&#123;&#125;<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-keyword">char</span> b):_a(<span class="hljs-number">1</span>),_b(b)&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样编译器会<emp>根据实参表来判断应该调用哪个构造函数</emp>。</p><h3 id="构造函数缺省参数"><a href="#构造函数缺省参数" class="headerlink" title="构造函数缺省参数"></a>构造函数缺省参数</h3><p>我们也可以给某些形参一个<mark class="hl-label blue">默认值</mark> ：</p><p><img src="https://cloud.fullcomb.top/private/source/image/cpp/2/10.jpg" alt></p><div class="tip success"><p>构造函数的重载和缺省参数与一般的函数一样，很容易理解，所以不再赘述。当两者都能达到目的时，一般情况下还是推荐使用重载，因为省略参数还对参数列表的顺序有要求。</p></div><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><p>如果我们没有定义构造函数，编译器会自动加上一个空的构造函数。<psw>然而没什么用。</psw></p></li><li><p>如果实例化类时，<mark class="hl-label pink">调用的构造函数的形参列表为空，那么就不能打括号！</mark> 如下：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> _a;<span class="hljs-keyword">char</span> _b;<br>    <span class="hljs-built_in">MyClass</span>():_a(<span class="hljs-number">1</span>),_b(<span class="hljs-number">2</span>)&#123;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    MyClass m;<span class="hljs-comment">//MyClass m();</span><br>&#125;<br></code></pre></td></tr></table></figure><p>读者可以先想一想上面代码存在的问题。</p><details class="folding-tag" blue><summary> 答案 </summary>              <div class="content">              <p><code>MyClass m()</code>似乎是一个合乎情理的写法，然而我们仔细观察一下，就会发现：<mark class="hl-label blue">这不就是函数声明吗！</mark> 是的，编译器会将该语句理解为一个作用域在main函数内的函数的声明，而不会将m识别为一个类类型的变量。当我们使用m时，编译器报错：<mark class="hl-label green">m具有非类类型。</mark> </p>              </div>            </details><div class="tip success"><p>我们正确的做法应该不加括号！</p></div><hr><h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><div class="tip "><p>同构造函数类似，析构函数在销毁对象时会被编译器自动调用。</p></div><h2 id="析构函数的定义"><a href="#析构函数的定义" class="headerlink" title="析构函数的定义"></a>析构函数的定义</h2><div class="note blue modern"><p>析构函数(destructor) 与构造函数相反，<mark class="hl-label pink">当对象被销毁时</mark> ，如对象所在的函数已调用完毕，系统就会自动执行析构函数。析构函数往往用来做<mark class="hl-label green">“清理善后”</mark> 的工作。</p></div><div class="tip warning"><p>但是注意析构函数不是用来销毁对象的，而是在对象的生命周期结束，对象被销毁的时候用来清理残余资源的。</p></div><div class="note orange simple"><p><strong>析构函数的特征如下</strong>：</p><ol><li>析构函数的函数名时类名前面加上<code>~</code>。</li><li>无返回值。</li><li>析构函数不能有参数！</li><li>编译器在对象销毁时自动调用。</li></ol></div><h2 id="析构函数的实例"><a href="#析构函数的实例" class="headerlink" title="析构函数的实例"></a>析构函数的实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> _a;<span class="hljs-keyword">char</span> _b;<br>    <span class="hljs-built_in">MyClass</span>():_a(<span class="hljs-number">1</span>),_b(<span class="hljs-number">2</span>)&#123;&#125;<br>    ~<span class="hljs-built_in">MyClass</span>()&#123;std::cout&lt;&lt;<span class="hljs-string">&quot;调用了析构函数&quot;</span>;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    MyClass m;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><emp>程序结束时</emp>(即main函数结束，所有资源被释放)，输出<mark class="hl-label blue">调用了析构函数</mark> 。<br><br>这个例子<emp>可以体现对象销毁时自动调用析构函数</emp>，但还不能体现出清理资源这一点。<br>我们再看看下面的例子（以教材的实现string类为例）：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">char</span>* _p;<br>    <span class="hljs-keyword">int</span> _size;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">String</span>(<span class="hljs-keyword">int</span> n);<br>    ~<span class="hljs-built_in">String</span>();<br>&#125;;<br>String::<span class="hljs-built_in">String</span>(<span class="hljs-keyword">int</span> n=<span class="hljs-number">5</span>):_size(n)&#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;调用了构造函数&quot;</span>&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>    _p = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(n*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">char</span>));<br>&#125;<br>String::~<span class="hljs-built_in">String</span>()&#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;调用了析构函数&quot;</span>&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-built_in">free</span> (_p);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    String s;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">调用了构造函数<br>调用了析构函数<br></code></pre></td></tr></table></figure><p>这个例子就比较完善了。我们在实例化string类时，<emp>调用构造函数，为它分配了空间</emp>；string对象销毁时，<emp>自动调用析构函数清理分配的空间</emp>。</p><h2 id="析构函数的意义"><a href="#析构函数的意义" class="headerlink" title="析构函数的意义"></a>析构函数的意义</h2><div class="tip "><p>析构函数的意义就是释放多余的空间。</p></div><p>我们给对象的成员动态分配了空间。<emp>即使这个对象被销毁，如果我们在之前没有手动释放这片空间的话，之前在堆上的分配空间仍然是存在的</emp>。但是指向它的指针已经被销毁，所以<emp>这片内存相当于悬空，成为内存垃圾</emp>。如果程序一直这样运行下去，内存垃圾越来越多，程序就会运行地越来越慢，最后可能会导致电脑死机。所以我们需要析构函数来帮我们自动化地解决这个问题。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 大二上 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.2类的存储模型和This指针</title>
      <link href="/post/9cbacfa0.html"/>
      <url>/post/9cbacfa0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><div class="tip "><p>本节我们将学习C++中类的存储模型，据此更好地讲解this指针及其作用。由于C++的类和C语言中的结构体大致相当，所以我们先回顾C中结构体的存储方式，即<mark class="hl-label pink">字节对齐</mark> 。</p></div><h2 id="先看个例子"><a href="#先看个例子" class="headerlink" title="先看个例子"></a>先看个例子</h2><p>学习C语言时，我们可能了解过<mark class="hl-label pink">结构体的字节对齐</mark> 。<psw>数据结构老师讲的合理吗……</psw>它是结构体的成员进行存储时采用的方式。比如，对于下面这样一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>&#123;</span><br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">char</span> b;<br>    <span class="hljs-keyword">int</span> c;<br>    <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> d;<br>    <span class="hljs-keyword">char</span> e;<br>&#125;MyStruct;<br></code></pre></td></tr></table></figure><p>可否想过，如果我们对其进行取大小运算，即<code>sizeof(MyStruct)</code>，结果将会是多少？</p><p>我们可能会直接将各个成员的大小加起来,所以结果将会是<code>4+1+4+2+1=12</code> 。我们不妨去程序里面验证一下:</p><p><img src="https://cloud.fullcomb.top/private/source/image/cpp/2/1.png" alt></p><p>结果和我们之前计算的竟然<emp>不一样</emp>！<psw>我不演了</psw>，这个问题就出在结构体的<mark class="hl-label pink">字节对齐</mark> 。</p><h2 id="字节对齐的含义"><a href="#字节对齐的含义" class="headerlink" title="字节对齐的含义"></a>字节对齐的含义</h2><p>字节对齐可以表述为：<mark class="hl-label blue">各种类型的数据按照一定的规则在空间上排列，而不是按顺序一个接一个地排放。</mark> 就上面的例子而言，<emp>结构体的中每四个字节分一段</emp>，所以储存的结果为：</p><details class="folding-tag" blue><summary> 如果知道字节对齐就先想想应该是怎么排放的吧 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/cpp/2/2.png" alt></p><blockquote><p>图中黑色部分表示间隔，没有存放数据。因为<code>c</code>占了4个字节，所以不能和<code>b</code>在一段里面，被挤到了下一段；相反地，<code>d</code>占2个字节，<code>e</code>占一个字节，所以它们就可以放在一段里面。</p></blockquote>              </div>            </details><h2 id="字节对齐的原因"><a href="#字节对齐的原因" class="headerlink" title="字节对齐的原因"></a>字节对齐的原因</h2><p>C语言是一门<emp>注重程序运行速度</emp>的语言，<mark class="hl-label pink">字节对齐其实是C语言以空间来换时间的一种方式</mark> 。</p><div class="note pink modern"><p>因为从计算机的角度来讲，它通常是以2，4或8的字节块来对程序进行读写的。C语言尽可能地<emp>使一个成员的读写在一次扫描中完成</emp>，就可以加快程序运行的速度。</p></div><h2 id="字节对齐的应用"><a href="#字节对齐的应用" class="headerlink" title="字节对齐的应用"></a>字节对齐的应用</h2><div class="tip "><p>学习字节对齐是有实际意义的！它在面试中也经常被问到，我们应该重视。</p></div><p>如果我们将上面例子中结构体成员的顺序改一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>&#123;</span><br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">char</span> b;<br>    <span class="hljs-keyword">char</span> e;<br>    <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> d;<br>    <span class="hljs-keyword">int</span> c;<br>&#125;MyStruct;<br></code></pre></td></tr></table></figure><p>再按照字节对齐的方式算一下，发现它的大小为<psw>12字节</psw>，恰好没有间隔！这样<emp>空间利用率就达到了最高</emp>。</p><p>所以，<mark class="hl-label blue">合理地安排结构体中的元素顺序，可以节省空间</mark> 。这应该作为程序员写代码时的自觉。</p><div class="note info flat"><p>上面的例子都是四字节对齐。除此之外，还有二字节和八字节对齐的方式，这和计算机有关。读者不妨去验证一下自己的计算机是哪种对齐方式（大多数都是四字节对齐）。</p></div><hr><h1 id="类的存储模型"><a href="#类的存储模型" class="headerlink" title="类的存储模型"></a>类的存储模型</h1><h2 id="类的大小"><a href="#类的大小" class="headerlink" title="类的大小"></a>类的大小</h2><p>明白了结构体的字节对齐，我们再<emp>对下面的类进行取大小运算</emp>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">char</span> b;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> (a+b);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>类相比于C语言中的结构体多了成员函数。我们先来分析可能的结果。</p><details class="folding-tag" red><summary> 先想想成员函数的大小可能会怎么计算 </summary>              <div class="content">              <p><code>int</code>占4字节，<code>char</code>占1字节，函数如果以指针的形式存储，占4字节。那么，按照字节对齐，该类的大小应该是12字节。是这样吗？我们接下来去程序中验证一下。</p><p><img src="https://cloud.fullcomb.top/private/source/image/cpp/2/3.png" alt></p><p>最终的结果是8字节，与预想的不同！我们可以验证，<mark class="hl-label pink">函数在类中是不占空间的</mark> 。</p>              </div>            </details><div class="tip "><p>值得注意的是，C++为空类分配了1个字节的空间，表示它是存在的。</p></div><h2 id="C-的内存模型"><a href="#C-的内存模型" class="headerlink" title="C++的内存模型"></a>C++的内存模型</h2><p>在讲类的存储模型之前，我们先来研究一下<mark class="hl-label green">C++的内存模型</mark> 。</p><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1-1">C++的内存模型图解</button></li><li class="tab"><button type="button" data-href="#1-2">说明</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p><img src="https://cloud.fullcomb.top/private/source/image/cpp/2/4.png" alt></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><ol><li>栈是我们经常用到的。<emp>调用一个函数，就要在栈上开辟一个新的空间</emp>，栈从高地址向下生长。</li><li><emp>动态内存分配的空间就在堆上</emp>，堆向上生长。</li><li><emp>数据段</emp>包括全局区，静态区和常量区，<emp>是程序运行前事先分配好的</emp>。</li><li>代码段，顾名思义存的就是代码。不过，它不是将我们的程序原封不动地存储，而是以二进制指令的形式进行存储。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="类的存储模型-1"><a href="#类的存储模型-1" class="headerlink" title="类的存储模型"></a>类的存储模型</h2><p>类的成员变量和结构体的存储一样，<mark class="hl-label pink">我们关注的是类中函数的存储</mark> 。</p><p><img src="https://cloud.fullcomb.top/private/source/image/cpp/2/5.png" alt></p><p>如上图，对于一个类的所有对象，它们的成员变量可以不同，但是成员函数都是一样的。那么<emp>为了节省存储空间</emp>，我们应该让它们共用这个函数。即<emp>一个类的成员函数存放在公共的代码段</emp>。</p><p>我们可以通过程序来验证这一点：</p><p><img src="https://cloud.fullcomb.top/private/source/image/cpp/2/7.jpg" alt></p><blockquote><p><code>myclass</code>和<code>yourclass</code>的add函数的地址都是相同的，可以说明类的成员函数存放在公共的代码段。</p></blockquote><div class="tip "><p>总结<mark class="hl-label pink">类的存储模型：</mark> </p><ol><li>成员函数在类中不占空间，它储存在公共的代码段。</li><li>类中的成员变量按照字节对齐的方式进行存储。</li><li>空类占一个字节表示存在。</li></ol></div><hr><h1 id="This指针"><a href="#This指针" class="headerlink" title="This指针"></a>This指针</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>通过上面类的存储模型，我们知道了成员函数都存储在公共的代码段中。那么问题来了，对于下面的程序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> _a;<br>    <span class="hljs-keyword">char</span> _b;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> (_a+_b);<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    MyClass m,n;<br>    m._a=<span class="hljs-number">1</span>;<br>    m._b=<span class="hljs-number">2</span>;<br>    n._a=<span class="hljs-number">3</span>;<br>    n._b=<span class="hljs-number">4</span>;<br>    std::cout&lt;&lt;m.<span class="hljs-built_in">add</span>();<br>&#125;<br><span class="hljs-comment">//输出3，即1+2</span><br></code></pre></td></tr></table></figure><p>这个程序中<code>MyClass</code>的实例有<code>m</code>和<code>n</code>两个。我们调用<code>m</code>中的<code>add()</code>函数时，通过<code>add</code>这个函数名找到对应函数在代码段中的地址。可是，<code>m.add()</code>和<code>n.add()</code>都指向的是同一个函数的地址，那么，↓</p><div class="tip warning"><p>这个函数如何知道是m这个实例在调用它而不是n呢？</p></div><h2 id="this指针的含义"><a href="#this指针的含义" class="headerlink" title="this指针的含义"></a>this指针的含义</h2><div class="tip "><p>C++通过This指针来解决上面的问题。</p></div><div class="note blue modern"><p><span class="p center small"><strong>This指针的定义</strong></span></p><p>C++编译器给每个给每个非静态的成员函数增加了一个<mark class="hl-label blue">隐藏的指针参数</mark> ，让<mark class="hl-label green">该指针指向调用当前函数的对象</mark> 。该函数体中的所有对成员变量的操作，都是通过这个指针来访问的。</p></div><p>调用成员函数的地方，<emp>编译器会自动增加了对象的地址作为隐藏的实参</emp>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::cout&lt;&lt;m.<span class="hljs-built_in">add</span>(&amp;m);<br></code></pre></td></tr></table></figure><p>而类中成员函数的定义，就会<emp>自动添加this指针作为形参</emp>，同时<emp>this指针会指向函数里面的成员变量</emp>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(MyClass* <span class="hljs-keyword">this</span>)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>-&gt;_a+<span class="hljs-keyword">this</span>-&gt;_b);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这样成员函数就知道是哪个实例在调用它了，同时也能正确地对该实例中的成员变量进行操作。</p></blockquote><p>我们通过下面的程序对<mark class="hl-label pink">this指针的存在</mark> 及其<mark class="hl-label default">指向这个对象blue</mark> 进行证明：</p><p><img src="https://cloud.fullcomb.top/private/source/image/cpp/2/8.jpg" alt></p><h2 id="this指针在哪？"><a href="#this指针在哪？" class="headerlink" title="this指针在哪？"></a>this指针在哪？</h2><p>这是一个频率极高的面试题，但是，如果我们明白什么是this指针，这个问题也就迎刃而解了。</p><div class="tip success"><p>this指针是成员函数的一个形参。由C++的内存模型知，当我们调用这个成员函数的时候，就会使用到栈空间。this指针就存储在栈空间里面。</p></div>]]></content>
      
      
      <categories>
          
          <category> 大二上 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1类与结构体与对象</title>
      <link href="/post/183dd111.html"/>
      <url>/post/183dd111.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="tip "><p>C++是一门面向对象的语言。C++刚出现的时候，被称为”C with Classes”，可见类之于C++的重要性。<mark class="hl-label blue">在本章我们将关注C++的类及其用法。</mark> </p></div><h1 id="引言-C语言的结构体"><a href="#引言-C语言的结构体" class="headerlink" title="引言:C语言的结构体"></a>引言:C语言的结构体</h1><p>C语言中，我们学习了结构体。使用结构体可以把不同类型的变量组合在一起。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>&#123;</span><br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">char</span> b;<br>    <span class="hljs-keyword">float</span> c;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span> <span class="hljs-title">mystruct</span>;</span><br></code></pre></td></tr></table></figure><div class="note warning modern"><p>使用结构体，要分清下面几个概念：</p><ol><li><mark class="hl-label pink">结构体名</mark> ：<code>MyStruct</code>是结构体的名字。</li><li><mark class="hl-label green">结构体类型</mark> ：<code>struct Mystruct</code>是一个结构体类型</li><li><mark class="hl-label blue">结构体变量</mark> ：<code>struct MyStruct</code>类型的变量<code>mystruct</code>是一个结构体变量。</li></ol></div><p>为了避免每次定义结构体变量的时候都要写 <code>struct MyStruct</code> ,我们常常采用 <mark class="hl-label red">typedef</mark> 的方式将结构体名升级为类型名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>&#123;</span><br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">char</span> b;<br>    <span class="hljs-keyword">float</span> c;<br>&#125;MyStruct;<br>MyStruct mystruct;<br></code></pre></td></tr></table></figure><p>通过<code>typedef</code> ，我们将结构体类型 <code>struct MyStruct</code> 命名为 <code>MyStruct</code> ，这样定义结构体变量的时候就不用多写<code>struct</code> 了。</p><div class="tip success"><p>但是，使用typedef只是权益之计。我们基本上不会用到结构体名，所以更希望定义的结构体直接就是一个类型，这样更加简洁。C++中的类解决了这个问题。<emp>类与结构体有着千丝万缕的联系</emp>。</p></div><blockquote><p>C++当然不是因为这个原因而引入类。但是从这个问题里我们可以看出C和C++的不同理念：C语言注重程序运行的速度和占用空间的最优；C++牺牲了一部分运行速度以换取程序的简洁与编程的效率。</p></blockquote><hr><h1 id="类与结构体"><a href="#类与结构体" class="headerlink" title="类与结构体"></a>类与结构体</h1><h2 id="C-的结构体"><a href="#C-的结构体" class="headerlink" title="C++的结构体"></a>C++的结构体</h2><p>C++遵循简洁性，结构体的定义比C语言更加简单，定义的结构体名可直接作为类型名使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>&#123;</span><br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">char</span> b;<br>    <span class="hljs-keyword">float</span> c;<br>&#125;;<br>MyStruct mystruct;<br></code></pre></td></tr></table></figure><p>同时，结构体内部的<emp>成员不仅可以是变量，还可以是函数</emp>，如下图：</p><p><img src="https://cloud.fullcomb.top/private/source/image/cpp/2/6.jpg" alt></p><div class="note info flat"><p>访问结构体中的函数和访问其中的变量的方法相同，都是<mark class="hl-label pink">结构体变量.成员</mark> 的方式。</p></div><h2 id="类的引入"><a href="#类的引入" class="headerlink" title="类的引入"></a>类的引入</h2><p>为了保持和C语言的<mark class="hl-label orange">兼容性</mark> ，C++<mark class="hl-label pink">采用类来代替结构体</mark> ，同时C语言中的结构体在C++中依然保留。</p><div class="tip "><p>如果不这样做的话，随着C++的发展，C++的结构体可能会与C语言的结构体不兼容，C语言的结构体拿到C++中就可能出错或与预想结果不符。</p></div><p>所以类类型的定义应该看起来是下面的样子（和结构体差不多）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&#123;</span><br>    <span class="hljs-comment">//成员变量</span><br>    <span class="hljs-comment">//成员函数</span><br>&#125;;<span class="hljs-comment">//不要忘了分号！</span><br></code></pre></td></tr></table></figure><div class="tip warning"><p>再强调一遍，不要忘了分号！</p></div><h2 id="结构体与类的区别"><a href="#结构体与类的区别" class="headerlink" title="结构体与类的区别"></a>结构体与类的区别</h2><ol><li><p>下面我们会知道，<emp>类的成员的访问默认是私有的</emp>，在类外不能访问到。</p></li><li><p>而C++的结构体为了保持与C语言中结构体的<mark class="hl-label orange">兼容性</mark> ，它的<emp>成员默认是公有的</emp>，可以在结构体外访问到。<span class="nota" data-nota="不然，C语言的结构体拿到C++就无法在外部访问，一旦在外访问就会报错">想想为什么？</span></p></li><li>本质上，C++的<mark class="hl-label red">类就是结构体</mark> ，或者说<mark class="hl-label red">结构体其实就是一种类</mark> 。</li></ol><hr><h1 id="类的访问控制及定义方式"><a href="#类的访问控制及定义方式" class="headerlink" title="类的访问控制及定义方式"></a>类的访问控制及定义方式</h1><h2 id="类的访问控制"><a href="#类的访问控制" class="headerlink" title="类的访问控制"></a>类的访问控制</h2><p>C++使用<mark class="hl-label pink">public</mark> 、<mark class="hl-label blue">private</mark> 、<mark class="hl-label green">protected</mark> 这三个关键字来<emp>控制用户对类成员的访问权限</emp>。这三个关键字称为<mark class="hl-label blue">段约束符</mark> 。</p><div class="note blue modern"><ol><li>使用<mark class="hl-label pink">public</mark> 修饰的成员，在类外是可以访问到的。<code>public</code>成员<emp>常常作为类对外部的访问接口</emp>。</li><li>使用<mark class="hl-label blue">private</mark> 修饰的成员，在类外是不能访问的，否则编译器会报错 <code>xxx is private within this context</code> 。它只能在类内访问，是开发者有意隐藏，<emp>不希望用户直接访问到的部分</emp>。</li><li>使用<mark class="hl-label green">protected</mark> 修饰的成员，<emp>可以在子类(派生类)中被访问到</emp>,除此之外内外则不能访问。子类的概念将会在继承部分给出。</li></ol></div><h2 id="类的定义方式"><a href="#类的定义方式" class="headerlink" title="类的定义方式"></a>类的定义方式</h2><emp>结合类的访问控制</emp>，我们给出<mark class="hl-label pink">类规范的定义方式</mark> ：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">char</span> b)</span></span>&#123;<br>        _a=a;<br>        _b=b;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> _a;<br>    <span class="hljs-keyword">char</span> _b;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> (_a+_b);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><div class="note pink modern"><p><span class="p center small"><strong>说明</strong></span></p><ol><li><p><mark class="hl-label pink">建议在类的成员变量前面加一个下划线</mark> 。否则，以<code>init()</code>函数为例，就会出现 <code>a=a</code>、 <code>b=b</code>的情况，很不自然。而加下划线就可以将它们区分，同时类的成员变量的有下划线，也有助于我们对类成员的识别，提高程序可读性。</p><p>而函数没有这个冲突，所以可加可不加。但为了提高可读性也建议加上。<psw>不想打不加也行</psw></p></li><li><p>关于缩进，建议<code>public</code>，<code>private</code>，<code>protected</code>顶格，之间的代码离最左边一个Tab。个人认为这样代码美观一些。反正这是提高可读性的一种方式，怎么好看就怎么来。</p></li></ol></div><h2 id="类的实现"><a href="#类的实现" class="headerlink" title="类的实现"></a>类的实现</h2><p>上面的例子，类的成员函数是放在类内实现的。</p><p>一般地，类的成员函数，<emp>既可以在类内实现，也可以在类外实现</emp>。</p><h3 id="类外实现"><a href="#类外实现" class="headerlink" title="类外实现"></a>类外实现</h3><p>我们在类内声明了一个函数，在类外实现这个成员函数的时候，要加上<emp>类名和访问限制修饰符</emp><mark class="hl-label blue">::</mark> 。还是以之前的类为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">char</span> b)</span></span>&#123;<br>        _a=a;<br>        _b=b;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> _a;<br>    <span class="hljs-keyword">char</span> _b;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MyClass::show</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MyClass::add</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (_a+_b);<br>&#125;<br></code></pre></td></tr></table></figure><div class="tip "><p>在类外定义访问权限为<mark class="hl-label blue">private</mark> 的函数与它不能在类外被访问到并不矛盾。</p></div><h3 id="类内实现"><a href="#类内实现" class="headerlink" title="类内实现"></a>类内实现</h3><p>类内实现函数的比较简单，所以此处不再赘述。</p><div class="note warning flat"><p>要注意的是，类内实现的函数，<mark class="hl-label pink">编译器会判断是否要将其优化为内联函数！</mark> 如果该函数没有循环语句和递归语句，则编译器会将其识别为内联函数，<mark class="hl-label blue">相当于自动在它前面加上了inline关键字</mark> 。</p></div><blockquote><p>要证明这一点很简单，只需要观察汇编代码中是否有<code>call</code>指令即可。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><div class="note blue flat"><p><span class="p center small"><strong>类的成员函数的实现</strong></span></p><ol><li>成员函数的<emp>函数体比较短，建议放在类内实现</emp>。这样编译器会自动将其优化为内联函数，加快程序运行的速度。</li><li>成员函数的<emp>函数体比较长，建议放在类外实现</emp>。这样会避免类的代码过长，使得程序可读性降低。</li><li>类外实现的函数，必须将函数的声明和定义放在同一个文件中，或类放在头文件中，定义（实现）放在cpp文件中。<emp>即定义要找得到声明</emp>。</li><li>成员函数在类外实现是更常见的方式。</li></ol></div><hr><h1 id="类与面向对象"><a href="#类与面向对象" class="headerlink" title="类与面向对象"></a>类与面向对象</h1><h2 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h2><blockquote><p>我们可以把类看成一个房屋的图纸，它规定了房屋应该怎么修建。但是，它没有真正地修好这个房屋。要建出这个“房屋”，还要进行实例化。</p></blockquote><mark class="hl-label blue">类的实例化，就是定义一个类类型的变量。</mark> 比如我已经定义了名叫MyClass的类类型，我们再定义一个类类型的变量：<mark class="hl-label green">MyClass&nbsp;myclass</mark>  ，这就是类的实例化。而<mark class="hl-label pink">对象就是类的实例。</mark> <h2 id="面向对象的理解"><a href="#面向对象的理解" class="headerlink" title="面向对象的理解"></a>面向对象的理解</h2><mark class="hl-label default">面向对象编程，即OOP(Object&nbsp;Oriented&nbsp;Progra)。它是C++的核心。</mark> <p>面向对象和面向过程有什么区别呢？</p><emp>它们都是认识世界的方式，但角度不同</emp>。以进浴室洗澡为例，<br><br><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#1-1">面向过程</button></li><li class="tab"><button type="button" data-href="#1-2">面向对象</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="1-1"><ul><li>打开浴室门</li><li>打开水龙头</li><li>洗澡</li><li>擦身体</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><ul><li>对于门这个对象，它的方法是开门这个动作。我们传递力的大小的参数给门，如果满足的话就打开。</li><li>水龙头同理，调用放水这个方法。</li><li>人调用洗澡这个方法。</li><li>毛巾调用吸水的方法。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><mark class="hl-label red">结论</mark> <div class="note red flat"><p>面向过程一直以人的视角来完成事件；而面向对象则是不断切换角度和观察对象，调用所关注对象的某个方法来完成某个事件，然后依靠参数的传递完成对象之间的交互</p></div>]]></content>
      
      
      <categories>
          
          <category> 大二上 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学复习笔记</title>
      <link href="/post/719672b4.html"/>
      <url>/post/719672b4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="tip "><p>PS：本篇由我在临近期末时做的笔记改编而来。<psw>其实就只是改了一些错误，增加了期末考试自己没有复习到的知识点(悲)，最后边嗑瓜子边打了一遍</psw>。毕竟复习笔记重点还算分明，故记之，做查阅用。</p></div><h1 id="计算机图形学中的基本概念"><a href="#计算机图形学中的基本概念" class="headerlink" title="计算机图形学中的基本概念"></a>计算机图形学中的基本概念</h1><h2 id="简述研究内容"><a href="#简述研究内容" class="headerlink" title="简述研究内容"></a>简述研究内容</h2><details class="folding-tag" red><summary> 答案 </summary>              <div class="content">              <p>计算机图形学的主要研究内容有<mark class="hl-label blue">建模</mark> 、<mark class="hl-label pink">渲染</mark> 、<mark class="hl-label green">动画</mark> 。</p><ol><li><mark class="hl-label blue">Modeling</mark> :创建3D几何对象的模型，即三维物体模型的计算机表示。</li><li><mark class="hl-label pink">Rendering</mark> :从3D模型生成2D图像。</li><li><mark class="hl-label green">Animation</mark> :描述对象的运动。</li></ol>              </div>            </details><h2 id="图形与图像的区别"><a href="#图形与图像的区别" class="headerlink" title="图形与图像的区别"></a>图形与图像的区别</h2><div class="tabs" id="-1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1-1">图像</button></li><li class="tab"><button type="button" data-href="#-1-2">图形</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1-1"><p><mark class="hl-label default">图像(image)</mark> 是人为用外部设备捕捉到的具有视觉效果的画面，是位图。计算机存储图像中<emp>每个像素点的位置、颜色、灰度等信息</emp>，所占内存较大。</p><p>常见的图像格式有jpg、JEPG、png、BMP等。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-1-2"><p><mark class="hl-label default">图形(graph)</mark> 强调的是<emp>场景的几何表示</emp>，通过<emp>方程等数学形式</emp>对物体进行描述，是矢量图。它所占内存较小。</p><p>常见的图形格式有SVG等。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h1 id="图形系统"><a href="#图形系统" class="headerlink" title="图形系统"></a>图形系统</h1><h2 id="图形系统的组织与功能"><a href="#图形系统的组织与功能" class="headerlink" title="图形系统的组织与功能"></a>图形系统的组织与功能</h2><p><img src="https://cloud.fullcomb.top/private/source/image/cg/1.jpg" alt></p><blockquote><p>左边的是软件，右边的是硬件。</p></blockquote><h2 id="图形软件包"><a href="#图形软件包" class="headerlink" title="图形软件包"></a>图形软件包</h2><div class="note red modern"><p>图形软件包分为<mark class="hl-label red">专用图形软件包</mark> 和<mark class="hl-label red">通用编程软件包</mark> 。</p><ol><li>专用图形软件包是为非程序员设计,其接口通常是一组菜单，如CAD(<psw>不是C4D……考试写错了</psw>)。</li><li>通用编程软件包提供一个可用于高级程序设计语言的图形函数库作为<emp>计算机图形应用编程接口</emp>，如GL、OpenGL等。</li></ol></div><h2 id="显示器-刷新式CRT"><a href="#显示器-刷新式CRT" class="headerlink" title="显示器:刷新式CRT"></a>显示器:刷新式CRT</h2><details class="folding-tag" blue><summary> 结构 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/cg/2.jpg" alt></p>              </div>            </details><ol><li><p><emp>发光原理</emp>：电子轰击荧光屏上的荧光物质，使其发生能级跃迁，从而发出荧光。</p></li><li><p><emp>荧光屏的特性</emp>包括荧光质的颜色和余晖。</p></li><li><p><emp>余晖</emp>是指荧光质<span class="p blue">从最大亮度衰减到最大亮度的10%的这段时间</span>，通常为10~60ms。</p></li><li><emp>光点</emp>是显示器能够显示的最小发光点。<span class="p blue">它的物理直径定义为光点亮度下降到最大亮度60%处的直径。</span><blockquote><p>当两个光点的距离大于物理直径时，两个光点是可区分的。</p></blockquote></li><li><emp>屏幕分辨率</emp>是指CRT上<span class="p blue">无重叠显示的最大光点数</span>。<div class="note warning modern"><p>区别屏幕分辨率和显示分别率！前者是指显示屏，后者是指图像，下面会讲。我们一般指的分辨率是显示分辨率，屏幕分辨率相对不是那么重要。</p></div></li><li><emp>显示器的扫描方式</emp>分为逐行扫描和隔行扫描。下面观察逐行扫描和隔行扫描的方式。<div class="tabs" id="-1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#-1-1">逐行扫描</button></li><li class="tab"><button type="button" data-href="#-1-2">隔行扫描</button></li><li class="tab"><button type="button" data-href="#-1-3">结论</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="-1-1"><p><img src="https://cloud.fullcomb.top/private/source/image/cg/3.png" alt></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-1-2"><p><img src="https://cloud.fullcomb.top/private/source/image/cg/4.jpg" alt></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-1-3"><ul><li>逐行扫描一帧包含多次从左至右的扫描、水平回扫以及一次垂直回扫。</li><li>隔行扫描一帧分为两场，分别扫描奇数行和偶数行，两场之间用垂直回扫连接。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li></ol><hr><h1 id="图形的信息"><a href="#图形的信息" class="headerlink" title="图形的信息"></a>图形的信息</h1><h2 id="图形信息的存储"><a href="#图形信息的存储" class="headerlink" title="图形信息的存储"></a>图形信息的存储</h2><div class="tip warning"><p>一幅图片可以看作是像素的集合。像素是当前<emp>显示分辨率</emp>所能提供的最小点。图形的信息就储存在像素中。</p></div><ol><li><p><mark class="hl-label pink">显示分辨率</mark> 就是水平和垂直两个方向上像素数量的乘积，如720p<script type="math/tex">\times</script>​​​​480p。</p></li><li><p>像素的信息，即<mark class="hl-label blue">强度值</mark> 被储存在帧缓冲区中。</p></li><li><p><mark class="hl-label green">色深</mark> 即像素信息的长度,以bit为单位。最少为1b,显示为黑白。若能显示16色,即$2^4$​,则色深为4b。</p><blockquote><p>强度和色深差不多是一个意思。只是强度指的是图像的信息，而色深则指信息的位数。</p></blockquote></li><li><p>常考的计算：<mark class="hl-label red">帧缓冲区容量=显示分辨率$\times$​色深</mark> 。</p></li></ol><h2 id="颜色和灰度"><a href="#颜色和灰度" class="headerlink" title="颜色和灰度"></a>颜色和灰度</h2><div class="note pink modern"><p>对于颜色，我们要分清两点：<emp>使用的颜色数</emp>和<emp>所存储的颜色数量</emp>。使用的颜色是指在该时刻用户使用的颜色，它小于等于存储的颜色数；存储的颜色数就是所能使用的颜色的最大数量。</p></div><ol><li><p>颜色的<emp>直接存储</emp>：直接在帧缓冲区中存储颜色信息。</p><div class="note pink flat"><p>如：要储存$2^{24}$种颜色，那么帧缓冲区的一个像素的色深为24b。</p></div></li><li><p>颜色的<emp>查找表存储</emp>：帧缓冲区存储颜色查找表的索引值。索引值的位数代表了<mark class="hl-label pink">同一时刻能</mark> 够使用的最大颜色数；颜色查找表的位数代表了<mark class="hl-label pink">总共</mark> 可以使用的最大颜色数。</p><div class="note pink flat"><p>如：每像素20位的帧缓存和每像素24位的颜色查找表的RGB光栅系统，总共可以显示$2^{24}$种颜色，在任意时刻可以同时显示$2^{20}$种颜色。</p></div></li><li><p>灰度：当RGB三个分量相等时，颜色为某种程度的灰色。一个灰色对应一个<mark class="hl-label pink">灰度等级</mark> 。</p></li></ol><hr><h1 id="观察流水线"><a href="#观察流水线" class="headerlink" title="观察流水线"></a>观察流水线</h1><p><img src="https://cloud.fullcomb.top/private/source/image/cg/5.jpg" alt></p><hr><h1 id="点的绘制"><a href="#点的绘制" class="headerlink" title="点的绘制"></a>点的绘制</h1><p>原理：根据点的坐标$(x,y)$​​​​，对帧缓冲区相应存储单元的内容进行操作以画点。</p><div class="note red modern"><p><span class="p center small">寻址</span></p><p><img src="https://cloud.fullcomb.top/private/source/image/cg/6.png" alt></p><p>寻址公式为<script type="math/tex">addr(x,y)=addr(0,0)+[y_0\times(x_{max}+1+x_0)\times\color_depth]</script></p></div><hr><h1 id="直线的绘制"><a href="#直线的绘制" class="headerlink" title="直线的绘制"></a>直线的绘制</h1><div class="tip "><p>直线绘制的基本原理是获得直线上的各像素点，然后再对各点进行绘制。所以直线绘制的重点是<span class="p yellow">高效得获得直线上的像素点的坐标</span>。<psw>绘制的其实是线段……</psw></p></div><h2 id="DDA算法"><a href="#DDA算法" class="headerlink" title="DDA算法"></a>DDA算法</h2><blockquote><p>思想：在一个坐标轴上以单位间隔取样，另一个坐标轴以m或$\frac{1}{m}$变化，从而获得线段上的各像素点。</p></blockquote><p><img src="https://cloud.fullcomb.top/private/source/image/cg/7.png" alt></p><blockquote><p>缺点：取整和浮点运算比较耗时，且较长线段会产生误差累积。</p></blockquote><h2 id="Bresenham画线算法"><a href="#Bresenham画线算法" class="headerlink" title="Bresenham画线算法"></a>Bresenham画线算法</h2><div class="tip "><p>我们重点关注使用Bresenham算法的计算流程。具体公式是怎么推出的见教材。</p></div><p><img src="https://cloud.fullcomb.top/private/source/image/cg/8.jpg" alt></p><p>同理可知，当$m&gt;1$​时，计算流程为：</p><details class="folding-tag" cyan><summary> 先想想再打开 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/cg/9.png" alt></p>              </div>            </details><p>而当斜率小于0时可以先用对称性把斜率转化为大于0。所以只研究斜率大于0的情况不失一般性。</p><h2 id="中点画线算法"><a href="#中点画线算法" class="headerlink" title="中点画线算法"></a>中点画线算法</h2><hr><h1 id="圆的生成"><a href="#圆的生成" class="headerlink" title="圆的生成"></a>圆的生成</h1><h2 id="中点画圆算法"><a href="#中点画圆算法" class="headerlink" title="中点画圆算法"></a>中点画圆算法</h2><details class="folding-tag" cyan><summary> 先想想再打开 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/cg/10.png" alt></p>              </div>            </details><h2 id="Bresenham画圆算法"><a href="#Bresenham画圆算法" class="headerlink" title="Bresenham画圆算法"></a>Bresenham画圆算法</h2><details class="folding-tag" cyan><summary> 先想想再打开 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/cg/11.png" alt></p>              </div>            </details><hr><h1 id="图形填充"><a href="#图形填充" class="headerlink" title="图形填充"></a>图形填充</h1><div class="tip "><p>画好图形后就要对其进行填充。然而，凹多边形的填充算法相对凸多边形更加复杂(不限于填充算法)，同时我们可以通过切割的方法讲凹多边形转化为凸多边形。所以填充之前我们还要进行<mark>凹多边形和凸多边形的识别</mark>。</p></div><h2 id="识别凹多边形"><a href="#识别凹多边形" class="headerlink" title="识别凹多边形"></a>识别凹多边形</h2><mark class="hl-label blue">方法</mark> ：叉积法<div class="note blue flat"><ol><li>若各叉积的Z分量均同号，则为凸多边形。</li><li>若有正有负，则为凹多边形。</li></ol></div><div class="tip error"><p>进行填充之前，还要做的一件事就是<mark>鉴别非标准多边形的内部区域</mark>，即进行内外测试。</p></div><h2 id><a href="#" class="headerlink" title></a><span class="p red">内外测试</span></h2><mark class="hl-label red">方法一</mark> ：奇偶规则<div class="note red flat"><ol><li>若射线穿过的边的条数为奇数，则为内部区域。</li><li>若射线穿过的边的条数为偶数，则为外部区域。</li></ol></div><mark class="hl-label red">方法二</mark> ：非零环绕规则<div class="note red flat"><p>从区域内部任意位置引出一条不过顶点的射线</p><ol><li>从左至右穿过，减1</li><li>从右至左穿过，加1</li></ol><p>若最终结果不等于0，则为内部区域。</p></div><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1-1">例子</button></li><li class="tab"><button type="button" data-href="#1-2">奇偶规则</button></li><li class="tab"><button type="button" data-href="#1-3">非零环绕规则</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>观察下面奇偶规则和非零环绕规则的例子。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><p><img src="https://cloud.fullcomb.top/private/source/image/cg/12.jpg" alt></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-3"><p><img src="https://cloud.fullcomb.top/private/source/image/cg/13.jpg" alt></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="区域填充"><a href="#区域填充" class="headerlink" title="区域填充"></a>区域填充</h2><h3 id="扫描线算法"><a href="#扫描线算法" class="headerlink" title="扫描线算法"></a>扫描线算法</h3><div class="note green modern"><p>方法：自底向上扫描，包括<emp>求交、排序、配对、着色</emp>四步。</p><ol><li>若扫描线穿过的是顶点，要注意顶点的取舍。此时，<emp>以扫描线以上与该顶点相邻的边的条数作为在该顶点处的交点个数</emp>。</li><li>配对时，按照顶点编号<mark class="hl-label green">1与2</mark> 、<mark class="hl-label green">3与4</mark> ……的方式配对</li></ol></div><h3 id="边界填充算法"><a href="#边界填充算法" class="headerlink" title="边界填充算法"></a>边界填充算法</h3><div class="note green modern"><p>方法：从内部的一点开始，以一种指定的颜色填充，直到边界为止。</p><ol><li>若为<mark class="hl-label blue">4-填充</mark> ，则有时可能<emp>填不完整</emp>。</li><li>若为<mark class="hl-label green">8-填充</mark> ，则有时可能<emp>填充越界</emp>。</li></ol></div><hr><h1 id="走样与反走样"><a href="#走样与反走样" class="headerlink" title="走样与反走样"></a>走样与反走样</h1><div class="tip "><p>像素是离散的，当我们用有限的像素来逼近直线时，就会产生锯齿，这就是<mark class="hl-label pink">走样</mark> 。而我们通过一些方法来减小这种锯齿，就是<mark class="hl-label green">反走样</mark> 。</p></div><mark class="hl-label default">反走样技术</mark> <div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1-1">硬件解决</button></li><li class="tab"><button type="button" data-href="#1-2">软件解决</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>采用高分辨率的显示器。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><p><mark class="hl-label pink">基本思路</mark> 是<emp>使边界的亮度更低，中间的亮度更高</emp>，从而减轻据齿的视觉效应。</p><ol><li><mark class="hl-label blue">过取样技术</mark> ：高分辨率取样确定亮度等级，然后在低分辨率的设备上显示。</li><li><mark class="hl-label blue">区域取样技术</mark> ：以面积比来确定亮度等级。</li><li>像素移相技术</li><li><mark class="hl-label blue">子像素加权方案</mark> ：按照某种分布来确定该区域各像素的亮度等级。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h1><p>基本的几何变换包括<mark class="hl-label pink">平移translate</mark> 、<mark class="hl-label blue">旋转rotate</mark> 和<mark class="hl-label green">缩放scale</mark> 。</p><p>我们通常使用<emp>齐次坐标</emp>来表示矩阵变换，这样表示出来的都是矩阵乘积的形式，更加简洁。</p><h2 id="二维几何变换"><a href="#二维几何变换" class="headerlink" title="二维几何变换"></a>二维几何变换</h2><p><img src="https://cloud.fullcomb.top/private/source/image/cg/14.png" alt></p><blockquote><p>这里的旋转是指<emp>绕z轴的旋转</emp>。虽然二维没有z轴这个说法，但在OpenGL中表示二维就是从一个坐标轴俯视过去的。<emp>绕任意直线的旋转</emp>将在后面详细讨论。</p></blockquote><h2 id="三维几何变换"><a href="#三维几何变换" class="headerlink" title="三维几何变换"></a>三维几何变换</h2><details class="folding-tag" cyan><summary> 三维的矩阵变换相对二维，绕坐标轴的旋转变换更加复杂，需要熟练记忆并掌握 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/cg/15.png" alt></p>              </div>            </details><h2 id="三维立体绕任意直线旋转"><a href="#三维立体绕任意直线旋转" class="headerlink" title="三维立体绕任意直线旋转"></a>三维立体绕任意直线旋转</h2><div class="note info flat"><p>我们的目标是将绕任意直线L的旋转转化为绕坐标轴的旋转。</p></div><div class="tabs" id="2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2-1">图示</button></li><li class="tab"><button type="button" data-href="#2-2">步骤</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><p><img src="https://cloud.fullcomb.top/private/source/image/cg/16.jpg" alt></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-2"><ol><li>将L平移至通过坐标原点。</li><li>将L绕x轴旋转至xoz平面</li><li>将L继续绕y轴旋转至与z轴重合</li><li>将L绕z轴旋转相应的角度</li><li>分别绕y轴和x轴反向旋转，再反向平移。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="note warning modern"><p>这个做法的难点就是<mark class="hl-label red">空间角α和β的求解</mark> 。我们采用<mark class="hl-label pink">向量</mark> 的方法。</p></div><blockquote><p>在计算α前，我们还要明白一点就是，<emp>u与u''的夹角等于u'与z轴的夹角</emp>(见上面的第三个坐标系)。</p></blockquote><p>然后我们通过向量点乘获得夹角的余弦，向量叉乘获得夹角的正弦。计算过程省去，下面直接给出结论。</p><div class="tabs" id="3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#3-1">α的计算</button></li><li class="tab"><button type="button" data-href="#3-2">β的计算</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="3-1"><p><img src="https://cloud.fullcomb.top/private/source/image/cg/17.jpg" alt></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3-2"><p><img src="https://cloud.fullcomb.top/private/source/image/cg/18.jpg" alt></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tip warning"><p>做题的时候我们直接代上面的矩阵即可。</p></div><hr><h1 id="窗口-视口变换"><a href="#窗口-视口变换" class="headerlink" title="窗口-视口变换"></a>窗口-视口变换</h1><mark class="hl-label pink">窗口</mark> 是<emp>世界坐标系中要显示的区域</emp>，通常在观察坐标系中定义。<mark class="hl-label blue">视口</mark> 是<emp>窗口映射到设备坐标系上的区域</emp>。<details class="folding-tag" cyan><summary> 图解窗口和视口 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/cg/19.jpg" alt></p><p>来源：</p><div class="tag link"><a class="link-card" title="计算机图形学——窗口到视口的变换" href="https://www.cnblogs.com/wkfvawl/p/11745248.html"><div class="left"><img src="https://cloud.fullcomb.top/private/source/image/cg/20.jpg"></div><div class="right"><p class="text">计算机图形学——窗口到视口的变换</p><p class="url">https://www.cnblogs.com/wkfvawl/p/11745248.html</p></div></a></div>              </div>            </details><p>变换的时候，<emp>要使视口内的一点和窗口保持相同的相对位置</emp>，需要满足下面的方程组：</p><div class="tabs" id="3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#3-1">方程组</button></li><li class="tab"><button type="button" data-href="#3-2">示意图</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="3-1"><p><img src="https://cloud.fullcomb.top/private/source/image/cg/21.jpg" alt></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3-2"><p><img src="https://cloud.fullcomb.top/private/source/image/cg/22.jpg" alt></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h1 id="直线裁剪"><a href="#直线裁剪" class="headerlink" title="直线裁剪"></a>直线裁剪</h1><div class="tip "><p>当我们从世界坐标系中截取窗口时，我们只需要窗口内的区域，窗口外的则舍弃以减小内存占用。这时就要对其进行裁剪。我们来研究最基础的直线裁剪。</p></div><h2 id="CS直线裁剪算法"><a href="#CS直线裁剪算法" class="headerlink" title="CS直线裁剪算法"></a>CS直线裁剪算法</h2><p>CS直线裁剪算法即Cohen-Sutherland直线裁剪算法的简称。</p><mark class="hl-label red">步骤：</mark> <div class="note red simple"><ol><li><p>按照<emp>左右下上</emp>的顺序对窗口进行<mark class="hl-label pink">区域编码</mark> </p><details class="folding-tag" red><summary> 区域编码如图 </summary>           <div class="content">           <p><img src="https://cloud.fullcomb.top/private/source/image/cg/23.jpg" alt></p>           </div>         </details></li><li><p>顶点编码</p><p><img src="https://cloud.fullcomb.top/private/source/image/cg/24.png" alt></p></li></ol></div><mark class="hl-label blue">说明：</mark> <details class="folding-tag" cyan><summary> 与老师的QA（打错字了好尴尬/捂脸） </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/cg/24.jpg" alt></p>              </div>            </details><h2 id="LB直线裁剪算法"><a href="#LB直线裁剪算法" class="headerlink" title="LB直线裁剪算法"></a>LB直线裁剪算法</h2><p>LB直线裁剪算法即“梁友栋-Barsky”直线裁剪算法。</p><mark class="hl-label orange">思想：</mark> <div class="note orange simple"><ol><li><p>利用直线的参数方程，已知直线的起始点，用参数u表示直线上的任意一个点：</p><p><img src="https://cloud.fullcomb.top/private/source/image/cg/25.png" alt></p></li><li><p>直线在区域的端点右六个候选点：</p><p><img src="https://cloud.fullcomb.top/private/source/image/cg/26.png" alt></p><p><mark class="hl-label pink">入点候选组</mark> <emp>1、2、3</emp>中选择u较大的那个点；<mark class="hl-label blue">出点候选组</mark> <emp>4、5、6</emp>中选择u较小的那个。</p></li></ol></div><mark class="hl-label blue">步骤：</mark> <div class="note blue simple"><p><img src="https://cloud.fullcomb.top/private/source/image/cg/27.JPEG" alt></p></div><div class="tip "><p><span class="p yellow">对比CS和LB直线裁剪算法：</span></p><p>LB算法减少了计算交点的次数，性能更高，而且更容易推广到三维。所以LB算法更优。</p></div><h2 id="其他直线裁剪算法"><a href="#其他直线裁剪算法" class="headerlink" title="其他直线裁剪算法"></a>其他直线裁剪算法</h2><p>//Todo，之前没有复习到。</p><hr><h1 id="三维观察坐标系"><a href="#三维观察坐标系" class="headerlink" title="三维观察坐标系"></a>三维观察坐标系</h1><details class="folding-tag" red open><summary> 问题一：如何建立是三维观察坐标系？ </summary>              <div class="content">              <ol><li>用观察坐标原点$P_0$和三维物体上的一参考点Pref确定观察上向量<script type="math/tex">N=P_0-Pref</script>。</li><li>确定观察坐标系Z轴$Z_{view}=N$（以观察向上向量作为观察坐标系Z轴）。</li><li>指定观察向上向量<script type="math/tex">V_{up}=(0,1,0)</script>，建立<script type="math/tex">Y_{view}</script>轴的正方向。</li><li><script type="math/tex">X_{view}=v_{up}\times Z_{view}</script>。</li><li><script type="math/tex">Y_{view}=Z_{view}\times V_{up}</script>。</li></ol><div class="note red flat"><p>以上为标准答案，考试需要记忆！</p></div>              </div>            </details><details class="folding-tag" orange open><summary> 问题二：如何求解三维观察WC-VC变换矩阵？ </summary>              <div class="content">              <ol><li>平移使得WC，VC坐标原点重合。</li><li>绕<script type="math/tex">X_{w}</script>轴旋转，使得<script type="math/tex">Z_v</script>轴旋转到XY平面。</li><li>绕<script type="math/tex">Y_v</script>轴旋转，使得<script type="math/tex">Z_v</script>与<script type="math/tex">Z_w</script>轴重合。</li><li>绕<script type="math/tex">Z_w</script>轴旋转，使得<script type="math/tex">X_w</script>与<script type="math/tex">X_v</script>重合，<script type="math/tex">Y_w</script>与<script type="math/tex">Y_v</script>重合。</li><li>复合变换矩阵即为<script type="math/tex">M=R_zR_yR_xT</script>。</li></ol><div class="note orange flat"><p>和三维立体绕任意直线旋转的变换过程相似。</p></div>              </div>            </details><hr><h1 id="投影变换"><a href="#投影变换" class="headerlink" title="投影变换"></a>投影变换</h1><h2 id="投影三要素"><a href="#投影三要素" class="headerlink" title="投影三要素"></a>投影三要素</h2><p>投影三要素包括：视点（投影中心）、投影平面、投影线。</p><details class="folding-tag" blue><summary> 投影三要素图示 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/cg/28.png" alt></p>              </div>            </details><h2 id="斜投影的计算"><a href="#斜投影的计算" class="headerlink" title="斜投影的计算"></a>斜投影的计算</h2><p>利用相似三角形：</p><p><img src="https://cloud.fullcomb.top/private/source/image/cg/29.jpg" alt></p><hr><h1 id="三维对象的表示"><a href="#三维对象的表示" class="headerlink" title="三维对象的表示"></a>三维对象的表示</h1><h2 id="表示方法"><a href="#表示方法" class="headerlink" title="表示方法"></a>表示方法</h2><ol><li><mark class="hl-label pink">边界表示：</mark> 使用一组曲面来描述三维对象，从而将其分为内外两部分。如：<emp>样条曲面、多边形曲面</emp>。</li><li><mark class="hl-label green">空间分区：</mark> 将包含物体的空间区域划分为一组较小的、非重叠的、邻接的实体，从而描述物体内部的性质。如八叉树的表示。</li><li><mark class="hl-label blue">多边形网格：</mark> 图形系统一般用多边形网格对物体进行建模，<mark class="hl-label blue">再用细分的方法使物体的表面更加平滑。</mark> </li></ol><h2 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h2><p><img src="https://cloud.fullcomb.top/private/source/image/cg/30.jpg" alt></p><mark class="hl-label blue">特性：</mark> <div class="note blue flat"><ol><li>多项式次数=控制点个数-1</li><li>贝塞尔曲线总是通过第一个和最后一个控制点</li><li>第一个和最后有个控制点重合会生成闭合的Bezier曲线</li><li>任何贝塞尔曲线总是落在控制点的凸壳内</li></ol></div><h2 id="四叉树与八叉树"><a href="#四叉树与八叉树" class="headerlink" title="四叉树与八叉树"></a>四叉树与八叉树</h2><p><img src="https://cloud.fullcomb.top/private/source/image/cg/31.png" alt></p><h2 id="分形"><a href="#分形" class="headerlink" title="分形"></a>分形</h2><p>分形就是重复使用指定的变换函数作用于空间区域中的所有点，使每点具有无限细节。<mark class="hl-label pink">分形的特点的是对象整体和局部之间具有自相似性</mark> 。</p><h3 id="分型的维数"><a href="#分型的维数" class="headerlink" title="分型的维数"></a>分型的维数</h3><p>用于描述分型对象细节的变化量，用D表示。<mark class="hl-label green">D越大，细碎性越高</mark> </p><p><mark class="hl-label blue">计算：</mark> $D=lnn/ln(1/s)$，其中n为再生数目，S为缩放因子，如：<br></p><p><img src="https://cloud.fullcomb.top/private/source/image/cg/32.png" alt></p><hr>]]></content>
      
      
      <categories>
          
          <category> 游戏与3D </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.4宏与内联函数</title>
      <link href="/post/704c85b6.html"/>
      <url>/post/704c85b6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><div class="tip "><p>本节涉及到预处理和编译的相关知识，我们先来回顾一下C/C++程序执行的过程(以g++编译器为例)。</p></div><ol><li><p><mark class="hl-label pink">预处理</mark> 的指令为<code>cpp main.cpp &gt; main.i</code>。</p><p>它主要进行的是<emp>头文件的展开与宏的替换</emp>。预处理后得到的文件为main.i。</p></li><li><p><mark class="hl-label blue">编译</mark> 的指令为<code>g++ -S main.i</code>。</p><p>编译后得到的文件为main.s。</p></li><li><p><mark class="hl-label green">汇编</mark> 的指令为<code>as -o main.o main.s</code>。</p><p>汇编得到的文件为main.o。.o文件时我们经常见到的中间文件(直接用IDE应该很少见到)。</p></li><li><p><mark class="hl-label red">链接</mark> 的指令为<code>g++ -o main main.o</code>。</p><p>Windows平台下生成的文件就是我们经常看到的.exe (可执行文件)。</p></li></ol><div class="note blue flat"><p><span class="p center small">如果读者还有疑惑或不熟悉，请移步这篇教程：</span></p><div class="tag link"><a class="link-card" title="C/C++的执行过程" href="https://www.fullcomb.top/post/fb935c76.html"><div class="left"><img src="https://cloud.fullcomb.top/private/source/image/compilation/cover.png"></div><div class="right"><p class="text">C/C++的执行过程</p><p class="url">https://www.fullcomb.top/post/fb935c76.html</p></div></a></div></div><h1 id="宏-Macro"><a href="#宏-Macro" class="headerlink" title="宏(Macro)"></a>宏(Macro)</h1><h2 id="宏的使用"><a href="#宏的使用" class="headerlink" title="宏的使用"></a>宏的使用</h2><ol><li><emp>定义一个符号常量</emp>。这是我们经常使用的宏定义的形式，如<code>#define PI 3.14</code> 。它的好处是便于代码的维护。</li><li><emp>宏函数替换常用的语句</emp>。如<code>#define MAX(x,y) ((x)&gt;(y)?(x):(y))</code>实现求两个数的最大值 。这样我们在代码中使用<code>MAX(1,2)</code>的时候，就会在预处理阶段被预处理器自动替换成<code>((1)&gt;(2)?(1):(2))</code>，最终的结果为2，没有问题。它的作用是减少代码量，<psw>偷懒伴侣</psw>。</li></ol><div class="tip warning"><p>使用宏函数一定要注意打括号！少了括号就可能会出问题！</p></div><blockquote><p><mark class="hl-label pink">#define</mark> 我们常用的预处理指令。除此之外，常见的预处理指令还有<mark class="hl-label blue">#ifdef</mark> 、<mark class="hl-label blue">#ifndef</mark> 、<mark class="hl-label blue">#endif</mark> 等。它们在工程中用得很多，主要作用是防止头文件的重复包含以及函数的反复声明。</p></blockquote><h2 id="宏的实例"><a href="#宏的实例" class="headerlink" title="宏的实例"></a>宏的实例</h2><p>既然都讲宏了，那就顺便再讲讲<mark class="hl-label green">注释</mark> 、<mark class="hl-label green">#ifdef</mark> 和<mark class="hl-label green">#endif</mark> 。<psw>夹带私货不过分吧~</psw></p><p>我们在命令行输入<code>cpp test.c &gt; test.i</code>，得到 .i文件，然后将.c文件和.i文件进行对比：</p><p><img src="https://satoing.gitee.io/img/compilation/1.png" alt></p><details class="folding-tag" open cyan><summary> 结论 </summary>              <div class="content">              <p>预处理阶段，进行下面的操作：</p><ol><li>宏的替换。<code>MAX(x,y)</code>在.i文件中被替换掉了。</li><li>注释的抹去。.i文件中没有注释了。</li><li>代码块的消除。<code>#ifdef MIN(x,y)</code>和<code>#endif</code>之间的代码都被忽略了。</li></ol>              </div>            </details><div class="tip "><p>为什么预处理的指令是cpp开头而不是g++呢？因为预处理准确来说是由编译器套件中的预处理器来进行的。并不是由编译器完成。有时候说编译器对cpp文件进行预处理实际上是不准确的说法。</p></div><h2 id="宏的优点"><a href="#宏的优点" class="headerlink" title="宏的优点"></a>宏的优点</h2><ul><li>使用宏定义符号常量可以方便我们的理解和对代码进行维护；</li><li>使用宏函数可以避免执行一般的函数时所产生的开销，加快程序运行的速度；</li></ul><h2 id="宏的缺陷"><a href="#宏的缺陷" class="headerlink" title="宏的缺陷"></a>宏的缺陷</h2><p>对于宏函数，它的缺点有：</p><ul><li>不能调试，因为在预处理阶段进行替换。</li><li>没有类型检查，不安全。</li><li>写法复杂，容易出错。(下面通过例子讲解)</li></ul><hr><ul><li>先观察下面这个程序：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUL(a,b) a*b</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    std::cout&lt;&lt;<span class="hljs-built_in">MUL</span>(<span class="hljs-number">1</span>+<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><details class="folding-tag" red><summary> 结果与改进 </summary>              <div class="content">              <p>最终输出7，与预想结果9不符。因为宏替换后变成了<code>1+2*3</code>，改变了运算顺序。</p><p>改进：在宏定义处加上括号，<code>#define MUL(a,b) (a)*(b)</code>。</p>              </div>            </details><ul><li>再来看看这个程序：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> abs(a) ((a&gt;=0)?a:-a)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>;<br>    std::cout&lt;&lt;<span class="hljs-built_in">abs</span>(x)&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>&lt;&lt;<span class="hljs-built_in">abs</span>(++x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><details class="folding-tag" red><summary> 结果 </summary>              <div class="content">              <p>它输出的结果为<mark>1和3</mark>！与目标输出1和2不符。因为宏替换后变成了<code>((++x&gt;=0)?++x:-++x)</code>，自增运算进行了两次。</p><p>而且，<mark class="hl-label pink">无法通过单纯地添加括号来避免！</mark> </p>              </div>            </details><div class="tip "><p>总结：宏函数可通过添加括号避免大多数问题，但是有些情况却不能避免，是使用宏的缺陷！</p></div><p>那么，有没有既高效又能避免上述问题的方案呢？C++告诉我们要使用<emp>内联函数</emp>。</p><h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><h2 id="内联函数的定义"><a href="#内联函数的定义" class="headerlink" title="内联函数的定义"></a>内联函数的定义</h2><p>使用<mark class="hl-label pink">inline</mark> 修饰的函数叫做内联函数。</p><p>不同于宏在预处理阶段进行替换，<mark class="hl-label blue">编译中期</mark> 时编译器会在调用内联函数的地方将其展开。</p><p>所以内联函数<emp>没有函数压栈的开销</emp>，能提高程序运行的效率。同时相比于宏函数，内联函数<emp>可以调试</emp>，而且<emp>编译器能够对其进行优化</emp>，不会出现上面输出和预想不同的情形。</p><h2 id="内联函数的使用"><a href="#内联函数的使用" class="headerlink" title="内联函数的使用"></a>内联函数的使用</h2><div class="tip "><p>一般我们只将<span class="p yellow">频繁调用，且函数体较小</span>的函数定义为内联函数，下面对此进行说明：</p></div><ol><li>如果函数的调用次数少，函数压栈所产生的开销对于程序而言是可以忽略的。这时使用内联函数意义不大。</li><li>如果函数体较大，编译中期就会将整个函数展开。且如果调用次数很多，那么会使得整个代码过长，编译器编译代码的时间还可能会增加。</li><li>如果函数频繁调用，且函数体较小，那么这时使用内联函数就很好。</li></ol><p>我们使用inline函数来解决之前使用宏函数未解决问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">abs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (a&gt;=<span class="hljs-number">0</span>)?a:-a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>;<br>    std::cout&lt;&lt;<span class="hljs-built_in">abs</span>(x)&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>&lt;&lt;<span class="hljs-built_in">abs</span>(++x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这时正确地输出1和2。</p></blockquote><h2 id="使用内联函数的说明"><a href="#使用内联函数的说明" class="headerlink" title="使用内联函数的说明"></a>使用内联函数的说明</h2><ol><li><mark class="hl-label pink">内联函数内部不能有循环语句</mark> ( 如<code>for</code> , <code>while</code> , <code>switch</code> )。一旦出现，即使函数前面有inline，编译器也会把它当作普通函数来处理。即<mark class="hl-label blue">编译器默认内联函数不能太复杂</mark> 。</li><li>使用内联函数实际上是一种<mark class="hl-label green">以空间换时间</mark> 的做法。我们知道，在程序运行时，代码会以二进制指令的形式储存在代码区中。而使用inline将函数展开后，会使代码增长，<emp>代码区储存的指令增加</emp>，占用的空间增加。</li></ol><h2 id="内联函数总结"><a href="#内联函数总结" class="headerlink" title="内联函数总结"></a>内联函数总结</h2><div class="note pink modern"><ol><li>我们使用内联函数来代替宏函数，但是宏还有其独特的用法，比如定义符号常量。</li><li>要注意使用inline函数的情景。一般我们只将频繁调用，且函数体小的函数定义为内联函数。而且内联函数内部不能有循环语句。</li></ol></div>]]></content>
      
      
      <categories>
          
          <category> 大二上 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.3引用、指针与nullptr</title>
      <link href="/post/b1db5868.html"/>
      <url>/post/b1db5868.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在我们学习C语言的<mark class="hl-label blue">指针</mark> 的时候大多数教材都会讲到“<mark class="hl-label pink">交换a和b两个数</mark> ”的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> temp=a;<br>    a=b;<br>    b=temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a=<span class="hljs-number">1</span>,b=<span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">swap</span>(a,b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d&quot;</span>,a,b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于<emp>实参的保护机制</emp>，这样的交换是不成功的。要达到交换的目的，C语言告诉我们应该使用指针：</p><hr><div class="note info modern"><p><emp>实参的保护机制</emp>是C语言的内容，但是为了保证这个<mark class="hl-label blue">C++系列</mark> 知识点的完备性，我尽可能地穿插讲解一些C语言的知识点。</p></div><details class="folding-tag" blue><summary> 知识点补充：实参的保护机制 </summary>              <div class="content">              <p>TODO，涉及到汇编内容比较多，我也不怎么熟悉还得捋捋，但是又得尽可能讲简单点……还没想好怎么写比较好……看来都还给老师了……</p>              </div>            </details><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a,<span class="hljs-keyword">int</span>* b)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> temp=*a;<br>    *a=*b;<br>    *b=temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a=<span class="hljs-number">1</span>,b=<span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">swap</span>(&amp;a,&amp;b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d&quot;</span>,a,b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>而C++ <span class="p blue">为了避免指针的滥用</span>，引入了比指针更安全的<emp>引用类型</emp>，来代替指针。</p><div class="tip "><p>本节我们将细说引用。先来回顾一下指针的基础知识。</p></div><hr><h1 id="指针-pointer"><a href="#指针-pointer" class="headerlink" title="指针(pointer)"></a>指针(pointer)</h1><h2 id="指针的含义"><a href="#指针的含义" class="headerlink" title="指针的含义"></a>指针的含义</h2><p>指针的<emp>语法含义</emp>就是 <mark class="hl-label pink">指向变量的地址</mark>  。</p><p>指针的<wavy>本质是一个变量，用于存储其他变量的地址</wavy>。对于32位机器，指针占 4个字节；对于64位机器，指针占8个字节</p><div class="note warning modern"><p>指针占多少字节还和编译器有关：如果你的电脑是64位的，但是使用的编译器是32位的，指针也只占4个字节。</p></div><h2 id="指针的分类"><a href="#指针的分类" class="headerlink" title="指针的分类"></a>指针的分类</h2><p>按照使用的权限，指针可以分为(以整型指针为例)：</p><ol><li><p><code>const int* a</code>或<code>int const* a</code>：指向常量的指针，即<emp>指针指向的内存是只读的</emp>。</p></li><li><p><code>int* const a</code>：指针常量，即<emp>指针只能指向这个地址，不能更改</emp>。</p></li><li><p><code>const int* const a</code>：指向常量的指针常量，是上面两种指针的综合。</p></li></ol><div class="note info flat"><p>有的时候可能会把1和2搞混淆。其实要记住它们也很简单，我们只需要倒过来读就行了。</p><p>我们把上面的<code>a</code>读作指针，<code>*</code>读作指向。比如，第一个就可以读作<mark class="hl-label blue">指针指向整型常量</mark> ，即指向常量的指针；第二个读作<psw>指针常量指向整型</psw>，即常指针。这样就不怕混淆了。</p></div><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>如下面的程序，通过打印<mark class="hl-label pink">&foo</mark> ，我们可以发现函数也在内存中也占有地址。那么我们就可以将指针指向这个函数，即<mark class="hl-label blue">函数指针</mark> 。</p><p><img src="https://cloud.fullcomb.top/private/source/image/cpp/1/7.jpg" alt></p><div class="note info green modern"><p>对于游戏开发者，函数指针应该是一个很重要的内容了。我在学习OpenGL时，就经常被函数指针绕晕。这真是<psw>无法拒绝，建议多来点/doge</psw>。</p></div><h3 id="定义函数指针"><a href="#定义函数指针" class="headerlink" title="定义函数指针"></a>定义函数指针</h3><p>我们定义一般的指针时，需要指定这个指针的类型。函数指针也同理。</p><p>对于一个函数，我们关注的是它的<emp>形参类型和返回类型</emp>。所以，函数指针的定义方式为：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<mark class="hl-label pink">返回类型(*ptr)(参数列表)</mark> </p><div class="note blue flat"><p><span class="p center small">例如：</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//返回类型为空，参数列表也为空</span><br><span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*ptr1)();<br><span class="hljs-comment">//返回类型为整型，参数列表也为两个整型</span><br><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*ptr2)(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)<br></code></pre></td></tr></table></figure></div><h3 id="函数指针赋值"><a href="#函数指针赋值" class="headerlink" title="函数指针赋值"></a>函数指针赋值</h3><p>定义了一个函数指针后，我们可以将相同类型函数的地址赋给它。</p><p>如下图，函数名和函数名取地址都可以代表这个函数的地址。(因为编译器会隐式地将<code>foo</code>转化为<code>&amp;foo</code>)</p><p><img src="https://cloud.fullcomb.top/private/source/image/cpp/1/8.jpg" alt></p><p>所以下面两种函数指针的赋值方式都是正确的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">p=foo;<br>p=&amp;foo;<br></code></pre></td></tr></table></figure><h3 id="使用函数指针"><a href="#使用函数指针" class="headerlink" title="使用函数指针"></a>使用函数指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">(*p)();<span class="hljs-comment">//推荐这种写法</span><br><span class="hljs-built_in">p</span>();<span class="hljs-comment">//低版本编译器可能报错</span><br></code></pre></td></tr></table></figure><h3 id="定义函数指针类型"><a href="#定义函数指针类型" class="headerlink" title="定义函数指针类型"></a>定义函数指针类型</h3><div class="note blue modern"><p>之前看ACLLib的头文件时，看到了这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*KeyboardEventCallback)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> event)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerKeyboardEvent</span><span class="hljs-params">(KeyboardEventCallback callback)</span></span>;<br></code></pre></td></tr></table></figure><p>第一句<emp>声明了一个函数指针的类型</emp>，第二句声明了<emp>一个接受函数指针作为参数的回调函数</emp>。</p></div><p>我们使用typedef自定义一个类型时，是这样的写法：<code>typedef int bit_32</code>。如果单看后面的<code>int bit_32</code>，则是相当于定义了一个整型变量。</p><p>同理，对于<mark class="hl-label blue">typedef&nbsp;void(*KeyboardEventCallback)(int&nbsp;key,int&nbsp;event);</mark> ，如果我们单看后面，<mark class="hl-label pink">void(*KeyboardEventCallback)(int&nbsp;key,int&nbsp;event);</mark> ，则是定义了一个函数指针。那么类比一下，<mark class="hl-label green">typedef&nbsp;void(*KeyboardEventCallback)(int&nbsp;key,int&nbsp;event);</mark> 定义了一个函数指针类型也好理解了。</p><div class="note warning modern"><p>对于以函数指针作为形参的函数，我们必须要像这样先定义一个函数指针类型，然后像上面代码第二句一样声明这个函数！</p></div><h2 id="空指针nullptr"><a href="#空指针nullptr" class="headerlink" title="空指针nullptr"></a>空指针nullptr</h2><div class="note info modern"><p>C语言种我们定义一个空指针，是这样写的：<code>int *ptr=NULL;</code></p></div><p>其中<code>NULL</code>是C语言中定义一个<emp>宏</emp>(Macro)。NULL的宏定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NULL</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __cplusplus</span><br>      <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NULL 0</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>      <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NULL (void *)0</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// __cplusplus</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// NULL</span></span><br></code></pre></td></tr></table></figure><details class="folding-tag" red open><summary> 从这段定义可以看出 </summary>              <div class="content">              <ol><li><p>在C语言中，<code>NULL</code>具有二义性，它既指字面常量0，又指空指针。</p></li><li><p>C++中，<code>NULL</code>只指代字面常量0，我们应该用<code>nullptr</code>来代指空指针。</p></li></ol>              </div>            </details><div class="note warning modern"><p>切记切记，C++的空指针就必须用nullptr！哪怕是新建cpp文件写C代码也要用nullptr。</p><p>虽然你的电脑可能认识NULL，但是其他电脑就说不定了，特别是学校的老电脑……</p></div><hr><h1 id="引用-reference"><a href="#引用-reference" class="headerlink" title="引用(reference)"></a>引用(reference)</h1><h2 id="引用的概念"><a href="#引用的概念" class="headerlink" title="引用的概念"></a>引用的概念</h2><p>引用的<emp>语法含义</emp>就是<mark class="hl-label pink">给一个变量取别名</mark> 。</p><div class="note warning modern"><p><span class="p center small">注意</span></p><ol><li><p>引用在定义时就一定要赋值，且之后不能再改变。(下面我们会知道原因)</p></li><li><p>通过本名和别名都可以访问到这变量所在的内存空间，如下图：</p><p> <img src="https://cloud.fullcomb.top/private/source/image/cpp/1/5.JPG" alt></p><details class="folding-tag" open red><summary> 可以看出 </summary>           <div class="content">           <p><code>c</code>是 <code>a</code>的引用，相当于<code>a</code>的别名。<code>a</code> 和<code>c</code>都指向同一片内存空间 <code>0x7fffffffe4bc</code>。</p>           </div>         </details></li></ol></div><div class="note info modern"><p>也许读者平时在使用VS进行调试。其实gdb作为GNU套件中的一员，也是一个很好用(?)的调试工具。<psw>其实主要是学linux要用</psw>。如果有时间的话，我以后会写一个使用gdb进行调试的系列。</p></div><h2 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h2><p>既然引用就相当于一个变量的别名，那么它在内存中是怎么存在的呢？还是说就是一个宏？</p><emp>引用的本质是常指针！</emp><div class="note green flat"><ol><li>我们定义一个引用，如<code>int &amp;c=a</code>,就等价于<code>int* const c=a</code>。</li><li>我们使用一个引用，如<code>c=200</code>，就会被转化为<code>(*c)=200</code>。</li></ol></div><div class="tip "><p><mark class="hl-label pink">所以:</mark> </p><ol><li>引用不能改变且只能在定义时赋值</li><li>引用和指针一样，也会占空间，且为地址的大小。</li></ol></div><p>但是，我们可以通过和指针的对比来印证这一点。对比下面两图：</p><ul><li><p>使用常指针，打印出变量的地址：<img src="https://cloud.fullcomb.top/private/source/image/cpp/1/7.JPG" alt></p></li><li><p>使用引用，打印出a、b变量的地址：<img src="https://cloud.fullcomb.top/private/source/image/cpp/1/6.JPG" alt></p></li></ul><details class="folding-tag" red><summary> 结论 </summary>              <div class="content">              <p>两个程序的区别就是前者用的是指针，后者用的是引用。</p><p>通过打印发现，两个程序的<code>a</code>和<code>c</code>的地址都是一样的。<wavy>前者有指针占位（8字节）；可以推断后者是引用占位，也占了8字节</wavy>。这一点足以说明引用的本质就是指针。</p>              </div>            </details><div class="tip cogs"><p><span class="nota" data-nota="不能，因为&b会转化为&(*b)，最后打印出的是a的地址">图二可以直接打印出b对应的指针的地址吗？</span></p></div><h2 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h2><p>前面我们知道了引用是一个常指针，因为它不能像一般的指针一样随便指，所以它比一般的指针更<emp>安全</emp>。而<mark class="hl-label pink">常引用</mark> 又比一般的引用更安全。下面我们来了解常引用。</p><div class="tip "><p>这里的安全是对于程序而言的，越安全的程序其中的数据就越不容易被“某些用户”篡改。而对程序员来说就是更大的负担……但维护程序的安全性也是程序员的职责。</p></div><h3 id="常引用指向常量"><a href="#常引用指向常量" class="headerlink" title="常引用指向常量"></a>常引用指向常量</h3><div class="tip warning"><p>我们要给常量取别名，就必须用常引用！</p></div><p>比如，我们必须用<code>const int &amp; a=1;</code>使a来代指1， 而不能用 <code>int &amp; a=1;</code> 如果用了，编译器会报错：<mark class="hl-label pink">cannot bind non-const lvalue reference of type ‘int&’ to an rvalue of type 'int'</mark> 。因为 <code>1</code> 是不可修改的右值。</p><p>特别注意，<mark class="hl-label blue">const</mark> 修饰的变量也必须用常引用！</p><hr><details class="folding-tag" blue><summary> 知识点补充：左值与右值 </summary>              <div class="content">              <p>这是C语言中<emp>值类别(value category)</emp>的知识点。</p><ul><li>简单点来说，左值就是可以修改的量，即变量；右值就是不能修改的变量，即常量。</li><li>严格点来说，lvalue即locate value，可以进行取地址操作；而rvalue则不能取地址。</li></ul><div class="tag link"><a class="link-card" title="OI Wiki" href="https://oi-wiki.org/lang/value-category/"><div class="left"><img src="https://oi-wiki.org/favicon.ico"></div><div class="right"><p class="text">OI Wiki</p><p class="url">https://oi-wiki.org/lang/value-category/</p></div></a></div>              </div>            </details><hr><h3 id="常引用指向变量"><a href="#常引用指向变量" class="headerlink" title="常引用指向变量"></a>常引用指向变量</h3><p>对于一个变量，如<code>int a</code>，可以有下面两种引用方式：</p><ul><li><mark class="hl-label pink">不使用常引用</mark> <code>int &amp; b=a</code>：这时通过<code>a</code>和<code>b</code>都可以修改对用内存空间的值。</li><li><mark class="hl-label green">使用常引用</mark> <code>const int &amp; b=a</code>：这时只能通过<code>a</code>修改内存空间的值，而<emp>用b的话编译器报错</emp>。</li></ul><div class="note blue modern"><p>上面两点可以理解为引用的<emp>访问权限只能降级，不能升级</emp>。即可以将读写改为只读，而不能将只读改为读写。</p></div><h2 id="开始使用引用吧"><a href="#开始使用引用吧" class="headerlink" title="开始使用引用吧"></a>开始使用引用吧</h2><blockquote><p>引用可以在变量原本的作用域里面使用，但是意义不大。</p><p>引用更广泛的使用场景是<mark class="hl-label blue">传参</mark> ！</p></blockquote><h3 id="作形参"><a href="#作形参" class="headerlink" title="作形参"></a>作形参</h3><p>回到引言里面交换的例子，我们用引用来实现两个数的交换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; a,<span class="hljs-keyword">int</span>&amp; b)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> temp=a;<br>    a=b;<br>    b=temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a=<span class="hljs-number">1</span>,b=<span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">swap</span>(a,b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d&quot;</span>,a,b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><div class="tip "><p>以前学习到引用传参的时候，如果按照引用的语法含义“一个变量的别名” 去理解，那么就会疑惑为什么传参的时候别名可以和本名相同。其实从引用的本质“常指针” 的角度来想问题就迎刃而解了。</p></div><h3 id="作返回值"><a href="#作返回值" class="headerlink" title="作返回值"></a>作返回值</h3><div class="note info flat"><p>这种用法局限性很大，平时一般不会用到。但看到的时候得明白。</p></div><p>有的时候，我们必须要用返回值返回参数。我们一般的做法是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a=<span class="hljs-number">1</span>,b=<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> c=<span class="hljs-built_in">add</span>(a,b);<br>    std::cout&lt;&lt;c;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>用这种方法进行了两次拷贝：第一次是 <code>return</code> 的时候，把 <code>a+b</code> 的值拷贝给临时空间；第二次是在主调函数里面把临时空间的值拷贝给 <code>c</code> 。</p><p>而使用引用，只需要进行一次拷贝： <code>return</code> 的时候，把 <code>a+b</code> 的值拷贝给临时空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a=<span class="hljs-number">1</span>,b=<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp; c=<span class="hljs-built_in">add</span>(a,b);<br>    std::cout&lt;&lt;c;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，我们要注意它的<mark class="hl-label blue">生命周期</mark> 。在下一次使用(即用到了存储这个返回值的寄存器)的时候，这片临时空间将归还给系统。</p>]]></content>
      
      
      <categories>
          
          <category> 大二上 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【恋练有词】U1D1</title>
      <link href="/post/5c28d1d9.html"/>
      <url>/post/5c28d1d9.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><details class="folding-tag" green open><summary> 写在前面 </summary>              <div class="content">              <p>我一直认为背单词是件痛苦的事，也很少去背过单词，所以现在词汇量极为贫乏。正巧我昨年在图书馆得到了一位刚考完研的学长的真传:《 <mark class="hl-label green">恋练有词</mark> 》，那么用好这本绿宝书，现在开始也不晚。</p>              </div>            </details><div class="tip success"><p><span class="p center logo large">第一遍</span><span class="p center small">先按照辞书背一遍，并记下笔记</span></p></div><h2 id="work"><a href="#work" class="headerlink" title="work"></a>work</h2><details class="folding-tag" green><summary> 单词意思 </summary>              <div class="content">              <ol><li><mark class="hl-label green">名词</mark> ：职业；工作；产品；著作；</li><li><mark class="hl-label green">动词</mark> ：工作；有效、起作用；</li></ol>              </div>            </details><details class="folding-tag" green><summary> 短语和例句 </summary>              <div class="content">              <ol><li>work placement 实习工作</li><li>work skills 工作技能</li><li>work against 竭力反对</li><li>work on 致力于</li><li>work out 计算出，解决</li></ol>              </div>            </details><details class="folding-tag" green><summary> 派生词 </summary>              <div class="content">              <p><mark class="hl-label green">workout</mark>  n.锻炼</p><p>It turns out that the brain needs exercise <span class="nota" data-nota="much 是副词，很大程度上">in much the same way</span> our muscles do, and the right mental <span class="nota" data-nota="可数名词">workouts</span> can significantly improve our basic congitive funtions.</p><p><mark class="hl-label green">workplace</mark>  n.工作场所</p><p><mark class="hl-label green">workaholic</mark>  n.工作狂</p><p><mark class="hl-label green">workstation</mark>  n.工作台</p><p>Claire C. Gordon, senior anthropologist at the Army Rearch Center in Natick, Mass., ensures that 90 percent of the uniforms and workstations fit recruits without <span class="nota" data-nota="改变，改动">alteration</span>.</p><p><mark class="hl-label green">patchwork</mark>  n.拼凑物，混杂物</p>              </div>            </details><details class="folding-tag" green><summary> 相关词 </summary>              <div class="content">              <p><mark class="hl-label green">career</mark>  n.职业；生涯；经历</p><p><mark class="hl-label green">labour</mark>  n.劳动；<mark>劳动力</mark>；努力  ||  v.劳动、工作</p><p>labour cost、child labour</p>              </div>            </details><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><details class="folding-tag" green><summary> 单词意思 </summary>              <div class="content">              <ol><li><mark class="hl-label green">名词</mark> ：州；国家；政府；状态、情况</li><li><mark class="hl-label green">动词</mark> ：声明；规定</li><li><mark class="hl-label green">形容词</mark> ：国有的</li></ol>              </div>            </details><details class="folding-tag" green><summary> 短语和例句 </summary>              <div class="content">              <ol><li>head of states 国家元首</li><li>a new <span class="nota" data-nota="（美国）国务院">State Department Buliding</span> 一座新的美国国务院大楼</li><li>federal,state and local government 联邦、州和地方政府</li><li>a natural state  一种自然状态</li></ol><hr><ol><li>The <span class="nota" data-nota="法案，此外常用的还有账单">bills</span> are similar to a measure recently adopted in California, which last year become the first state to require <span class="nota" data-nota="性别的名词">gender</span> quotas for private companies.</li><li>In many rich countries average wages in the <span class="nota" data-nota="国有部门">state sector</span> are higher than in the private one.</li></ol>              </div>            </details><details class="folding-tag" green><summary> 派生词 </summary>              <div class="content">              <p><mark class="hl-label green">stated</mark>  adj.规定的；声明的</p><p><mark class="hl-label green">statement</mark>  n.声明；规定</p><p><mark class="hl-label green">overstate</mark>  v.过分夸大</p>              </div>            </details><details class="folding-tag" green><summary> 相关词 </summary>              <div class="content">              <p><mark class="hl-label green">status</mark>  n.身份；地位；情况、状况；重要性</p><ol><li>legal status 法律地位</li><li>immigration status 移民身份</li><li><mark>financial</mark> status 财务状况</li><li>Other scientists perform the <span class="nota" data-nota="专门的">specialised</span> work of <span class="nota" data-nota="同行">peer</span> <span class="nota" data-nota="评审">review</span> also for free, bacause it’s a central element in acquisition of status and the production of scientific knowledge.</li></ol><p><mark class="hl-label green">statute</mark>  n.法令、法规</p><p>The White House argued that Arizona’s laws conflicted with its enforcement priorities, even if state laws complied with federal statutes <span class="nota" data-nota="很形象的说法，字字遵守">to the letter</span>. </p><p><mark class="hl-label green">estate</mark>  n.地产；庄园；住宅；遗产</p><p>real estate 不动产-&gt;房地产</p><p><mark class="hl-label green">statistic</mark>  n.统计学</p><p><mark class="hl-label green">statistical</mark>  adj.统计的；统计学的</p><p>Most journals are weak in <span class="nota" data-nota="统计数据审查">statistical review</span>, and this damage the quality of what they publish.</p><p><mark class="hl-label green">stationary</mark>  adj.静止不动的；固定的</p>              </div>            </details><h2 id="change"><a href="#change" class="headerlink" title="change"></a>change</h2><details class="folding-tag" green><summary> 单词意思 </summary>              <div class="content">              <ol><li><mark class="hl-label green">名词</mark> ：变化；零钱</li><li><mark class="hl-label green">动词</mark> ：改变；更换</li></ol>              </div>            </details><details class="folding-tag" green><summary> 短语和例句 </summary>              <div class="content">              <ol><li>climate change</li><li>change one’s attitude towards</li></ol>              </div>            </details><details class="folding-tag" green><summary> 相关词 </summary>              <div class="content">              <p><mark class="hl-label green">exchange</mark>  n.交换；交易所；交流 || v.交流；交换</p><p>cultural exchange 文化交流</p><p>Labour is provided free in exchange for the hope of status, while huge profits are made by a few big <span class="nota" data-nota="公司">firms</span> who run the market places.</p>              </div>            </details><h2 id="social"><a href="#social" class="headerlink" title="social"></a>social</h2><details class="folding-tag" green><summary> 单词意思 </summary>              <div class="content">              <p><mark class="hl-label green">形容词</mark> ：社会的；社交的；好交际的</p>              </div>            </details><details class="folding-tag" green><summary> 短语和例句 </summary>              <div class="content">              <p>social contexts 社会背景</p><p>social media 社交媒体</p>              </div>            </details><details class="folding-tag" green><summary> 派生词 </summary>              <div class="content">              <p><mark class="hl-label green">asocial</mark>  adj.缺乏社交性的</p><p>Meanwhile, the asocial robot simply <span class="nota" data-nota="前后左右移动">moved forwards and backwords and side to side</span>.</p><p><mark class="hl-label green">sociable</mark>  adj.好交际的、合群的</p><p><mark class="hl-label green">society</mark>  n.社会；社团、协会；上流社会</p><p>the American Society of News Edition 美国新闻编辑协会</p><p><mark class="hl-label green">sociologist</mark>  n.社会学家</p>              </div>            </details><h2 id="public"><a href="#public" class="headerlink" title="public"></a>public</h2><details class="folding-tag" green><summary> 单词意思 </summary>              <div class="content">              <ol><li><mark class="hl-label green">形容词</mark>  公共的；公开的；政府的</li><li><mark class="hl-label green">名词</mark>  公众、民众；<mark>志趣相投或做一件事的群体</mark></li></ol>              </div>            </details><details class="folding-tag" green><summary> 短语和例句 </summary>              <div class="content">              <ol><li><p>in pubilc <mark>situations</mark> </p></li><li><p>public resources 公共资源</p></li><li>public awareness of <span class="nota" data-nota="(对自然环境的)保护">conservation</span> 公众的环保意识</li><li>public health problem</li><li><mark>public officials</mark> 公务员；政府工作人员</li><li>travelling public 旅客</li></ol>              </div>            </details><details class="folding-tag" green><summary> 派生词 </summary>              <div class="content">              <p><mark class="hl-label green">publicly</mark>  adv.公开地；当众地</p><p><mark class="hl-label green">publicize</mark>  v.引起公众的注意-&gt;宣传</p><p><mark class="hl-label green">publication</mark>  n.出版、发行；发表；出版物</p><ol><li>publication process</li><li>That’s the reason why we <span class="nota" data-nota="(首次)上市、发行，此外还有发射的意思">launched</span> <em>Arc</em>, a new publication dedicated to the near future.</li><li>Depending on the comment received, the editor would accept the paper for publication or decline it.%}</li></ol>              </div>            </details><details class="folding-tag" green><summary> 相关词 </summary>              <div class="content">              <p><mark class="hl-label green">republican</mark>  n.共产主义者 || adj.共和国的；共和党的</p><p><mark>Republican Party</mark>共和党</p><p>Republican governor 共和党州长</p>              </div>            </details><h2 id="human"><a href="#human" class="headerlink" title="human"></a>human</h2><details class="folding-tag" green><summary> 单词意思 </summary>              <div class="content">              <p><mark class="hl-label green">名词</mark> ：人</p><p><mark class="hl-label green">形容词</mark> ：人类的 </p>              </div>            </details><details class="folding-tag" green><summary> 短语和例句 </summary>              <div class="content">              <ol><li>human beings 人类</li><li>human nature 人性</li></ol>              </div>            </details><details class="folding-tag" green><summary> 派生词 </summary>              <div class="content">              <p><mark class="hl-label green">nonhuman</mark>  adj.非人类的</p><p><mark class="hl-label green">humanity</mark>  n.<mark>人类；人性；人道；人文学科</mark></p><p>Only when humanity began to get its food in a more productive way was there time for other things.</p><p><mark class="hl-label green">humankind</mark>  n.人类</p><p><mark class="hl-label green">humane</mark>  adj.人道的</p><p><mark class="hl-label green">humanist</mark>  n.人道主义者</p>              </div>            </details><details class="folding-tag" green><summary> 相关词 </summary>              <div class="content">              <p><mark class="hl-label green">anthropology</mark>  n.人类学</p><p><mark class="hl-label green">anthropologist</mark>  n.人类学家  </p>              </div>            </details><h2 id="take"><a href="#take" class="headerlink" title="take"></a>take</h2><details class="folding-tag" green><summary> 单词意思 </summary>              <div class="content">              <p><mark class="hl-label green">动词</mark> ：携带；拿、取；花费；学习、接受 </p>              </div>            </details><details class="folding-tag" green><summary> 短语和例句 </summary>              <div class="content">              <p>But the regular time it takes to get a <span class="nota" data-nota="人文学科的博士学位">doctor degree in the humanities</span> is nine year.</p>              </div>            </details><details class="folding-tag" green><summary> 相关词 </summary>              <div class="content">              <p><mark class="hl-label green">mistake</mark>  n.错误 || v.误解</p><p>factual mistakes 事实性错误</p>              </div>            </details><h2 id="government"><a href="#government" class="headerlink" title="government"></a>government</h2><details class="folding-tag" green><summary> 单词意思 </summary>              <div class="content">              <p><mark class="hl-label green">名词</mark> ：政府；管理；政体</p>              </div>            </details><details class="folding-tag" green><summary> 短语和例句 </summary>              <div class="content">              <ol><li>government <span class="nota" data-nota="复数">revenues</span> 政府收入</li><li>government transparency 政府透明度</li></ol>              </div>            </details><details class="folding-tag" green><summary> 派生词 </summary>              <div class="content">              <p><mark class="hl-label green">givernment-funded</mark>  adj.政府拨款的</p><p><mark class="hl-label green">govern</mark>  v.统治、支配；管理</p><p><mark class="hl-label green">governor</mark>  n.(殖民地)总督、(美国)州长</p><p><mark class="hl-label green">governance</mark>  n.管理方法</p><p>Good governance <span class="nota" data-nota="依靠">rests on</span> an understanding of the <span class="nota" data-nota="内在的">inherent</span> worth of each individual.</p>              </div>            </details><details class="folding-tag" green><summary> 相关词 </summary>              <div class="content">              <p><mark class="hl-label green">control</mark>  n.控制；指挥；指挥能力 || v.控制；指挥</p><ol><li><p>take control of 控制</p></li><li><p>air traffic control 空中交通指挥</p></li></ol><p><mark class="hl-label green">curb</mark>  v.控制、抑制 || n.起抑制作用的事物</p><p>Finally, figures close to the France government have murmured, euro-zone member should agree to some <span class="nota" data-nota="名词，财政">fiscal</span> and <span class="nota" data-nota="社会和谐">social harmonization</span>: eg., curbing competition in <span class="nota" data-nota="形容词，公司的">corporate</span>-tax rate or labour costs.</p><p><mark class="hl-label green">chancellor</mark>  n.大臣；总理；首席法官；大学名誉校长</p>              </div>            </details><h2 id="accord"><a href="#accord" class="headerlink" title="accord"></a>accord</h2><details class="folding-tag" green><summary> 单词意思 </summary>              <div class="content">              <p><mark class="hl-label green">名词</mark> ：协议；条约</p><p><mark class="hl-label green">动词</mark> ：给予；符合</p>              </div>            </details><details class="folding-tag" green><summary> 短语和例句 </summary>              <div class="content">              <ol><li>with one accord 一致地</li><li>in accord with 按照，与……一致</li><li>of one’s own accord 志愿地，主动地</li></ol><hr><p>Since desire and will are damaged by the presence of thoughts that don’t accord with desire, Allen concluded: “We do not attract what we want, but what we are.”</p>              </div>            </details><details class="folding-tag" green><summary> 相关词 </summary>              <div class="content">              <p><mark class="hl-label green">record</mark>  n.记录；履历；唱片 || v.记录；录音 || adj.创纪录的</p>              </div>            </details><h2 id="mean"><a href="#mean" class="headerlink" title="mean"></a>mean</h2><details class="folding-tag" green><summary> 单词意思 </summary>              <div class="content">              <p><mark class="hl-label green">动词</mark> ：意思是、意味着；打算；</p><p><mark class="hl-label green">形容词</mark> ：刻薄的、吝啬的；低劣的；平均的</p><p><mark class="hl-label green">名词</mark> ：平均值、平均数</p>              </div>            </details><details class="folding-tag" green><summary> 短语和例句 </summary>              <div class="content">              <p><mark>be meant</mark> to do sth 打算做某事</p><p>Certainly, intelligence <span class="nota" data-nota="包含">encompasses</span> more than a score on a test. <span class="nota" data-nota="副词，那么">Just</span> what does it mean to be smart?</p>              </div>            </details><details class="folding-tag" green><summary> 派生词 </summary>              <div class="content">              <p><mark class="hl-label green">meaning</mark>  n.含义</p><p><mark class="hl-label green">meaningful</mark>  adj.有意义的</p><p><mark class="hl-label green">means</mark>  <mark>n.方法，手段</mark></p><ol><li>a means of ……的方式</li><li>by this mean 借助这种方法</li><li>by means of 依靠……</li><li>by no means 绝不，一点也不</li></ol><p><mark class="hl-label green">meantime</mark>  n.同时 || adv.与此同时</p><p>in the meantime 与此同时</p><p><mark class="hl-label green">meanwhile</mark>  n.其间 || adv.同时</p>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> 大二上 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.2缺省参数与函数重载</title>
      <link href="/post/fb67e8be.html"/>
      <url>/post/fb67e8be.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h2><p>读者也许使用过一些图形库进行图形绘制或游戏制作，如 <span class="nota" data-nota="OpenGL、DirectX、EasyX、Raylib、ACLLib……">自己先想想再把鼠标移过来</span>。使用这些库的时候，我们直接调用里面的函数(API)即可实现想要的功能。</p><div class="tip info"><p>API :  Application Programming Interface，应用程序编程接口</p></div><p>而在调用这些API时，经常会遇到这样的情况：要使用的函数形参有很多。但是，我们往往只需要设置其中的某些参数，<psw>或者不知道其他参数设置了有什么用</psw>。这时就更希望那些我们没有自定义的参数使用比较合理的默认值。这样就不必输入全部的参数，使用起来也更加简便。</p><p><mark>要实现这点，在C++中，就要用到<emp>省略参数</emp>。</mark></p><h2 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h2><p>若要求我们实现一个加法器的程序，使它既能进行<code>int</code>相加，也能进行<code>double</code>相加和<code>float</code>相加。C语言中，我们的做法是分别定义下列的加法函数，然后针对不同类型的数据分别调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add_int</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">add_double</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a,<span class="hljs-keyword">double</span> b)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">add_float</span><span class="hljs-params">(<span class="hljs-keyword">float</span> a,<span class="hljs-keyword">float</span> b)</span></span>;<br></code></pre></td></tr></table></figure><p>有没有办法可以只用一个函数<code>add()</code>，既能实现<code>int</code>相加，也能实现<code>double</code>和<code>float</code>相加呢？</p><p><mark>要实现这点，在C++中，就要用到<emp>函数重载</emp>。</mark></p><h1 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h1><h2 id="缺省参数的概念"><a href="#缺省参数的概念" class="headerlink" title="缺省参数的概念"></a>缺省参数的概念</h2><p>缺省参数是指<emp>声明或定义函数时</emp>给函数指定一个参数，这个参数就是<wavy>默认值</wavy>。调用这个函数时：</p><ul><li>如果对应参数的位置传入实参，则使用传入值。</li><li>如果对应的位置没有传入实参，则使用默认值。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a=<span class="hljs-number">666</span>)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//传入值，使用传入的值</span><br>    cout&lt;&lt;<span class="hljs-built_in">Show</span>(<span class="hljs-number">999</span>)&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-comment">//不传入值，使用默认值</span><br>    cout&lt;&lt;<span class="hljs-built_in">Show</span>()&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>分别输出：<code>999</code>，<code>666</code>。</p></blockquote><h2 id="缺省参数的分类"><a href="#缺省参数的分类" class="headerlink" title="缺省参数的分类"></a>缺省参数的分类</h2><ol><li><strong>全缺省参数</strong>：所有形参都设定了默认值。</li><li><strong>半缺省参数</strong>：只有部分参数设定了默认值。</li></ol><div class="note warning modern"><p>半缺省参数的函数，形参列表只能是 <span class="p red">非默认-非默认……默认-默认-……</span> 这样的情况，即默认的参数只能放在非默认的后面。否则会导致结果和自己想的不一样。</p></div><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>缺省参数的默认值必须在使用之前确定。</li><li>非函数声明时有默认的形参必须放在没有默认值的形参的后面。</li><li>缺省参数在声明和定义里面的出现要注意！这点在下面使用例子进行解释。</li></ol><hr><div class="note info modern"><p>在之前例子的基础上，我们对它进行一些变化，请判断下面的三个例子是否正确：</p></div><ul><li><mark>声明和定义分开</mark>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a=<span class="hljs-number">666</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">Show</span>(<span class="hljs-number">999</span>)&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>    cout&lt;&lt;<span class="hljs-built_in">Show</span>()&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><details class="folding-tag" cyan><summary> 结果 </summary>              <div class="content">              <p>这是对的，默认参数要放在声明的地方！</p>              </div>            </details><ul><li><mark>默认参数放在定义处</mark>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">Show</span>(<span class="hljs-number">999</span>)&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>    cout&lt;&lt;<span class="hljs-built_in">Show</span>()&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a=<span class="hljs-number">666</span>)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><details class="folding-tag" cyan><summary> 结果 </summary>              <div class="content">              <p>编译器报错：<code>too few arguments to function ‘int Show(int)’</code>。即将默认值放在定义处时，由于编译器先解析的是函数声明，运行到相应函数的时候会到声明处去查询，所以不知道这个函数有默认值。(解析顺序的原因)</p>              </div>            </details><ul><li><mark>默认参数放在声明和定义处同时出现</mark>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a=<span class="hljs-number">666</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">Show</span>(<span class="hljs-number">999</span>)&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>    cout&lt;&lt;<span class="hljs-built_in">Show</span>()&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a=<span class="hljs-number">666</span>)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><details class="folding-tag" cyan><summary> 结果 </summary>              <div class="content">              <p>编译器报错：<code>为‘int Show(int)’的第 1 个形参指定了默认实参</code>，即不能重复设定默认实参。</p>              </div>            </details><div class="note warning modern"><p><span class="p center small">总结</span></p><p>当声明和定义分开时，<emp>默认参数必须放在声明处</emp>，只放在定义处，或声明和定义处同时设置默认参数都是错误的！</p></div><h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><h2 id="引言问题解决"><a href="#引言问题解决" class="headerlink" title="引言问题解决"></a>引言问题解决</h2><p>回到引言中加法器的问题，我们如何使得<code>add()</code>函数既能实现<code>int</code>相加，也能实现<code>double</code>和<code>float</code>相加呢？我们的方法是：<mark>使用函数重载，定义一系列同名函数。</mark></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//add.c中的内容</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">float</span> a,<span class="hljs-keyword">float</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a,<span class="hljs-keyword">double</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cloud.fullcomb.top/private/source/image/cpp/1/2.JPG" alt></p><div class="note info flat"><p><span class="p center small">如果对多文件编程有疑惑，可以去简单看看这篇文章：</span></p><div class="tag link"><a class="link-card" title="单独编译与链接" href="https://www.fullcomb.top/post/fb935c76.html#链接-Link"><div class="left"><img src="https://cloud.fullcomb.top/private/source/image/compilation/cover.png"></div><div class="right"><p class="text">单独编译与链接</p><p class="url">https://www.fullcomb.top/post/fb935c76.html#链接-Link</p></div></a></div></div><h2 id="函数重载的概念"><a href="#函数重载的概念" class="headerlink" title="函数重载的概念"></a>函数重载的概念</h2><p>C++允许在同一作用域中声明几个功能类似的同名函数。这些函数的<emp>形参列表必须不同</emp>(<span class="nota" data-nota="1. 形参个数不同 2. 形参数据类型不同 3. 形参顺序不同">想想可以有哪些不同</span>)。它常用于简化处理一系列功能类似，但数据类型不同的函数问题。</p><h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><p><mark>同名函数的形参列表一定要不同！</mark></p><p>因为我们调用函数的时候是通过<code>函数名(实参列表)</code>这样的方式进行的，这些函数的名字都相同，所以参数列表必须不同，这样编译器才能将它们分开，不然就会产生歧义。</p><hr><p> 函数重载的用法到这里就结束了，下面将利用汇编代码探究函数重载的原理，感兴趣的话可以看看。</p><h2 id="作用机理"><a href="#作用机理" class="headerlink" title="作用机理"></a>作用机理</h2><p>我们将之前生成的可执行文件用<code>objdump</code>指令进行反汇编，然后找到<code>add()</code>函数的位置。</p><p><img src="https://cloud.fullcomb.top/private/source/image/cpp/1/3.JPG" alt></p><p>很容易发现，两个<code>int</code>相加，就有后缀<code>ii</code>，<code>double</code>，<code>float</code>同理。前缀<code>-Z3</code>代表了返回类型（ <code>int</code> , <code>double</code> ， <code>float</code> 归为一类）。</p><p>可想而知，C++依据形参列表给函数名字添加相应的修饰符，从而将同名函数区分开。使用的时候，编译器就会通过前缀和后缀进行筛选，选出此处应该使用的函数。</p><div class="note info modern"><p>C++进行函数重载给函数名添加修饰符这一点和区分不同命名空间的成员的作用机理很相似。</p></div><p>C语言不支持函数重载，就是因为没有给函数添加修饰符这个机制。</p>]]></content>
      
      
      <categories>
          
          <category> 大二上 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.1命名空间与IO</title>
      <link href="/post/10d6f836.html"/>
      <url>/post/10d6f836.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>学习一门语言，一般都是从<code>Hello,world!</code>开始的。我们先来看一下C++的<code>Hello,world!</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Hello,world!&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时初学者一般会有两个疑惑：</p><ol><li><emp>namespace</emp>是什么鬼？</li><li><emp>cout和endl</emp>又是什么？</li><li>为什么<emp>头文件</emp>没有<code>.h</code>？</li></ol><div class="tip "><p>这三个问题将在本节解决。</p></div><h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><h2 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h2><p>在使用C语言进行协同项目开发时，可能会有这样的情况：A和B在编写各自的模块时，都定义了相同名字的函数。他们各自的代码能够编译通过，但是最后合并的时候，编译器却会报错。这个问题就是重定义。</p><p>如下图，A和B都定义了一个名叫foo的函数。我们分别编译A和B的代码，是没有问题的。但是，最后链接的时候，编译器报错”<code>ambiguating new declaration</code>“(重定义)。</p><p><img src="https://cloud.fullcomb.top/private/source/image/cpp/1/1.JPG" alt></p><div class="note info flat"><p><span class="p center small">如果对C的编译和链接有疑惑，可以去简单看看这篇文章：</span></p><div class="tag link"><a class="link-card" title="编译与链接" href="https://www.fullcomb.top/post/fb935c76.html"><div class="left"><img src="https://cloud.fullcomb.top/private/source/image/compilation/cover.png"></div><div class="right"><p class="text">编译与链接</p><p class="url">https://www.fullcomb.top/post/fb935c76.html</p></div></a></div></div><p>这个问题，即相同名字的函数(当然不局限于函数)发生冲突，在C语言中是没有解决的。<psw>至少我不会/脸黑</psw>。但是就这个问题，C++给出的明确的解决方案就是使用”<emp>命名空间</emp>“。</p><h2 id="命名空间的作用"><a href="#命名空间的作用" class="headerlink" title="命名空间的作用"></a>命名空间的作用</h2><ul><li><p>简单点来说，我们把名字关进命名空间这个”小黑屋”。编译器在外面是不知道里面有什么的，当我们把小黑屋打开，编译器才能找到里面的名字。同时，这个屋内的变量名字即使同另外一个的一样，但是他们本质是不一样的。使用时我们按照一定的方式打开”小黑屋”(取出命名空间中的成员)即可。</p></li><li><p>严谨点来说，<mark>命名空间通过将标识(zhi)符的名称<wavy>本地化</wavy>，防止相同名字的标识符之间产生冲突</mark>。</p></li></ul><div class="note info flat"><p>本地化的意思就是编译器编译时会在名字前面加一些前缀(一个命名空间对应一个前缀)，以防止同名导致冲突。当我们使用某个命名空间的时候，编译器就会默认加上相应的前缀，从而找到对应的函数/变量。</p></div><h2 id="命名空间的定义"><a href="#命名空间的定义" class="headerlink" title="命名空间的定义"></a>命名空间的定义</h2><p>使用<code>namespace</code>关键字：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> Mynamespace&#123;<br>    <span class="hljs-comment">//存放变量</span><br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-comment">//存放函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="命名空间的使用"><a href="#命名空间的使用" class="headerlink" title="命名空间的使用"></a>命名空间的使用</h2><p>使用命名空间有三种方法：</p><ol><li><p><mark>暴力导入</mark>。一次性全部释放出命名空间中的所有成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> Mynamespace; <br></code></pre></td></tr></table></figure><p>这样确实省力，但是全部释放后这个命名空间就相当于不存在了，没有起到命名空间的作用。所以，<emp>这种方法一定要慎用！！！</emp></p></li><li><p><mark>一个个导入</mark>。事先想好自己要用到这个命名空间中的哪些成员，把他们单独释放出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//释放出命名空间中的a变量</span><br><span class="hljs-keyword">using</span> Mynamespace::a;<br></code></pre></td></tr></table></figure><p>这要求我们提前想好要使用命名空间的哪些成员(当然也可以用到时加，但是程序会显得很乱)。这种方法<wavy>适用于使用比较频繁的成员</wavy>。</p></li><li><p><mark>使用命名空间名称和作用域限制符</mark>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::cout&lt;&lt;<span class="hljs-string">&quot;Hello,World!&quot;</span>&lt;&lt;std::endl;<br></code></pre></td></tr></table></figure><p>这样就不需要使用<code>using</code>了，同时也是最安全的一种做法。缺点是比较繁琐，<wavy>适用于使用不是那么频繁的成员</wavy>。</p></li></ol><div class="note info flat"><p>前两种方法相当于事先将命名空间里面的成员拿出来；第三种相当于要用的时候去对应命名空间取，用完再放回去。</p></div><h1 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h1><h2 id="为什么叫cin和cout"><a href="#为什么叫cin和cout" class="headerlink" title="为什么叫cin和cout"></a>为什么叫cin和cout</h2><p>想必这个问题会困扰初学者许久。也许你会认为因为是C++，所以在前面加了个C。但是，实际上并不是这样。</p><ul><li><p><code>cin</code>是<code>clavier input</code>的缩写，即键盘输入。表示程序接收来自键盘的输入。</p></li><li><p><code>cout</code>是<code>console output</code>的缩写，即控制台输出。表示将值输出到控制台（命令行）。</p></li><li><p><code>endl</code>是<code>end line</code>的缩写，即换行，它的作用同转义字符<code>\n</code>一样。</p><blockquote><psw>没用的知识增加了……</psw></blockquote></li></ul><h2 id="cout"><a href="#cout" class="headerlink" title="cout"></a>cout</h2><p><code>cout</code>支持<emp>连续输出</emp>和<emp>自动类型推断</emp>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> a=<span class="hljs-number">1</span>;<br>cout&lt;&lt;<span class="hljs-string">&quot;Hello,World!&quot;</span>&lt;&lt;endl&lt;&lt;<span class="hljs-string">&quot;换行后继续输出&quot;</span>&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>&lt;&lt;<span class="hljs-string">&quot;再次换行后继续输出&quot;</span>&lt;&lt;a;<br></code></pre></td></tr></table></figure><p>这里的<code>endl</code>和<code>\n</code>等价。</p><div class="note warning modern"><p>但是，cout不能控制输出的格式。比如，对于一个int型，不能指定以八进制或十六进制输出，这时我们应该使用标准化输出函数<code>printf</code>。</p></div><div class="tip info"><p>cout之所以支持自动类型推断，是因为对<code>&lt;&lt;</code>进行了运算符重载。</p></div><h2 id="cin"><a href="#cin" class="headerlink" title="cin"></a>cin</h2><p><code>cin</code>支持连续输入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">char</span> b;<br><span class="hljs-comment">//连续输入a和b</span><br>cin&gt;&gt;a&gt;&gt;b;<br></code></pre></td></tr></table></figure><p>但是，<code>cin</code>不能指定以什么样的方式输入（空格，不空格，换行……），这时我们应该使用<code>scanf</code>。</p><div class="note warning modern"><p>据我的测试，cin使用空格和换行分隔都是可以的，但是不能使用逗号分隔！所以需要用逗号作为分隔符或指定输入方式的就要用<code>scanf</code></p></div><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><code>scanf</code> 与 <code>printf</code> 其实是 C 语言提供的函数。大多数情况下，它们的速度比 <code>cin</code> 和 <code>cout</code> 更快，并且能够<mark>方便地控制输入输出格式</mark>。与之相比，<code>cin</code>和<code>cout</code>的使用更加灵活。它不需要我们去说明输出的格式，可以自己推导，并且能够<mark>连续输入和输出</mark>。</p><p>读者不妨用下面的代码进行一个简单的测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">clock_t</span> start=<span class="hljs-built_in">clock</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100000</span>;i++)<br>        <span class="hljs-comment">//测试cout的速度</span><br>        cout&lt;&lt;i;<br>    <span class="hljs-comment">//测试printf的速度</span><br>    <span class="hljs-comment">//printf(&quot;%d&quot;,i);</span><br>    <span class="hljs-keyword">clock_t</span> stop=<span class="hljs-built_in">clock</span>();<br>    cout&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>&lt;&lt;stop-start;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际使用中，对于应该使用<code>scanf</code> , <code>printf</code> 还是<code>cin</code>和<code>cout</code>，需要我们根据自己的需求进行选择。</p><hr><div class="note warning modern"><p>上面的结果对电脑性能依赖较大。而且有时候因为编译器的优化，<code>cin</code>和<code>cout</code>甚至会快过<code>scanf</code>和<code>printf</code>！所以我们还不能一概而论。</p></div><p>除此此外，OI可能会涉及到一些<emp>卡常</emp>的技巧。为了使程序运行得更快，很多大佬都推荐使用<code>cin</code>和<code>cout</code>。<psw>我在OI Wiki问过，大佬们给我的是这个答复。</psw></p><div class="tag link"><a class="link-card" title="OI Wiki" href="https://oi-wiki.org/lang/basic/"><div class="left"><img src="https://oi-wiki.org/favicon.ico"></div><div class="right"><p class="text">OI Wiki</p><p class="url">https://oi-wiki.org/lang/basic/</p></div></a></div><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><ol><li><p><strong>什么是<code>std</code>？</strong></p><p><code>std</code>是 C++ 标准库所使用的 <strong>命名空间</strong>。<code>cin</code>和<code>cout</code>都放在命名空间<code>std</code>里面。</p></li><li><p><strong>为什么头文件没有<code>.h</code>？</strong></p><p>这是对C++进行标准化的方式。C++引入命名空间以后，为了区分以前全局空间的头文件，所以用同名不带<code>.h</code>的方式对它们加以区别。而最前面加c表示来源于C语言。如：</p><details class="folding-tag" green><summary> 查看例子 </summary>              <div class="content">              <p>C++标准化之前的头文件去掉<code>.h</code>：</p><ul><li><code>iostream.h</code>-&gt;<code>iostream</code></li></ul><p>从C语言引入的头文件去掉<code>.h</code>，开头加上<code>c</code>：</p><ul><li><code>string.h</code>-&gt;<code>cstring</code></li><li><code>math.h</code>-&gt;<code>cmath</code></li></ul>              </div>            </details></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大二上 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.1 函数</title>
      <link href="/post/683da30b.html"/>
      <url>/post/683da30b.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="考点综述"><a href="#考点综述" class="headerlink" title="考点综述"></a>考点综述</h1><p>掌握函数<emp>表达式的求解</emp>，函数的<emp>奇偶性</emp>、<emp>单调性</emp>、<emp>有界性</emp>、<emp>周期性</emp>等基本性质的证明与应用。</p><h1 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h1><h2 id="求函数的表达式"><a href="#求函数的表达式" class="headerlink" title="求函数的表达式"></a>求函数的表达式</h2><h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><p><img src="https://cloud.fullcomb.top/private/source/image/math/1.1/1.png" alt></p><details class="folding-tag" green><summary> 解答 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/math/1.1/1.jpg" alt></p>              </div>            </details><details class="folding-tag" yellow><summary> 总结 </summary>              <div class="content">              <p>内层函数的值域是外层函数的定义域，进行分类讨论即可。</p>              </div>            </details><h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><p><img src="https://cloud.fullcomb.top/private/source/image/math/1.1/2.png" alt></p><details class="folding-tag" green><summary> 解答 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/math/1.1/2.jpg" alt></p>              </div>            </details><details class="folding-tag" yellow><summary> 总结 </summary>              <div class="content">              <p>这种题第一次确实不太容易想到……</p><p>不过看到n次方相加再开n次方的这种形式，可以想到最大值。以后看到这种形式就知道用夹逼了。</p><p>知道用夹逼之后还有一个问题就是最后还要写成分段函数的形式！</p>              </div>            </details><h3 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h3><p><img src="https://cloud.fullcomb.top/private/source/image/math/1.1/3.png" alt></p><details class="folding-tag" green><summary> 解答 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/math/1.1/3.jpg" alt></p>              </div>            </details><details class="folding-tag" yellow><summary> 总结 </summary>              <div class="content">              <p>$F(x)+F(\frac{x-1}{x})$可以进行一个形成闭环的代换！</p><p>该代换比较特别，应该熟练掌握！</p>              </div>            </details><h3 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h3><p><img src="https://cloud.fullcomb.top/private/source/image/math/1.1/4.png" alt></p><details class="folding-tag" green><summary> 解答 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/math/1.1/4.jpg" alt></p>              </div>            </details><details class="folding-tag" yellow><summary> 总结 </summary>              <div class="content">              <p>代换，消元的思路比较明显，最后取极限的时候消去含n的项即可。</p><p>要注意可以消去的条件：这里是因为$f(0)=0$。也有题目告诉$f(x)$有界，同样可以消去。</p>              </div>            </details><h3 id="例5"><a href="#例5" class="headerlink" title="例5"></a>例5</h3><p><img src="https://cloud.fullcomb.top/private/source/image/math/1.1/5.png" alt></p><details class="folding-tag" green><summary> 解答 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/math/1.1/5.jpg" alt></p>              </div>            </details><details class="folding-tag" yellow><summary> 总结 </summary>              <div class="content">              <p>抓住$\frac{\sqrt{45}-1}{2}$的特点！$x=\frac{\sqrt{45}-1}{2}$可以推出$(2x+1)^2=45$，即$x^2+x=11$​。根据这个表达式可以对$f(x)$进行降次，从而消去$x$。</p><p>其实看到这种高次方的，答案无非就是0或1(-1)。</p>              </div>            </details><h2 id="函数性质的应用"><a href="#函数性质的应用" class="headerlink" title="函数性质的应用"></a>函数性质的应用</h2><h3 id="例6"><a href="#例6" class="headerlink" title="例6"></a>例6</h3><p><img src="https://cloud.fullcomb.top/private/source/image/math/1.1/6.png" alt></p><details class="folding-tag" green><summary> 解答 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/math/1.1/6.jpg" alt></p>              </div>            </details><details class="folding-tag" yellow><summary> 总结 </summary>              <div class="content">              <p>用好奇偶性和周期性的性质就行了，确实没有什么难点。</p>              </div>            </details><h3 id="例7"><a href="#例7" class="headerlink" title="例7"></a>例7</h3><p><img src="https://cloud.fullcomb.top/private/source/image/math/1.1/7.png" alt></p><details class="folding-tag" green><summary> 解答 </summary>              <div class="content">              <p><img src="https://cloud.fullcomb.top/private/source/image/math/1.1/7.jpg" alt></p>              </div>            </details><details class="folding-tag" yellow><summary> 总结 </summary>              <div class="content">              <p>函数$f(x)$关于点$(a,b)$对称，表达式为$f(a-x)+f(a+x)=2b$，对称的两点相加即是中心！然后根据表达式进行配凑即可。</p><p>对于$y_1\neq y_2$​​的情形，还可以进一步讨论：</p><p><img src="https://cloud.fullcomb.top/private/source/image/math/1.1/8.jpg" alt></p>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> 数学竞赛 </category>
          
          <category> 第一章：函数、极限与连续 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数竞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LOOPERS:去寻找真正的宝物吧</title>
      <link href="/post/5dd6d766.html"/>
      <url>/post/5dd6d766.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>说起key，我总是首先想到钢琴。key一直用恰到好处，直击心灵的钢琴曲，让我们真切地感受到爱情、友情与亲情的“美好”，<del>带给我们无比刺激的体验</del>。她确实有这样的力量，我喜欢key的这一点。</p><hr><p>2020年10月key宣布了八大企划，LOOPERS就是其中之一。我很早就看到了关于这部的宣传，理所应当地第一眼就被其牛逼的画风所吸引。这样的画风让我想到之前火爆了的dohnadohna和《言语如苏打般涌现》，这两部作品成功的很大一部分都得益于其画风。LOOPERS的画风和这两部都有很多的相似之处，我有一个预感：LOOPERS要火。</p><span id="more"></span><hr><p>谈到key的核心人物，那必须得说麻枝准。无论是音乐还是剧情，他都能做到不错的高度。麻枝准似乎都成了key的招牌了。但有点不爽的是，他笔下的作品越来越套路化。概括下来就是，先给你一个让人摸不着头脑的展开；然后让你大致了解情况，并解决你的一些疑问，进入日常注水环节；在你快要忘记主要矛盾的时候，正好给你突如其来地来一刀；最后就是充分感受老麻笔下的爱的环节。然而至少现在，那一刀对我们来说并不是那么突如其来了，而仿佛是理所应当的了——因为麻枝准的作品都是一个模子刻出来的。</p><p>在这次的八大企划里，麻枝准好像去写那个手游的脚本了。正好我讨厌手游，也不想看到麻枝准。</p><hr><p>要我去找东西，我一般是拒绝的。特别是当要用到某个东西的时候，它却突然“消失”了，然后自己就开始不情愿地找啊找，最后放弃。这时候我甚至会想，要是它能够准确定位就好了。</p><p>寻宝游戏大致就是这样一个有明确定位（地图）的找东西的过程。当然，要是事先告诉我们能找到什么就再好不过了。特别是如果在对这个神秘物品抱有期待的前提下去找的时候，结果往往是失望的。相反，如果告诉我能找到女朋友，我现在随时都能动身去找。</p><p>这也不是绝对的——有的人就是痴迷于寻宝这个过程。虽然不是不可理解，但我实在不敢苟同，因为这太痛苦以至于都成心理阴影了。而LOOPERS就是关于这样一个不可理喻的寻宝迷的寻宝故事，然后捏，这个混蛋还真的找到了女朋友。</p><hr><p>故事是用第三人称讲述的，所以男主也有语音。但是——</p><ul><li><p><img src="https://cloud.fullcomb.top/private/source/image/LOOPERS/1.png" alt="1.png"><br>上面是我看到宣传后印象中的男主，一开始给我一种高冷的感觉；</p></li><li><p><img src="https://cloud.fullcomb.top/private/source/image/LOOPERS/2.png" alt="2.png"><br>  然后这是游戏里面的男主，加上配音，我突然感觉这货就是一个寻宝煞笔，人设崩塌了属于是。我还怕他突然喊一句：<br>  <img src="https://cloud.fullcomb.top/private/source/image/LOOPERS/3.png" alt="3.png"></p></li><li><p>游戏OP响起的时候，看到下面这张CG，我甚至还以为中间这位西门小帅哥才是男主。<br>  <img src="https://cloud.fullcomb.top/private/source/image/LOOPERS/4.png" alt="4.png"></p></li></ul><p>关于男主的题外话就到此为止了，下面进入正题。</p><hr><p>故事和一个中篇小说一样，被分成了若干章。</p><p>序章讲述了一个男孩在医院偶遇一个女孩，陪她玩了会，并且把一个玩具给了他，告诉她要把这个玩具传递下去，到某个时候，自己的心愿就会实现；相反玩具回到自己手里，愿望就会失效。所以，我很好奇，如果女孩真的把玩具传递下去，那么实现的到底是谁的心愿呢？或者直接溯源到玩具厂商？</p><p>开篇，深夜寻宝的男主遇到了多年未见的脑子不太好使的银毛和有点腹黑的紫毛，并拉上她们去寻宝。在寻宝的过程中，银毛看到了是都市传说觅心女的幻像，为了掩饰自己害怕的心情，她开始说起了轻视觅心女的言论。于是，似乎是报应来了，紫毛被银毛头槌抽风挂了，银毛的父亲也被心情十分糟糕的她推下楼脑死，觅心女的话一直在银毛耳边萦绕……第二天，银毛的父亲照常叫她吃早饭，一切都仿佛没发生过，除了紫毛一直还在昏迷。我就想问问，你的重置点不是在便利店吗？</p><p>男主也发现了不对劲，告诉银毛，这一天重新来了。</p><p>他们到了和这件事有关系的西门小帅哥那里，并被告知了一切的真相：自己也和他们一样，被困在了同一天。这一天每次都被会重置，除了记忆，自己什么也不能从上一次的这天带过来。困在这一天的不只是他们，还有其他人。大家都曾经纵情享乐，但是无尽享乐的终点就是失去理智（所以学习不好吗？）。这个群体被称为LOOPERS。</p><p><img src="https://cloud.fullcomb.top/private/source/image/LOOPERS/5.png" alt="5.png"></p><p>二人惊了，不敢相信……反正我都羡慕死了，也无话可说了。无缝衔接⬇</p><p><img src="https://cloud.fullcomb.top/private/source/image/LOOPERS/6.png" alt="6.png"></p><p>于是，享乐之旅开始了。花多少钱也无所谓，自己死了也无所谓，反正第二天一切都会重置。</p><p>男主在享乐够了之后则继续寻宝，他用寻宝获得了女主的芳心，同时用寻宝的魅力唤起了LOOPERS众人曾经失去的活力。然后日常注水中……</p><p>说实话，我真的不觉得这个寻宝有多么有趣。众人寻了个宝一下子就有活力了，感觉他们之前的烦恼都像假的一样。还有，真的想吐槽一下，男主每天的重置点都是熬夜寻宝的那个早晨吧？真亏他白天还能这么精神。</p><p>男主还用万能的寻宝把昏迷的紫毛给唤醒了。继续日常注水……</p><p>快乐的时光总是这么短暂。时间的大门打开了，LOOPERS要回到原来的世界了。</p><p>这时预言家刀了。</p><p><img src="https://cloud.fullcomb.top/private/source/image/LOOPERS/7.png" alt="7.png"></p><p>刀子来了。女主最后没有回来，选择留在了那个世界。因为她身患绝症，认为自己在原本的世界里没有明天可言。似曾相识的一幕…<img src="https://cloud.fullcomb.top/private/source/image/LOOPERS/8.png" alt="8.png"></p><p>命运弄人，女主的手术成功了，绝症不绝了，但是因为她没有从那个世界回来，所以仍一直昏迷不醒。</p><p>这时回到序章。女主通过寻宝游戏的方式把那个玩具传递下去，实现了自己明天不要到来的愿望。那个世界，就是女主的愿望所导致的。一方面，了解到真相后，LOOPERS为了让女主醒来，开始合力寻找那个玩具。另一方面，女主的意识到自己错了之后，世界开始崩塌，她也开始寻找起那个玩具。</p><p><img src="https://cloud.fullcomb.top/private/source/image/LOOPERS/9.png" alt="9.png"></p><p>预言家又刀了，玩具就在那个地方！</p><p>历经千辛万苦，男主终于找到了那个玩具。但是晚了一步，女主没能醒来。</p><p>之后，LOOPERS众人每天都和女主分享自己今天的故事，就和唤醒紫毛一样，认为女主这样总有一天能够醒来。反正最后就是真爱无敌呗，女主醒来了。</p><p><img src="https://cloud.fullcomb.top/private/source/image/LOOPERS/10.png" alt="10.png"></p><p><img src="https://cloud.fullcomb.top/private/source/image/LOOPERS/11.png" alt="11.png"></p><hr><ul><li><p>玩完之后，感动之余，再回想一下剧情，我的第一想法就是，这很难不让人怀疑真的没有麻枝准的参与。经典的开篇，经典的注水，经典的刀子……——太经典<del>俗爆</del>了！然而制作列表确实找不到麻子……</p></li><li><p>抛开阴魂不散的麻枝准不谈，LOOPERS的故事还是讲得不错的。从头推到尾，剧情十分连贯。而且，可能是篇幅比较短的缘故，没有什么不必要的元素，所有的元素都和故事的发展紧密相关：开篇的魔法童话、恐龙橡皮、寻宝……但全部都用那个万能的煞笔寻宝串联起来，虽说得过去，却有点离谱。</p></li><li><p>设置了很多伏笔和照应，这早就是key的一个特点了。但是我还是觉得有些伏笔设置得很巧妙。</p></li><li><p>可以看到key之前作品的很多梗。比如既视感等。</p></li><li><p>key的音乐还是一如既往地表现比较好，比如下面这首的piano version，配合完美的时机，表现力拉满！很多音乐都经得起反复听，但有些bgm表现还是很一般，出现时机也是。</p>  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" autoplay="false" src="//music.163.com/outchain/player?type=3&id=2488951711&auto=1&height=66"></iframe></li><li><p>LOOPERS的情感特别有感染力。特别是男主和女主隔着两个世界对话那一段。虽然他们可能听不到对方说的话，但是，相互的情感确实届到了。</p><p><img src="https://cloud.fullcomb.top/private/source/image/LOOPERS/12.png" alt="12.png"></p><p><img src="https://cloud.fullcomb.top/private/source/image/LOOPERS/13.png" alt="13.png"></p><p>包括结尾那个艹蛋的自动播放。</p></li></ul><hr><p>最后再来回答开始的问题，魔法实现的到底是男主的愿望还是女主的？</p><p>显然是女主的，因为她成功挽留住了今天。</p><p>但是，也可以说，二人的愿望都实现了。</p><p>男主的愿望是得到一张世界上最好的藏宝图。</p><p>他得到了，</p><p>也找到了世界上最重要的宝物。</p>]]></content>
      
      
      <categories>
          
          <category> galgame </category>
          
      </categories>
      
      
        <tags>
            
            <tag> key </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++的执行过程与make初步</title>
      <link href="/post/fb935c76.html"/>
      <url>/post/fb935c76.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这次讲一个可以说过时，但是也可以说永不过时的内容：C/C++的编译与链接。说它过时，因为我们学习C语言的时候，第一个讲的就是这个知识点；而它不过时，是因为它是程序运行的基础。比如在一个C/C++工程中，可能会有很多的<code>.c/.cpp</code>、<code>.h/.hpp</code>文件，这时候我们要运行这个工程，就离不开编译与链接。</p><p>接下来将在命令行一步步地进行这个过程。</p><span id="more"></span><h1 id="编译与链接"><a href="#编译与链接" class="headerlink" title="编译与链接"></a>编译与链接</h1><p>C/C++的执行过程包括预处理(Prepocessing)、编译(Compilation)、汇编(Assembly)、链接(Link)四步。我们常常忽略预处理与汇编，直接把这个过程称为编译与链接；有时候甚至直接用编译来代指这整个过程（虽然可能是不标准的说法）。</p><p><strong>下面两张图总结C/C++的编译与链接：</strong></p><p><img src="https://cloud.fullcomb.top/private/source/image/compilation/2.png" alt></p><p><img src="https://cloud.fullcomb.top/private/source/image/compilation/3.png" alt></p><h2 id="预处理-Preprocessing"><a href="#预处理-Preprocessing" class="headerlink" title="预处理(Preprocessing)"></a>预处理(Preprocessing)</h2><p>以 test.c 为例，对它进行预处理的命令是：<code>cpp test.c &gt; test.i</code>。它的作用是将 test.c 中包含的头文件和定义的宏 (Macro) 展开，得到 test.i 文件。</p><p>.i 文件，它也是 C 文件的一种，即里面的代码也是C语言。</p><p>程序中进行预处理的标志是<code>#</code>，常见的预处理指令有<code>include</code>、<code>define</code>、<code>ifdef</code>、<code>ifndef</code>、<code>endif</code>等等。预处理不是 C/C++ 等程序设计语言自带的功能。完成预处理的是编译器中的预处理程序。但我们又通常把预处理和编译这两个过程分开，把预处理视作编译的前置步骤。</p><h3 id="头文件的预处理"><a href="#头文件的预处理" class="headerlink" title="头文件的预处理"></a>头文件的预处理</h3><p><code>#include &lt;stdio.h&gt;</code>可能是我们平时用到最多的形式了。</p><p><code>include</code>告诉要引用后面的文件。<code>&lt;&gt;</code>告诉预处理程序在系统自带的目录下面去寻找头文件。如果引用自己写的头文件，则应该使用<code>&quot;&quot;</code>，它告诉预处理程序在当前文件的目录下面去寻找头文件。如果头文件在当前目录的子目录include下，则使用<code>&quot;include/MyHead.h&quot;</code>的方式。（当然也可以在运行的时候使用<code>-I</code>指令指定头文件的位置，后面讲）。</p><h3 id="宏的预处理"><a href="#宏的预处理" class="headerlink" title="宏的预处理"></a>宏的预处理</h3><p>我们经常使用的宏的形式为：<code>#define PI 3.14</code>。用这种方法定义一个符号常量，便于代码的维护。</p><p>我们也可以使用宏来实现求两个数的最大值：<code>#define MAX(x,y) ((x)&gt;(y)?(x):(y))</code>。这样我们在代码中使用<code>MAX(1,2)</code>就会在预处理是被自动替换成<code>((1)&gt;(2)?(1):(2))</code>,最终的结果为2，没有问题。</p><p>宏是一种高效的用法，它可以避免调用函数调用时的额外开销。但是，它的缺点就是太傻了——它直接替换使用宏的部分，可能导致替换后的运算顺序和预期不同。</p><p>与宏有关指令的除了<code>#define</code>以外，还有<code>#ifdef</code>、<code>#ifndef</code>、<code>#endif</code>等等。它们在工程中用得很多，下面进行简单的介绍。</p><p><code>#ifdef……#endif</code>告诉预处理程序如果定义了某个宏，则执行之间的代码块，否则就忽略；<code>#ifndef……#endif</code>反之。</p><p><code>#ifdef</code>、<code>#ifndef</code>在工程中经常用到。此外，如果我们去看一些头文件，就会发现很多<code>#ifdef……#endif</code>、<code>#ifndef……#endif</code>这样的代码。它的作用是防止头文件的重复包含以及函数的反复声明。</p><hr><p>在命令行输入<code>cpp test.c &gt; test.i</code>，得到 .i文件。</p><p><img src="https://cloud.fullcomb.top/private/source/image/compilation/1.png" alt></p><p>我们来对比一下 test.c 和 test.i。</p><ul><li>test.i 的头文件都展开了，所以main函数在468行，前面都是 stdio.h 的内容。</li><li>宏都进行了替换。如<code>MAX(2.4)</code>被替换为了<code>((2)&gt;(4)?(2):(4))</code>。</li><li>由于<code>MIN(x,y)</code>的宏定义被注释掉了，所以test.i中<code>#ifdef MIN(x,y)</code>和<code>#endif</code>之间的代码消失了。</li><li>预处理不会检查语法正确与否。生成的test.i 也是可以直接运行的，前提是你的语法得正确。</li></ul><h2 id="编译-Compilation"><a href="#编译-Compilation" class="headerlink" title="编译(Compilation)"></a>编译(Compilation)</h2><p>编译就是编译器将源代码转化为汇编代码的过程。</p><p>除了将源代码转化为汇编代码，编译器还要做很多工作，如代码的优化等。编译相关的内容可能会在计科的后续课程《编译原理》中学到。</p><p>现在广泛使用的编译器主要有gcc/g++、clang、MSVC等。不同的编译器对代码的处理不同。好像有的牛逼些的公司也开发了自己的编译器，据说之前校招的时候就在咱学校招了几个做编译器的，属于是稀缺人才了。</p><hr><p>命令行中对刚才的 test.i 进行编译：输入<code>gcc -S test.i</code>，得到 test.s。</p><p>我们来看看生成的 test.s，这是一个汇编代码。</p><p><img src="https://cloud.fullcomb.top/private/source/image/compilation/5.png" alt></p><p>.asm 也挺有用的。比如我们可以通过数汇编代码的行数来比较一些操作或算法的优劣。比如，我这里可以通过汇编代码比较直接寻址和间接寻址的效率的高低。</p><h2 id="汇编-Assembly"><a href="#汇编-Assembly" class="headerlink" title="汇编(Assembly)"></a>汇编(Assembly)</h2><p>汇编即将汇编代码生成二进制文件的过程。</p><p>在命令行输入<code>as -o test.o test.s</code>，得到 test.o(bj)。.o文件算是中间文件，一般我们的目标文件是 .exe（可执行文件）或 .lib（静态链接库）或 .dll（动态链接库）。所以最后的 .o文件都要clean，如果没有clean的话就会生成很多的 .o垃圾。</p><p>对于多文件编程，每个源文件都要生成一个.o文件，这样的.o文件很多，我们下一步去链接的时候就很麻烦。所以，我们将 .o 文件打个包，生成一个 .lib 文件，这样链接的时候就只需要链接这个文件就行了。</p><p>值得一提的是，gcc的库文件都是 lib**.a 的形式——这是库文件的标准形式。</p><p><img src="https://cloud.fullcomb.top/private/source/image/compilation/6.png" alt></p><h2 id="链接-Link"><a href="#链接-Link" class="headerlink" title="链接(Link)"></a>链接(Link)</h2><p>为了体现各文件的依赖关系，下面换一个例子。</p><p><img src="https://cloud.fullcomb.top/private/source/image/compilation/8.png" alt></p><p>可以看到，hellomake.c 包含了 hellofunc.h 这个头文件，并调用了外部的一个函数；hellofunc.h 中声明了函数原型；hellofunc .c 则对 hellofunc.h 中声明的函数进行了实现。</p><p>先将hellomake.c和hellofunc.c分别生成 .o文件，然后再将这两个.o文件链接起来，生成可执行文件。下图中一二行可以用第三行代替。</p><p><img src="https://cloud.fullcomb.top/private/source/image/compilation/7.png" alt></p><p>在我看来，链接算是很麻烦的一步了。我们平时常用的单个文件链接标准库固然简单，但是，当一个项目大起来的时候，不仅要链接系统的标准库，还要链接系统的非标准库，以及用户自己写的库。这时候要链接这一大堆文件就无比麻烦。</p><h3 id="链接系统的标准库"><a href="#链接系统的标准库" class="headerlink" title="链接系统的标准库"></a>链接系统的标准库</h3><p>这个很简单，你根本不需要指定路径。编译器会在系统路径(path)下面去搜索。但是，为了搜索的文件不是太多，编译器只会搜索标准库std。</p><h3 id="链接系统的非标准库"><a href="#链接系统的非标准库" class="headerlink" title="链接系统的非标准库"></a>链接系统的非标准库</h3><p>系统的非标准库，如数学函数库(libm.a)，则需要我们手动去链接（有的时候？这可能要看脸？）。</p><p>这是我们通过<code>-lm</code>指令，告诉编译器去链接libm.a这个库。m为库名，是库文件名减去前缀lib和后缀.a的剩余部分。</p><h3 id="链接用户自定义的库"><a href="#链接用户自定义的库" class="headerlink" title="链接用户自定义的库"></a>链接用户自定义的库</h3><p>告诉编译器链接用户自定义的库，这大概就是所谓的令人头疼的配置环境了吧？</p><p>如果这些库都在该工程文件的子文件夹下，则直接使用<code>-l</code>命令即可，和链接系统的非标准库的做法一样。不过还得注意头文件的路径，要么在<code>#include &quot;include/.h&quot;</code>时说明搜索路径，要么通过<code>-I</code>命令添加头文件的绝对或相对路径。</p><hr><p>如果我们每次运行时都在命令行输入这样复杂的命令，肯定很麻烦，也不便于查看和修改之前的命令。于是，就有了make这种脚本工具来帮助我们来管理命令。</p><h1 id="make初步"><a href="#make初步" class="headerlink" title="make初步"></a>make初步</h1><p>这里仅对make进行一个感性的认识。</p><p><img src="https://cloud.fullcomb.top/private/source/image/compilation/9.png" alt></p><p>如图，我们先在makefile中写好命令。然后在命令行中输入make，则会自动执行我们在make中写好的命令。这就是最简单的makefile，它的作用好比一个脚本。</p><p>当文件多起来的时候，这样直接生成一个可执行文件肯定时不适用的。一是命令太长，二是我们有时候希望使用动态链接库。所以我们把指令分开来写，先生成 .o 文件，再生成可执行文件，如下图。</p><p><img src="https://cloud.fullcomb.top/private/source/image/compilation/10.png" alt></p><p>这样的好处是得到中间文件 .o ，可以生成库，供自己和别人使用。但是坏处就是会生成大量的 .o 文件，当文件多起来的时候，就会显得很乱。</p><p>解决方案一是在makefile中添加删除 .o 文件的命令。make有一个clean的指令，但我还不太会，所以直接用windows的 del 指令。</p><p><img src="https://cloud.fullcomb.top/private/source/image/compilation/11.png" alt></p><p>但是，当我们需要使用中间文件 .o 的时候，这种方法就不适用了。</p><p>所以解决方法二是将生成的文件输出到 build 目录下。使用 -o 指令指定输出文件的位置即可。（同时把可执行文件输出到 bin 目录下，头文件放到 include 目录下，这样就有点工程的感觉了。）</p><p><img src="https://cloud.fullcomb.top/private/source/image/compilation/12.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 常识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++程序设计 </tag>
            
            <tag> C语言复习 </tag>
            
            <tag> make </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表的应用1：就地逆置</title>
      <link href="/post/968a1ec4.html"/>
      <url>/post/968a1ec4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>就地逆置就是将动态数组中的所有元素逆置，空间复杂度为O(1)。</p><p>它可以说是线性表最重要的应用了，下面用多种方法分别实现顺序表和单链表的就地逆置。</p><h1 id="顺序表的就地逆置"><a href="#顺序表的就地逆置" class="headerlink" title="顺序表的就地逆置"></a>顺序表的就地逆置</h1><p>回顾顺序表的定义：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SeqList</span>&#123;</span><br>ElemType * elem;<br><span class="hljs-keyword">int</span> length;<br><span class="hljs-keyword">int</span> size;<br>&#125;SeqList,ListPtr;<br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="1-设置中间量"><a href="#1-设置中间量" class="headerlink" title="1. 设置中间量"></a>1. 设置中间量</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xl">void SeqListReverse_1(SeqList * list)&#123;<br>ElemType temp;<br><span class="hljs-function"><span class="hljs-title">for</span>(int i=0;i&lt;(list-&gt;</span>length)/<span class="hljs-number">2</span>;i++)&#123;<br><span class="hljs-function"><span class="hljs-title">temp</span>=list-&gt;</span>elem[i];<br><span class="hljs-function"><span class="hljs-title">list</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">elem</span>[i]=list-&gt;</span><span class="hljs-function"><span class="hljs-title">elem</span>[list-&gt;</span>length-i-<span class="hljs-number">1</span>];<br><span class="hljs-function"><span class="hljs-title">list</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">elem</span>[list-&gt;</span>length-i-<span class="hljs-number">1</span>]=temp;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-使用地址指针"><a href="#2-使用地址指针" class="headerlink" title="2. 使用地址指针"></a>2. 使用地址指针</h2><p>两端均设置一个指针，两指针逐渐向中间靠拢，指针交错时停止交换。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros">void SeqListReverse_2(SeqList * list)&#123;<br>ElemType * <span class="hljs-attribute">p</span>=&amp;(list-&gt;elem[0]);<br>ElemType * <span class="hljs-attribute">q</span>=&amp;(list-&gt;elem[list-&gt;length-1]);<br><span class="hljs-keyword">while</span>(p&lt;q)&#123;<br>*p+=*q;<br>*<span class="hljs-attribute">q</span>=*p-*q;<br>*<span class="hljs-attribute">p-</span>=*q;<br>p++;<br>q--;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>要注意上面指针的操作，有点炫技，但是可读性不高。不过这个方法还是值得学习。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">*p+=*q;<br>*<span class="hljs-attribute">q</span>=*p-*q;<br>*<span class="hljs-attribute">p-</span>=*q;<br></code></pre></td></tr></table></figure><p>与设置中间量的方法进行比较，第一种方法循环中涉及3次赋值操作、4次加减运算、4次间接寻址、4次直接寻址；第二种方法涉及3次赋值操作、3次加减运算、7次间接寻址。但是第二种方法多定义了一个指针变量。对于不同大小的ElemType，两种方法孰优孰劣还不好说。</p><p>但是，我们可以改进第二种方法，将间接寻址变为加减运算加直接寻址，即第三种方法，这样按理说效率会更高。</p><h2 id="3-设置计数器指针"><a href="#3-设置计数器指针" class="headerlink" title="3. 设置计数器指针"></a>3. 设置计数器指针</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xl">void SeqListReverse_3(SeqList * list)&#123;<br><span class="hljs-function"><span class="hljs-title">int</span> i=0,j=list-&gt;</span>length-<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(i&lt;j)&#123;<br><span class="hljs-function"><span class="hljs-title">list</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">elem</span>[i]+=list-&gt;</span>elem[j];<br><span class="hljs-function"><span class="hljs-title">list</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">elem</span>[j]=list-&gt;</span><span class="hljs-function"><span class="hljs-title">elem</span>[i]-list-&gt;</span>elem[j];<br><span class="hljs-function"><span class="hljs-title">list</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">elem</span>[i]-=list-&gt;</span>elem[j];<br>i++;<br>j--;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>很显然，上面的想法失败了。第三种方法虽然将间接寻址变成了直接寻址，但是又引入了<code>list-&gt;</code>的间接寻址，可以说是得不偿失。</p><p>但是，多亏了编译器在编译时将间接寻址转化为直接寻址，上面三种方法差别不大。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 10</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SeqList</span>&#123;</span><br>ElemType * elem;<br><span class="hljs-keyword">int</span> length;<br><span class="hljs-keyword">int</span> size;<br>&#125;SeqList,ListPtr;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitSeqList</span><span class="hljs-params">(SeqList * list)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SeqListReverse_1</span><span class="hljs-params">(SeqList * list)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SeqListReverse_2</span><span class="hljs-params">(SeqList * list)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SeqListReverse_3</span><span class="hljs-params">(SeqList * list)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ListDisplay</span><span class="hljs-params">(SeqList * list)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>SeqList list;<br><span class="hljs-built_in">InitSeqList</span>(&amp;list);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;list.size;i++)&#123;<br>list.elem[i]=i;<br>list.length++;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;原始的序列：&quot;</span>);<br><span class="hljs-built_in">ListDisplay</span>(&amp;list);<br><br><span class="hljs-built_in">SeqListReverse_1</span>(&amp;list);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;交换第一次后的序列：&quot;</span>);<br><span class="hljs-built_in">ListDisplay</span>(&amp;list);<br><br><span class="hljs-built_in">SeqListReverse_2</span>(&amp;list);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;交换第二次后的序列：&quot;</span>);<br><span class="hljs-built_in">ListDisplay</span>(&amp;list);<br><br><span class="hljs-built_in">SeqListReverse_3</span>(&amp;list);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;交换第三次后的序列：&quot;</span>);<br><span class="hljs-built_in">ListDisplay</span>(&amp;list);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitSeqList</span><span class="hljs-params">(SeqList * list)</span></span>&#123;<br>list-&gt;elem=(ElemType*)<span class="hljs-built_in">malloc</span>(list-&gt;size*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ElemType));<br><span class="hljs-keyword">if</span>(list-&gt;elem==<span class="hljs-literal">NULL</span>) <br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>list-&gt;length=<span class="hljs-number">0</span>;<br>list-&gt;size=MAXSIZE;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SeqListReverse_1</span><span class="hljs-params">(SeqList * list)</span></span>&#123;<br>ElemType temp;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;(list-&gt;length)/<span class="hljs-number">2</span>;i++)&#123;<br>temp=list-&gt;elem[i];<br>list-&gt;elem[i]=list-&gt;elem[list-&gt;length-i<span class="hljs-number">-1</span>];<br>list-&gt;elem[list-&gt;length-i<span class="hljs-number">-1</span>]=temp;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SeqListReverse_2</span><span class="hljs-params">(SeqList * list)</span></span>&#123;<br>ElemType * p=&amp;(list-&gt;elem[<span class="hljs-number">0</span>]);<br>ElemType * q=&amp;(list-&gt;elem[list-&gt;length<span class="hljs-number">-1</span>]);<br><span class="hljs-keyword">while</span>(p&lt;q)&#123;<br>*p+=*q;<br>*q=*p-*q;<br>*p-=*q;<br>p++;<br>q--;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SeqListReverse_3</span><span class="hljs-params">(SeqList * list)</span></span>&#123;<br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=list-&gt;length<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>list-&gt;elem[i]+=list-&gt;elem[j];<br>list-&gt;elem[j]=list-&gt;elem[i]-list-&gt;elem[j];<br>list-&gt;elem[i]-=list-&gt;elem[j];<br>i++;<br>j--;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ListDisplay</span><span class="hljs-params">(SeqList * list)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;list-&gt;length;i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,list-&gt;elem[i]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>output:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">原始的序列：<span class="hljs-number">0123456789</span><br>交换第一次后的序列：<span class="hljs-number">9876543210</span><br>交换第二次后的序列：<span class="hljs-number">0123456789</span><br>交换第三次后的序列：<span class="hljs-number">9876543210</span><br></code></pre></td></tr></table></figure><h1 id="单链表的就地逆置"><a href="#单链表的就地逆置" class="headerlink" title="单链表的就地逆置"></a>单链表的就地逆置</h1><p>回顾单链表节点的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> DataType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkListNode</span>&#123;</span><br>DataType data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkListNode</span> * <span class="hljs-title">next</span>;</span><br>&#125;LinkListNode,*ListPtr;<br></code></pre></td></tr></table></figure><p>下面的单链表默认带上头节点（递归法除外）。为了避免使用二重指针，下面的函数都通过返回值进行参数传递。</p><h2 id="1-迭代法"><a href="#1-迭代法" class="headerlink" title="1.迭代法"></a>1.迭代法</h2><p>迭代法的原理就是一个一个地将单链表的指针反向。</p><p>实现这算法需要设置三个指针<code>pre</code>、<code>cur</code>、<code>nex</code>，三个指针每次都向后移动，每次移动改变一个指针的方向。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs \">LinkListNode * LinkListReverse_1(LinkListNode * head)&#123;<br>LinkListNode * cur=head-&gt;next;<br>LinkListNode * pre=NULL, * nex=NULL;<br>while(cur!=NULL)&#123;<br>nex=cur-&gt;next;<br>cur-&gt;next=pre;<br>pre=cur;<br>cur=nex;<br>&#125;<br>head-&gt;next=pre;<br>return head;<br>&#125;<br></code></pre></td></tr></table></figure><p>要注意这里改变的是<code>pre</code>和<code>cur</code>之间的指针，而不能改变<code>cur</code>和<code>nex</code>之间的指针。</p><h2 id="2-递归法"><a href="#2-递归法" class="headerlink" title="2. 递归法"></a>2. 递归法</h2><p>递归的优点是使程序看起来优美，简单（实际上并不是表面上那么简单）。</p><p>递归法反转链表更适用于不带头结点的单链表。如果带上头结点，则需要做很多修改（反正我加了很多代码才可以），与递归的宗旨相违背。所以仅递归反转不带头结点的单链表。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xquery">LinkListNode * LinkListReverse_2(LinkListNode *<span class="hljs-built_in"> head</span>)&#123;<br><span class="hljs-keyword">if</span><span class="hljs-built_in">(head</span>==NULL|<span class="hljs-built_in">|head</span>-&gt;<span class="hljs-keyword">next</span>==NULL) <span class="hljs-keyword">return</span><span class="hljs-built_in"> head</span>;<br>LinkListNode *<span class="hljs-built_in"> tail</span>=LinkListReverse_2<span class="hljs-built_in">(head</span>-&gt;<span class="hljs-keyword">next</span>);<br><span class="hljs-built_in">head</span>-&gt;next-&gt;<span class="hljs-keyword">next</span><span class="hljs-built_in">=head</span>;<br><span class="hljs-built_in">head</span>-&gt;<span class="hljs-keyword">next</span>=NULL;<br><span class="hljs-keyword">return</span><span class="hljs-built_in"> tail</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>递归法确实有点难以理解，我也不太说得清楚。不过关键是不要按照程序运行的逻辑去想它是怎么递归的，脑袋中的栈会被压爆的。正确的做法是跳出递归，从结束递归的出口开始，往回想，然后就会发现规律。</p><p>具体的参考下面这篇文章：<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/bu-bu-chai-jie-ru-he-di-gui-di-fan-zhuan-lian-biao/">步步拆解：如何递归地反转链表的一部分 - 反转链表 II - 力扣（LeetCode）</a></p><h2 id="3-头插法"><a href="#3-头插法" class="headerlink" title="3. 头插法"></a>3. 头插法</h2><p>头插法需要需要先定义一个空串，然后把原来的链表的首元结点摘下来，最后把摘下来的结点插入新串的头节点和原首元结点之间。重复此操作，直到旧串为空。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs elixir">LinkListNode * LinkListReverse_3(LinkListNode * head)&#123;<br>if(head-&gt;<span class="hljs-keyword">next</span>==NULL||head-&gt;<span class="hljs-keyword">next</span>-&gt;<span class="hljs-keyword">next</span>==NULL) <span class="hljs-keyword">return</span> head;<br>LinkListNode * list=(LinkListNode*)malloc(sizeof(LinkListNode));<br>list-&gt;<span class="hljs-keyword">next</span>=NULL;<br>LinkListNode * temp;<br><span class="hljs-keyword">while</span>(head-&gt;<span class="hljs-keyword">next</span>!=NULL)&#123;<br>temp=head-&gt;<span class="hljs-keyword">next</span>;<br>head-&gt;<span class="hljs-keyword">next</span>=temp-&gt;<span class="hljs-keyword">next</span>;<br>temp-&gt;<span class="hljs-keyword">next</span>=list-&gt;<span class="hljs-keyword">next</span>;<br>list-&gt;<span class="hljs-keyword">next</span>=temp;<br>&#125;<br><span class="hljs-keyword">return</span> list;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-就地逆置法"><a href="#4-就地逆置法" class="headerlink" title="4. 就地逆置法"></a>4. 就地逆置法</h2><p>就地逆置法与头插法的区别就在于是否构造新串。就地逆置法的插入操作直接在原来的单链表上进行。所以相比头插法，就地逆置法还需要多用一个指针。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs elixir">LinkListNode * LinkListReverse_4(LinkListNode * head)&#123;<br>LinkListNode * p=head-&gt;<span class="hljs-keyword">next</span>, * q=p-&gt;<span class="hljs-keyword">next</span>;<br><span class="hljs-keyword">while</span>(q!=NULL)&#123;<br>p-&gt;<span class="hljs-keyword">next</span>=q-&gt;<span class="hljs-keyword">next</span>;<br>q-&gt;<span class="hljs-keyword">next</span>=head-&gt;<span class="hljs-keyword">next</span>;<br>head-&gt;<span class="hljs-keyword">next</span>=q;<br>q=p-&gt;<span class="hljs-keyword">next</span>;<br>&#125;<br><span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br>typedef int DataType;<br>typedef struct LinkListNode&#123;<br>DataType data;<br>struct LinkListNode * next;<br>&#125;LinkListNode,*ListPtr;<br><br>LinkListNode * InitLinkList(int n);<br>LinkListNode * LinkListReverse_1(LinkListNode * head);<br>LinkListNode * LinkListReverse_3(LinkListNode * head);<br>LinkListNode * LinkListReverse_4(LinkListNode * head);<br>int DisplayLinkList(LinkListNode * head);<br><br>int main()&#123;<br>int <span class="hljs-attribute">n</span>=9;<br>LinkListNode * head;<br><span class="hljs-attribute">head</span>=InitLinkList(n);<br>printf(<span class="hljs-string">&quot;原始的序列：&quot;</span>);<br>DisplayLinkList(head);<br><br><span class="hljs-attribute">head</span>=LinkListReverse_1(head);<br>printf(<span class="hljs-string">&quot;交换第一次后的序列：&quot;</span>);<br>DisplayLinkList(head);<br><br><span class="hljs-attribute">head</span>=LinkListReverse_3(head);<br>printf(<span class="hljs-string">&quot;交换第二次后的序列：&quot;</span>);<br>DisplayLinkList(head);<br><br><span class="hljs-attribute">head</span>=LinkListReverse_4(head);<br>printf(<span class="hljs-string">&quot;交换第三次后的序列：&quot;</span>);<br>DisplayLinkList(head);<br><br>return 0;<br>&#125;<br><br>LinkListNode * InitLinkList(int n)&#123;<br>LinkListNode * head=(LinkListNode*)malloc(sizeof(LinkListNode));<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">head</span>==NULL) exit(0);<br>head-&gt;<span class="hljs-attribute">next</span>=<span class="hljs-literal">NULL</span>;<br>LinkListNode * <span class="hljs-attribute">temp</span>=head;<br><span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=1;i&lt;=n;i++)&#123;<br>temp-&gt;next=(LinkListNode*)malloc(sizeof(LinkListNode));<br><span class="hljs-keyword">if</span>(temp-&gt;<span class="hljs-attribute">next</span>==NULL) exit(0);<br><span class="hljs-attribute">temp</span>=temp-&gt;next;<br>        temp-&gt;<span class="hljs-attribute">next</span>=<span class="hljs-literal">NULL</span>;<br>        temp-&gt;<span class="hljs-attribute">data</span>=i;<br>&#125;<br>return head;<br>&#125;<br>int DisplayLinkList(LinkListNode * head)&#123;<br>LinkListNode * <span class="hljs-attribute">temp</span>=head-&gt;next;<br><span class="hljs-keyword">while</span>(temp!=<span class="hljs-literal">NULL</span>)&#123;<br>printf(<span class="hljs-string">&quot;%d&quot;</span>,temp-&gt;data);<br><span class="hljs-attribute">temp</span>=temp-&gt;next;<br>&#125;<br>printf(<span class="hljs-string">&quot;\n&quot;</span>);<br>return 0;<br>&#125;<br>LinkListNode * LinkListReverse_1(LinkListNode * head)&#123;<br>LinkListNode * <span class="hljs-attribute">cur</span>=head-&gt;next;<br>LinkListNode * <span class="hljs-attribute">pre</span>=<span class="hljs-literal">NULL</span>, * <span class="hljs-attribute">nex</span>=<span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-attribute">nex</span>=cur-&gt;next;<br>cur-&gt;<span class="hljs-attribute">next</span>=pre;<br><span class="hljs-attribute">pre</span>=cur;<br><span class="hljs-attribute">cur</span>=nex;<br>&#125;<br>head-&gt;<span class="hljs-attribute">next</span>=pre;<br>return head;<br>&#125;<br><br>LinkListNode * LinkListReverse_3(LinkListNode * head)&#123;<br><span class="hljs-keyword">if</span>(head-&gt;<span class="hljs-attribute">next</span>==NULL||head-&gt;next-&gt;next==NULL) return head;<br>LinkListNode * list=(LinkListNode*)malloc(sizeof(LinkListNode));<br>list-&gt;<span class="hljs-attribute">next</span>=<span class="hljs-literal">NULL</span>;<br>LinkListNode * temp;<br><span class="hljs-keyword">while</span>(head-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-attribute">temp</span>=head-&gt;next;<br>head-&gt;<span class="hljs-attribute">next</span>=temp-&gt;next;<br>temp-&gt;<span class="hljs-attribute">next</span>=list-&gt;next;<br>list-&gt;<span class="hljs-attribute">next</span>=temp;<br>&#125;<br>return list;<br>&#125;<br>LinkListNode * LinkListReverse_4(LinkListNode * head)&#123;<br>LinkListNode * <span class="hljs-attribute">p</span>=head-&gt;next, * <span class="hljs-attribute">q</span>=p-&gt;next;<br><span class="hljs-keyword">while</span>(q!=<span class="hljs-literal">NULL</span>)&#123;<br>p-&gt;<span class="hljs-attribute">next</span>=q-&gt;next;<br>q-&gt;<span class="hljs-attribute">next</span>=head-&gt;next;<br>head-&gt;<span class="hljs-attribute">next</span>=q;<br><span class="hljs-attribute">q</span>=p-&gt;next;<br>&#125;<br>return head;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>output:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">原始的序列：<span class="hljs-number">123456789</span><br>交换第一次后的序列：<span class="hljs-number">987654321</span><br>交换第二次后的序列：<span class="hljs-number">123456789</span><br>交换第三次后的序列：<span class="hljs-number">987654321</span><br></code></pre></td></tr></table></figure><p>递归法的链表因为不带头结点，所以没有测试，不过应该没问题。</p>]]></content>
      
      
      <categories>
          
          <category> 大二上 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将代码上传到github</title>
      <link href="/post/6881dc2b.html"/>
      <url>/post/6881dc2b.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前一直在用hexo+Github生成静态博客，push了一次又一次，但是无非就是使用<code>hexo -cl</code>、<code>hexo -g</code>、<code>hexo -s</code>、<code>hexo -d</code>这几个命令。今天尝试将前几天写好的代码push到Github上。</p><p>刚才还好好的Github，现在突然抽风打不开了，所以我用gitee演示。</p><p>首先确认电脑上安装了git。</p><span id="more"></span><h1 id="第一步：初始化本地仓库"><a href="#第一步：初始化本地仓库" class="headerlink" title="第一步：初始化本地仓库"></a>第一步：初始化本地仓库</h1><ol><li><p>cd 项目文件夹</p></li><li><p>右键，Git Bash Here</p><p><img src="https://cloud.fullcomb.top/private/source/image/github1/1.png" alt></p></li><li><p>Bash里面输入<code>git init</code></p><p>这时候可以看到，项目文件夹里面多了名为<code>.git</code>的隐藏文件夹。</p><p><img src="https://cloud.fullcomb.top/private/source/image/github1/2.png" alt></p></li></ol><h1 id="第二步：远程连接"><a href="#第二步：远程连接" class="headerlink" title="第二步：远程连接"></a>第二步：远程连接</h1><ol><li><p>创建并初始化仓库，复制仓库地址。</p><p><img src="https://cloud.fullcomb.top/private/source/image/github1/3.png" alt></p></li><li><p><code>git remote add origin https://仓库地址</code></p></li><li><p>通过<code>git remote -v</code>命令查看</p><p><img src="https://cloud.fullcomb.top/private/source/image/github1/4.png" alt></p><blockquote><p>hint:我之前已经添加过仓库了所以第一个命令提示error</p></blockquote></li></ol><h1 id="第三步：推送到远程仓库"><a href="#第三步：推送到远程仓库" class="headerlink" title="第三步：推送到远程仓库"></a>第三步：推送到远程仓库</h1><ol><li><p><code>git add .</code>将文件夹下的所有文件添加到暂存区。</p></li><li><p><code>git commit -m &quot;备注&quot;</code>提交暂存区的文件到本地仓库。</p><p>这里的备注将会在仓库那里显示出来（文件名后面）。</p><p><img src="https://cloud.fullcomb.top/private/source/image/github1/7.png" alt></p></li><li><p><code>git pull --rebase origin master</code>将本地仓库和远程仓库同步</p></li></ol><p>这时候会发现工作目录下多了两个README.md文件。</p><ol><li><p><code>git push -u origin master</code>将缓冲区的文件推送到远程仓库。</p><p> <img src="https://cloud.fullcomb.top/private/source/image/github1/6.png" alt></p></li></ol><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>origin的名称要统一</p><p>如果你习惯使用origion那么就一直用origion，否则就一直用origin。两个混用会报错。</p>]]></content>
      
      
      <categories>
          
          <category> 常识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表及其基本操作</title>
      <link href="/post/858a796f.html"/>
      <url>/post/858a796f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>单链表是最简单确定链表，由一系列节点组成的序列，包括三部分：头指针、头节点、元节点。其中头节点根据实际需求可以不用。有头节点的优点是可保证链表非空，便于判断其他无效的指针即空指针。</p><h1 id="单链表节点的定义"><a href="#单链表节点的定义" class="headerlink" title="单链表节点的定义"></a>单链表节点的定义</h1><p>单链表的节点包括数据域和指针域。指针域中的指针指向下一个节点；数据域用于存放数据，存放的数据也可以是指针类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> DataType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkListNode</span>&#123;</span><br>DataType data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkListNode</span> * <span class="hljs-title">next</span>;</span><br>&#125;LinkListNode, * NodePtr;<br></code></pre></td></tr></table></figure><span id="more"></span><p>虽然这里我还定义了NodePtr这个指针类型，但是我不太喜欢使用。因为在后面的程序中没有看到<code>*</code>可能会忘记它是一个指针。把它写在这里是因为大多数经典教材都写了的。</p><p>单链表用熟练之后就可以把<code>LinkListNode</code>直接改为<code>Node</code>，当然前提是不会和后面的树或图产生歧义。</p><h1 id="单链表的初始化"><a href="#单链表的初始化" class="headerlink" title="单链表的初始化"></a>单链表的初始化</h1><p>下面的单链表默认都带头节点。</p><h2 id="法一：通过返回值进行传递"><a href="#法一：通过返回值进行传递" class="headerlink" title="法一：通过返回值进行传递"></a>法一：通过返回值进行传递</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk">LinkListNode * InitLinkList(int n)&#123;<br>LinkListNode * head=(LinkListNode*)malloc(sizeof(LinkListNode));<br><span class="hljs-keyword">if</span>(head==NULL) <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>head-&gt;<span class="hljs-keyword">next</span>=NULL;<br>LinkListNode * temp=head;<br><span class="hljs-keyword">for</span>(int i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>temp-&gt;<span class="hljs-keyword">next</span>=(LinkListNode*)malloc(sizeof(LinkListNode));<br><span class="hljs-keyword">if</span>(temp-&gt;<span class="hljs-keyword">next</span>==NULL) <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>temp=temp-&gt;<span class="hljs-keyword">next</span>;<br>        temp-&gt;<span class="hljs-keyword">next</span>=NULL;<br>        temp-&gt;data=i;<br>&#125;<br>return head;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="法二：通过指针进行传递"><a href="#法二：通过指针进行传递" class="headerlink" title="法二：通过指针进行传递"></a>法二：通过指针进行传递</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">void InitLinkList(LinkListNode * head,int n)&#123;<br>head=(LinkListNode*)malloc(sizeof(LinkListNode));<br><span class="hljs-keyword">if</span>(head==NULL) <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>head-&gt;<span class="hljs-keyword">next</span>=NULL;<br>LinkListNode * temp=head;<br><span class="hljs-keyword">for</span>(int i=n;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>temp-&gt;<span class="hljs-keyword">next</span>=(LinkListNode*)malloc(sizeof(LinkListNode));<br><span class="hljs-keyword">if</span>(temp-&gt;<span class="hljs-keyword">next</span>==NULL) <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>temp=temp-&gt;<span class="hljs-keyword">next</span>;<br>        temp-&gt;<span class="hljs-keyword">next</span>=NULL;<br>        scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;(temp-&gt;data);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>千万要注意，如果通过指针进行传递的话，调用的时候就应该用二重指针，即<code>**</code>。这点很容易犯错！不过<code>*</code>的个数多了我也不喜欢用了。</p><h1 id="单链表的四大基本操作"><a href="#单链表的四大基本操作" class="headerlink" title="单链表的四大基本操作"></a>单链表的四大基本操作</h1><h2 id="1-按址查找"><a href="#1-按址查找" class="headerlink" title="1. 按址查找"></a>1. 按址查找</h2><p>单链表的查找，不论是按址查找，还是按值查找，都要从头指针开始，往后面一个一个地查找，所以时间复杂度均为O(n)。查找的方法就是设置一个工作指针往下移动直至查找成功。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">DataType LinkListLocate_1(LinkListNode * head,int pos)&#123;<br>LinkListNode * temp=head-&gt;<span class="hljs-keyword">next</span>;<br><span class="hljs-keyword">for</span>(int i=<span class="hljs-number">1</span>;i&lt;=pos;i++)&#123;<br><span class="hljs-keyword">if</span>(i==pos)<br>return (temp-&gt;data);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp-&gt;<span class="hljs-keyword">next</span>==NULL) <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>temp=temp-&gt;<span class="hljs-keyword">next</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为返回值不确定，所以上面的程序没有直接返回值，有的编译器可能会警告，不是太好。</p><p>最好通过指针向主调函数传递查找到的data。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros">int LinkListLocate_1(LinkListNode * head,int pos,DataType * data)&#123;<br>LinkListNode * <span class="hljs-attribute">temp</span>=head-&gt;next;<br><span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=1;i&lt;=pos;i++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">i</span>==pos)<br><span class="hljs-number">*da</span><span class="hljs-attribute">ta</span>=temp-&gt;data;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp-&gt;<span class="hljs-attribute">next</span>==NULL) return -1;<br><span class="hljs-attribute">temp</span>=temp-&gt;next;<br>&#125;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面两种函数调用的形式也不相同：</p><p>方法一：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">DataType</span> <span class="hljs-class"><span class="hljs-keyword">data</span>=<span class="hljs-type">LinkListLocate_1</span>(<span class="hljs-title">head</span>,<span class="hljs-title">pos</span>);</span><br></code></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">ElemType</span> <span class="hljs-class"><span class="hljs-keyword">data</span>;</span><br><span class="hljs-type">LinkListNode</span>(head,pos,&amp;<span class="hljs-class"><span class="hljs-keyword">data</span>);</span><br></code></pre></td></tr></table></figure><h2 id="2-按值查找"><a href="#2-按值查找" class="headerlink" title="2. 按值查找"></a>2. 按值查找</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xl">int LinkListLocate_2(LinkListNode * head,DataType <span class="hljs-keyword">data</span>)&#123;<br>L<span class="hljs-function"><span class="hljs-title">inkListNode</span> * temp=head-&gt;</span>next;<br>int i=<span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-title">while</span>(temp-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>!=<span class="hljs-keyword">data</span> &amp;&amp; temp-&gt;</span>next!=NULL)&#123;<br><span class="hljs-function"><span class="hljs-title">temp</span>=temp-&gt;</span>next;<br>i++;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">if</span>(temp-&gt;</span><span class="hljs-keyword">data</span>==<span class="hljs-keyword">data</span>) return i;<br>return -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-插入"><a href="#3-插入" class="headerlink" title="3. 插入"></a>3. 插入</h2><p>向单链表中插入一个元素，只需要改变两次指针，时间复杂度为O(1)（不包括移动指针的步骤，不然仍然为O(n)）。但是一定要注意指针改变的顺序，应该为：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">//temp指向要插入位置的上一位</span><br><span class="hljs-function"><span class="hljs-title">add</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>=temp-&gt;</span>next;<br><span class="hljs-function"><span class="hljs-title">temp</span>-&gt;</span>next=add;<br></code></pre></td></tr></table></figure><p>实现插入操作的函数如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> LinkListInsert(LinkListNode * head,<span class="hljs-type">int</span> pos,DataType d)&#123;<br>LinkListNode * <span class="hljs-keyword">temp</span>, * <span class="hljs-keyword">add</span>;<br><span class="hljs-keyword">add</span>=(LinkListNode*)malloc(sizeof(LinkListNode));<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">add</span>==<span class="hljs-keyword">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">add</span>-&gt;data=d;<br><span class="hljs-keyword">temp</span>=head-&gt;next;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;pos;i++)&#123;<br><span class="hljs-keyword">temp</span>=<span class="hljs-keyword">temp</span>-&gt;next;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">temp</span>==<span class="hljs-keyword">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">add</span>-&gt;next=<span class="hljs-keyword">temp</span>-&gt;next;<br><span class="hljs-keyword">temp</span>-&gt;next=<span class="hljs-keyword">add</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-删除"><a href="#4-删除" class="headerlink" title="4. 删除"></a>4. 删除</h2><p>删除也只需要改变两次指针，时间复杂度为O(1)（不包括移动指针）。</p><p>与插入操作不同的是，删除操作需要两个中间指针。指针改变的顺序为：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>此时p指向要删除位置的前一位<br>q=p-&gt;<span class="hljs-keyword">next</span>;<br>p=q-&gt;<span class="hljs-keyword">next</span>;<br><span class="hljs-regexp">//</span>一定要把q指向节点的空间释放掉<br>free(q);<br></code></pre></td></tr></table></figure><p>实现删除操作的函数如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros">int LinkListDelete(LinkListNode * head,int pos,DataType * data)&#123;<br>LinkListNode * p, * q;<br><span class="hljs-attribute">p</span>=head;<br><span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=1;i&lt;pos;i++)&#123;<br><span class="hljs-attribute">p</span>=p-&gt;next;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">p</span>==NULL) return -1;<br>&#125;<br><span class="hljs-attribute">q</span>=p-&gt;next;<br>p-&gt;<span class="hljs-attribute">next</span>=q-&gt;next;<br>free(q);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>单链表的存取方式为顺序存取，所以对元素的访问必须进行从头进行，不太方便。</p><p>单链表的优点是便于修改其中的元素，但是要修改的前提是要先进行访问……</p><p>要注意的一点是插入和删除的位置到底在哪里。比如说在<code>pos=6</code>处进行插入或删除，则插入的话应该把新添加的元素放在<code>pos=6</code>处，原来的<code>pos&gt;=6</code>的元素都向后移动一位；删除的话应该删除<code>pos=6</code>的元素，原来的<code>pos&gt;6</code>的元素都向前移动一位。</p><p>说实话，我认为用单链表不如用顺序表，特别是，如果顺序表使用动态数组的话可以弥补数组大小得事先确定的缺点。链表的更多使用的是后面的循环链表、双向链表。</p><p>下面使用一个程序包括前面单链表的所有操作：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><br>typedef <span class="hljs-keyword">int</span> DataType;<br>typedef struct LinkListNode&#123;<br>DataType data;<br>struct LinkListNode * <span class="hljs-keyword">next</span>;<br>&#125;LinkListNode, * NodePtr;<br><br>LinkListNode * InitLinkList(<span class="hljs-keyword">int</span> n);<br><span class="hljs-keyword">int</span> LinkListLocate_1(LinkListNode * head,<span class="hljs-keyword">int</span> <span class="hljs-keyword">pos</span>,DataType * data);<br><span class="hljs-keyword">int</span> LinkListLocate_2(LinkListNode * head,DataType data);<br><span class="hljs-keyword">int</span> LinkListInsert(LinkListNode * head,<span class="hljs-keyword">int</span> <span class="hljs-keyword">pos</span>,DataType d);<br><span class="hljs-keyword">int</span> LinkListDelete(LinkListNode * head,<span class="hljs-keyword">int</span> <span class="hljs-keyword">pos</span>,DataType * data);<br><span class="hljs-keyword">int</span> DisplayLinkList(LinkListNode * head)&#123;<br>LinkListNode * temp=head-&gt;<span class="hljs-keyword">next</span>;<br><span class="hljs-keyword">while</span>(temp!=NULL)&#123;<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,temp-&gt;data);<br>temp=temp-&gt;<span class="hljs-keyword">next</span>;<br>&#125;<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">int</span> main()&#123;<br><span class="hljs-keyword">int</span> n=<span class="hljs-number">10</span>;<br>LinkListNode * head;<br>head=InitLinkList(n);<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;原始的序列：&quot;</span>);<br>DisplayLinkList(head);<br><br><span class="hljs-keyword">int</span> <span class="hljs-keyword">pos</span>=<span class="hljs-number">6</span>;<br>DataType data;<br>LinkListLocate_1(head,<span class="hljs-keyword">pos</span>,&amp;data);<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;查找的位置的元素为%d\n&quot;</span>,data);<br><br><span class="hljs-keyword">pos</span>=LinkListLocate_2(head,data);<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;查找的元素的位置为%d\n&quot;</span>,<span class="hljs-keyword">pos</span>);<br><br>LinkListDelete(head,<span class="hljs-keyword">pos</span>,&amp;data);<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;删除的元素为%d\n&quot;</span>,data);<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;删除后的序列：&quot;</span>);<br>DisplayLinkList(head);<br><br>LinkListInsert(head,<span class="hljs-keyword">pos</span>-<span class="hljs-number">1</span>,data);<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;插入后的序列：&quot;</span>);<br>DisplayLinkList(head);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>LinkListNode * InitLinkList(<span class="hljs-keyword">int</span> n)&#123;<br>LinkListNode * head=(LinkListNode*)malloc(sizeof(LinkListNode));<br><span class="hljs-keyword">if</span>(head==NULL) <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>head-&gt;<span class="hljs-keyword">next</span>=NULL;<br>LinkListNode * temp=head;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>temp-&gt;<span class="hljs-keyword">next</span>=(LinkListNode*)malloc(sizeof(LinkListNode));<br><span class="hljs-keyword">if</span>(temp-&gt;<span class="hljs-keyword">next</span>==NULL) <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>temp=temp-&gt;<span class="hljs-keyword">next</span>;<br>        temp-&gt;<span class="hljs-keyword">next</span>=NULL;<br>        temp-&gt;data=i;<br>&#125;<br><span class="hljs-keyword">return</span> head;<br>&#125;<br><span class="hljs-keyword">int</span> LinkListLocate_1(LinkListNode * head,<span class="hljs-keyword">int</span> <span class="hljs-keyword">pos</span>,DataType * data)&#123;<br>LinkListNode * temp=head-&gt;<span class="hljs-keyword">next</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-keyword">pos</span>;i++)&#123;<br><span class="hljs-keyword">if</span>(i==<span class="hljs-keyword">pos</span>)<br>*data=temp-&gt;data;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp-&gt;<span class="hljs-keyword">next</span>==NULL) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>temp=temp-&gt;<span class="hljs-keyword">next</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">int</span> LinkListLocate_2(LinkListNode * head,DataType data)&#123;<br>LinkListNode * temp=head-&gt;<span class="hljs-keyword">next</span>;<br><span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(temp-&gt;data!=data &amp;&amp; temp-&gt;<span class="hljs-keyword">next</span>!=NULL)&#123;<br>temp=temp-&gt;<span class="hljs-keyword">next</span>;<br>i++;<br>&#125;<br><span class="hljs-keyword">if</span>(temp-&gt;data==data) <span class="hljs-keyword">return</span> i;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">int</span> LinkListInsert(LinkListNode * head,<span class="hljs-keyword">int</span> <span class="hljs-keyword">pos</span>,DataType d)&#123;<br>LinkListNode * temp, * add;<br>add=(LinkListNode*)malloc(sizeof(LinkListNode));<br><span class="hljs-keyword">if</span>(add==NULL) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>add-&gt;data=d;<br>temp=head-&gt;<span class="hljs-keyword">next</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-keyword">pos</span>;i++)&#123;<br>temp=temp-&gt;<span class="hljs-keyword">next</span>;<br><span class="hljs-keyword">if</span>(temp==NULL) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br>add-&gt;<span class="hljs-keyword">next</span>=temp-&gt;<span class="hljs-keyword">next</span>;<br>temp-&gt;<span class="hljs-keyword">next</span>=add;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">int</span> LinkListDelete(LinkListNode * head,<span class="hljs-keyword">int</span> <span class="hljs-keyword">pos</span>,DataType * data)&#123;<br>LinkListNode * p, * <span class="hljs-keyword">q</span>;<br>p=head;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-keyword">pos</span>;i++)&#123;<br>p=p-&gt;<span class="hljs-keyword">next</span>;<br><span class="hljs-keyword">if</span>(p==NULL) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">q</span>=p-&gt;<span class="hljs-keyword">next</span>;<br>p-&gt;<span class="hljs-keyword">next</span>=<span class="hljs-keyword">q</span>-&gt;<span class="hljs-keyword">next</span>;<br>free(<span class="hljs-keyword">q</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>output：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns">原始的序列：<span class="hljs-number">12345678910</span><br>查找的位置的元素为<span class="hljs-number">6</span><br>查找的元素的位置为<span class="hljs-number">6</span><br>删除的元素为<span class="hljs-number">6</span><br>删除后的序列：<span class="hljs-number">1234578910</span><br>插入后的序列：<span class="hljs-number">12345678910</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大二上 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序表及其基本操作</title>
      <link href="/post/90305579.html"/>
      <url>/post/90305579.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h1><p>顺序表这种数据结构类似数组。除此之外，还要求记录当前表的长度和分配时定义的表的最大长度。</p><h2 id="法一：使用动态数组"><a href="#法一：使用动态数组" class="headerlink" title="法一：使用动态数组"></a>法一：使用动态数组</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SeqList</span>&#123;</span><br>ElemType * elem;<br><span class="hljs-keyword">int</span> length;<br><span class="hljs-keyword">int</span> size;<br>&#125;SeqList,* ListPtr;<br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="法二：使用静态数组"><a href="#法二：使用静态数组" class="headerlink" title="法二：使用静态数组"></a>法二：使用静态数组</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 10</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SeqList</span>&#123;</span><br>ElemType elem[MAXSIZE];<br><span class="hljs-keyword">int</span> length;<br><span class="hljs-keyword">int</span> size;<br>&#125;SeqList,* ListPtr;<br></code></pre></td></tr></table></figure><p>至于选用哪种定义方式，肯定还得看实际情况。我更倾向于使用动态数组。因为动态数组使用更灵活，也更节省空间。而且后面的一些基本操作，比如插入，如果数组的大小不够，动态数组还可以重新分配内存大小。所以，后面的操作也都以动态数组为例。</p><h1 id="顺序表的初始化"><a href="#顺序表的初始化" class="headerlink" title="顺序表的初始化"></a>顺序表的初始化</h1><p>初始化顺序表，要求给表分配内存空间，同时记录下最大长度，并把当前长度记为0。</p><h2 id="法一：通过返回值进行传递"><a href="#法一：通过返回值进行传递" class="headerlink" title="法一：通过返回值进行传递"></a>法一：通过返回值进行传递</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">SeqList InitSeqList()&#123;<br>SeqList list;<br>list.elem=(ElemType*)malloc(list.size*sizeof(ElemType));<br><span class="hljs-keyword">if</span>(list.elem==NULL)<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>list.length=<span class="hljs-number">0</span>;<br>list.size=MAXSIZE;<br>return list;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="法二：通过指针进行传递"><a href="#法二：通过指针进行传递" class="headerlink" title="法二：通过指针进行传递"></a>法二：通过指针进行传递</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">void InitSeqList(SeqList * list)&#123;<br>list-&gt;elem=(ElemType*)malloc(list-&gt;size*sizeof(ElemType));<br><span class="hljs-keyword">if</span>(list-&gt;elem==NULL) <br><span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>list-&gt;length=<span class="hljs-number">0</span>;<br>list-&gt;size=MAXSIZE;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面两种方法都行，不过使用方法不同。</p><ul><li><p>法一：</p><p><code>SeqList list=InitSeqList;</code></p></li><li><p>法二：</p>  <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lsl">SeqList <span class="hljs-type">list</span>;<br>InitSeqList(&amp;<span class="hljs-type">list</span>);<br></code></pre></td></tr></table></figure></li></ul><h1 id="顺序表的四大基本操作"><a href="#顺序表的四大基本操作" class="headerlink" title="顺序表的四大基本操作"></a>顺序表的四大基本操作</h1><p>顺序表的四大基本操作即按址查找、按值查找、插入、删除。四种操作都应该要十分熟练掌握，而且其精确的时间复杂度应该记下来。</p><h2 id="1-按址查找"><a href="#1-按址查找" class="headerlink" title="1. 按址查找"></a>1. 按址查找</h2><p>由于顺序表物理存储空间的连续性，即顺序存储方式，使得其存取方式为随机存取。只需要知道首元素的位置以及要访问元素的位序，即可通过寻址公式<code>Loc(a[i])=Loc(a[0])+i*sizeof(ElemType)</code>求得其位置。</p><p>顺序表的按值查找一般不需要定义函数，直接通过下面的语句即可：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">list.elem[location]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>话说这不就是访问吗，戳了一下elem[localtion]……</p><p>严谨点的话可以增加一个判断是否越界的语句。</p><p><strong>时间复杂度为O(1)。</strong></p><h2 id="2-按值查找"><a href="#2-按值查找" class="headerlink" title="2. 按值查找"></a>2. 按值查找</h2><p><strong>按值查找的时间复杂度为(n+1)/2。</strong></p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-keyword">int</span> ListLocate(SeqList list,ElemType <span class="hljs-built_in">e</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;list.length;i++)&#123;<br><span class="hljs-keyword">if</span>(list.elem[i]==<span class="hljs-built_in">e</span>) <br><span class="hljs-keyword">return</span> (i+<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最好把<code>return -1</code>写在for循环外面。因为有的编译器没有搜索到最直接的返回值可能会警告甚至报错。</p><h2 id="3-插入"><a href="#3-插入" class="headerlink" title="3. 插入"></a>3. 插入</h2><p><strong>插入的时间复杂度为n/2。</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xl">int ListInsert(SeqList * list,ElemType e,int pos)&#123;<br><span class="hljs-function"><span class="hljs-title">if</span>((pos&lt;1)||(pos&gt;list-&gt;</span>size+<span class="hljs-number">2</span>)) <br>return -<span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(list-&gt;</span><span class="hljs-function"><span class="hljs-title">length</span>==list-&gt;</span>size)&#123;<br><span class="hljs-function"><span class="hljs-title">list</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">elem</span>=(ElemType*)realloc(list-&gt;</span><span class="hljs-function"><span class="hljs-title">elem</span>,(list-&gt;</span>size+<span class="hljs-number">1</span>)*sizeof(ElemType));<br><span class="hljs-function"><span class="hljs-title">if</span>(list-&gt;</span>elem==NULL)<br>return -<span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-title">list</span>-&gt;</span>size++;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">for</span>(int i=list-&gt;</span>length-<span class="hljs-number">1</span>;i&gt;=pos-<span class="hljs-number">1</span>;i--)&#123;<br><span class="hljs-function"><span class="hljs-title">list</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">elem</span>[i+1]=list-&gt;</span>elem[i];<br>&#125;<br><span class="hljs-function"><span class="hljs-title">list</span>-&gt;</span>elem[pos-<span class="hljs-number">1</span>]=e;<br><span class="hljs-function"><span class="hljs-title">list</span>-&gt;</span>length++;<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里是通过指针来进行主函数和被调函数之间的联系，所以访问结构题元素应该用<code>-&gt;</code>。说实话，我不是很喜欢用这个符号……因为比起<code>.</code>要多打一个字符……汗</p><h2 id="4-删除"><a href="#4-删除" class="headerlink" title="4. 删除"></a>4. 删除</h2><p><strong>删除操作的时间复杂度为(n-1)/2。</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> ListDelete(SeqList * list,<span class="hljs-keyword">int</span> <span class="hljs-keyword">pos</span>)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">pos</span>&lt;<span class="hljs-number">1</span>||<span class="hljs-keyword">pos</span>&gt;=list-&gt;<span class="hljs-keyword">length</span>)<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-keyword">pos</span>-<span class="hljs-number">1</span>;i&lt;list-&gt;<span class="hljs-keyword">length</span>-<span class="hljs-number">1</span>;i++)&#123;<br>list-&gt;elem[i]=list-&gt;elem[i+<span class="hljs-number">1</span>];<br>&#125;<br>list-&gt;<span class="hljs-keyword">length</span>--;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>有的时候还可能会需要删除的值，则代码修改为：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> ListDelete(SeqList * list,<span class="hljs-keyword">int</span> <span class="hljs-keyword">pos</span>,ElemType * need)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">pos</span>&lt;<span class="hljs-number">1</span>||<span class="hljs-keyword">pos</span>&gt;=list-&gt;<span class="hljs-keyword">length</span>)<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>*need=list-&gt;elem[<span class="hljs-keyword">pos</span>-<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-keyword">pos</span>-<span class="hljs-number">1</span>;i&lt;list-&gt;<span class="hljs-keyword">length</span>-<span class="hljs-number">1</span>;i++)&#123;<br>list-&gt;elem[i]=list-&gt;elem[i+<span class="hljs-number">1</span>];<br>&#125;<br>list-&gt;<span class="hljs-keyword">length</span>--;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>顺序表的优势在于可以随机存取，对元素的访问十分方便。它比较适合元素个数不大变化，而更多是存取数据的应用。</p><p><strong>下面使用一个程序包括顺序表的所有操作：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-comment">//宏定义MAXSIZE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 10</span><br><span class="hljs-comment">//重命名</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SeqList</span>&#123;</span><br>ElemType * elem;<br><span class="hljs-keyword">int</span> length;<br><span class="hljs-keyword">int</span> size;<br>&#125;SeqList,*ListPtr;<br><span class="hljs-comment">//函数原型</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitSeqList</span><span class="hljs-params">(SeqList * list)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ListLocate</span><span class="hljs-params">(SeqList list,ElemType e)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ListInsert</span><span class="hljs-params">(SeqList * list,ElemType e,<span class="hljs-keyword">int</span> pos)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ListDelete</span><span class="hljs-params">(SeqList * list,<span class="hljs-keyword">int</span> pos)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ListDisplay</span><span class="hljs-params">(SeqList * list)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;list-&gt;length;i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,list-&gt;elem[i]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>SeqList list;<br><span class="hljs-built_in">InitSeqList</span>(&amp;list);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;list.size;i++)&#123;<br>list.elem[i]=i;<br>list.length++;<br>&#125;<br><span class="hljs-comment">//打印初始化后顺序表中的元素</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;原始的序列:&quot;</span>);<br><span class="hljs-built_in">ListDisplay</span>(&amp;list);<br><br><span class="hljs-comment">//查值查找</span><br><span class="hljs-keyword">int</span> pos;<br>ElemType e=<span class="hljs-number">6</span>;<br>pos=<span class="hljs-built_in">ListLocate</span>(list,e);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;定位元素的位置:&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,pos);<br><br><span class="hljs-comment">//删除线性表中的元素并打印删除后线性表的元素</span><br><span class="hljs-built_in">ListDelete</span>(&amp;list,pos);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除后的序列:&quot;</span>);<br><span class="hljs-built_in">ListDisplay</span>(&amp;list);<br><br><span class="hljs-comment">//向线性表中添加元素并打印</span><br><span class="hljs-built_in">ListInsert</span>(&amp;list,pos,e);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;添加元素后的序列:&quot;</span>);<br><span class="hljs-built_in">ListDisplay</span>(&amp;list);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//函数定义</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitSeqList</span><span class="hljs-params">(SeqList * list)</span></span>&#123;<br>list-&gt;elem=(ElemType*)<span class="hljs-built_in">malloc</span>(list-&gt;size*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ElemType));<br><span class="hljs-keyword">if</span>(list-&gt;elem==<span class="hljs-literal">NULL</span>) <br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>list-&gt;length=<span class="hljs-number">0</span>;<br>list-&gt;size=MAXSIZE;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ListLocate</span><span class="hljs-params">(SeqList list,ElemType e)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;list.length;i++)&#123;<br><span class="hljs-keyword">if</span>(list.elem[i]==e) <br><span class="hljs-keyword">return</span> (i+<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ListInsert</span><span class="hljs-params">(SeqList * list,ElemType e,<span class="hljs-keyword">int</span> pos)</span></span>&#123;<br><span class="hljs-keyword">if</span>((pos&lt;<span class="hljs-number">1</span>)||(pos&gt;list-&gt;size+<span class="hljs-number">2</span>)) <br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(list-&gt;length==list-&gt;size)&#123;<br>list-&gt;elem=(ElemType*)<span class="hljs-built_in">realloc</span>(list-&gt;elem,(list-&gt;size+<span class="hljs-number">1</span>)*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ElemType));<br><span class="hljs-keyword">if</span>(list-&gt;elem==<span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>list-&gt;size++;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=list-&gt;length<span class="hljs-number">-1</span>;i&gt;=pos<span class="hljs-number">-1</span>;i--)&#123;<br>list-&gt;elem[i+<span class="hljs-number">1</span>]=list-&gt;elem[i];<br>&#125;<br>list-&gt;elem[pos<span class="hljs-number">-1</span>]=e;<br>list-&gt;length++;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ListDelete</span><span class="hljs-params">(SeqList * list,<span class="hljs-keyword">int</span> pos)</span></span>&#123;<br><span class="hljs-keyword">if</span>(pos&lt;<span class="hljs-number">1</span>||pos&gt;=list-&gt;length)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=pos<span class="hljs-number">-1</span>;i&lt;list-&gt;length<span class="hljs-number">-1</span>;i++)&#123;<br>list-&gt;elem[i]=list-&gt;elem[i+<span class="hljs-number">1</span>];<br>&#125;<br>list-&gt;length--;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">原始的序列:0123456789      </span><br><span class="hljs-section">定位元素的位置:7</span><br><span class="hljs-section">删除后的序列:012345789     </span><br><span class="hljs-section">添加元素后的序列:0123456789</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大二上 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本数据类型和运算</title>
      <link href="/post/6afc6ab5.html"/>
      <url>/post/6afc6ab5.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>先尝试回答一下以下问题：</strong></p><ol><li>C语言的数据类型有哪些？基本数据类型可以怎样分类？</li><li>int可以表示的整数的数量级？char默认有符号还是无符号？为什么下面代码的c=26 (%d)？<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">char <span class="hljs-attribute">a</span>=175; char <span class="hljs-attribute">b</span>=107; char <span class="hljs-attribute">c</span>=a+b;<br></code></pre></td></tr></table></figure></li><li>几种算数运算符对整数、浮点数分别是怎么处理的？结果是整数还是浮点数？</li><li>奇葩的逗号表达式是怎么回事？</li><li>scanf_s被报错了是怎么回事？格式控制字符串怎么理解？<span id="more"></span></li></ol><hr><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>C语言的数据类型包括基本类型、构造类型、指针类型和空类型。构造类型包括数组、结构、联合和枚举，是用户以基本类型为基础构造的复杂类型。下面细说基本数据类型。</p><p>C语言的基本类型可以按照如下方式分类：</p><p><img src="https://satoing.gitee.io/img/C语言1/2.JPEG" alt></p><p>值得一提的是char被划分在整型数据里面，其实这是很合理的：字符型变量真正存储的是一串8位的数码，而当编译器知道这个变量是字符型后，就会通过该编码找到对应的字符。所以char可以当作1byte的整数使用；同理，int也可以当作char使用，如下：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> a=<span class="hljs-number">65</span>; <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>,a);<br></code></pre></td></tr></table></figure><p>最后会打印A，因为在格式说明里已经要求把int按照char输出了。但这种用法除了学习价值外就毫无意义了。</p><blockquote><p>我补充一下自己的意图吧。首先，我们知道汉字的GBK编码需要2个字节的内存，显然8位的char是无法存放的，所以才有<code>printf(&quot;%c%c%c%c%c%c\n&quot;,206,210,176,174,196,227);</code>的用法。于是我用2个字节的short int去存储GBK编码，然后用scanf输出汉字，但最后失败了。因为格式控制字符串里面对%c对数的范围也有要求，即不大于255。32位的整数溢出了，所以最后什么都没有输出？因为负数没有ASCII编码！</p></blockquote><hr><p>int就比较有趣了。早期的C语言，随着硬件的发展，int的大小也发生着改变。操作系统16位时，int的大小为2字节；操作系统32位时，int的大小为4字节；然而今天，操作系统已经64位，int的大小仍为4字节——其原因是C语言在32位时期已经相当普及，如果直接变成64位则会引发极大的问题，包括很多社会问题！C语言妥协的做法，就是定义了long long int。</p><p>我们不妨先计算一下整型数据的数量级。char: 2^8=256（百）; short: 2^16=65536（万）;long: 2^32=4294967296（十亿）;long long: 2^64（天文数字！）。若为有符号数则正负各占一半（补码0视为正数）。</p><p>现在的运算，光做加减法，int为32位都可能会溢出，更别说乘除了。而64位完全不存在这个问题。所以long long是有必要的。</p><p>我们写程序时，应该要仔细核算，在保证不越界的前提下，选择合适的整型大小，以节省空间——这是作为程序员的职责之一。</p><hr><p>C语言的char是默认有符号的，即MSB填0。这也是ASCII码区别其他编码的特点，因为其他大多数编码都是兼容ASCII码的，自然要取得比ASCII码更大，即MSB为1。编译器可以通过这个特点区分ASCII码和其他编码。</p><p>关于下面c的结果为26，其实就是溢出造成的。（这更容易体会到低位是多么容易溢出！）</p>   <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">char <span class="hljs-attribute">a</span>=175; char <span class="hljs-attribute">b</span>=107; char <span class="hljs-attribute">c</span>=a+b;<br></code></pre></td></tr></table></figure><p>175+107=282，282-256=26，所以结果为26，真的是这样吗？</p><p>前面说过，char默认有符号，所以175就已经越界了！大于127就算越界了！所以应该是107-81=26。</p><p><img src="https://satoing.gitee.io/img/C语言1/3.JPG" alt></p><hr><p>不知你是否见过这样的用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> uint8;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> unit16;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> uint32;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> uint64;<br></code></pre></td></tr></table></figure><p>虽然是换汤不换药的做法，但是能实现用户自定义类型，极大提高程序的兼容性。而且老师还叮嘱过我们，以后看到这样的代码，一定要去精读——这绝逼是好代码。</p><h1 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h1><p>双目运算中的算术运算应该是我们最熟悉的了，同时它也包括了自动类型转换，这点值得我们注意。</p><ol><li><p>两个数均为整数，+，-，*，/后的结果也为整数。不过两数相除的结果可能是小数，C语言一律向下取整。即<code>3/5=0</code>。如果想要向上取整，规范的做法是：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">w/<span class="hljs-number">64</span>+!!(w<span class="hljs-comment">%64)</span><br></code></pre></td></tr></table></figure><p>这里连续使用两次“!”的技巧性很强。实际上，C语言后来还定义了向下取整函数floor和ceil，但是floor基本没人用，因为C语言自动会向下取整所以何必呢？ceil用得也很少，因为<code>w/64+!!(w%64)</code>的做法已经成为向上取整约定俗成的方式了，性能也很好。</p></li><li><p>%的两个数只能是整数。</p></li><li>+，-，*，/的两个数中一个为浮点数，结果都自动转换为double型。这样可以提高运算精度。这也是类型转换中自动类型转换的经典例子。</li></ol><hr><p>逗号经常作为变量表，形参表等列表元素之间的分隔符，这样用逗号是没问题的。但是，当看到逗号运算符时，却往往脑壳疼，因为这样的语句可读性是很低的。自己写程序时不应该用，但是别人用了要读得懂。</p><p>逗号表达式的意思是从左至右依次计算各表达式的值，表达式最终的结果为最右端表达式的值。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> a=<span class="hljs-number">3</span>/<span class="hljs-number">5</span>,<span class="hljs-number">3</span>/<span class="hljs-number">5</span>+!!(<span class="hljs-number">3</span>%<span class="hljs-number">5</span>);//最终a的值为<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>明白了这个，那么请分析下面的用法。有人依此说return是一个函数，错在哪里？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>当然，根本没有报错：</p><p><img src="https://satoing.gitee.io/img/C语言1/4.JPG" alt></p><p>这里(0)实际上是(,0)，一个逗号表达式，所以最终返回的结果为0，没有报错。</p><h1 id="标准输入输出函数"><a href="#标准输入输出函数" class="headerlink" title="标准输入输出函数"></a>标准输入输出函数</h1><p>首先声明一下，scanf_s，getchar_s等等带_s的函数都是微软自己定义的安全函数，仅在微软的编译器里面生效。更可恶的是，Visual Studio会强制你使用_s的函数，简直牛逼疯了。不说跨系统了，跨编译器的可移植性都有很大问题。</p><p>说句题外话，我强烈不建议使用VS这样的IDE进行C语言的学习：</p><ul><li>首先是内存太大，动辄几个G，编译器几十M就可以了啊，很容易让学习者产生编程很难的错觉；</li><li>其次是想写一个程序也很麻烦，每次都要创建一个工作区。如果是小白的话，工作区是什么都不知道，只能叫怎么做就怎么做，丧失了自主性；</li><li>直接使用IDE，容易让学习者忽略最基本的编译，链接这些步骤。事实证明，我现在的好多同学都对这两个概念很模糊。</li><li>最后，不知道你发现没有，使用VS编译出来的可执行文件要比gcc编译出来的大很多，原因是微软会在里面添加一些奇奇怪怪的多余的东西。所以为了你程序最后的轻量高效，最好也不要使用VS。</li></ul><p>当然，以上只是个人观点，这还是得看个人喜好。</p><hr><p>printf()和scanf()都包括格式控制字符串和参数表。格式控制字符串又包括了格式说明符和普通字符。</p><p>格式说明符就是%c,%d,%o,%x,%f,%d之类的，还可以在中间添加修饰符。</p><p>普通字符就是一个个字符了。可以是英文字母，也可以是中文字符。从这里可见，C语言是可以输出中文的，所以一个汉字到底算不算是字符呢？先看一下下面的结果：</p><p><img src="https://satoing.gitee.io/img/C语言1/5.JPG" alt></p><p>这里提示说“我”是“multi-character character”，即我不是一个字符。C语言里面，将汉字当作两个字符，所以下面的问题也和上面一样：</p><p><img src="https://satoing.gitee.io/img/C语言1/6.JPG" alt></p><p>这里同样溢出了，但是打印了b；不同于上面什么都没有输出。但是问题都是一样的——一个汉字应该视为两个字符，所以也不难解释为什么要<code>printf(&quot;%c%c%c%c%c%c\n&quot;,206,210,176,174,196,227);</code>这样了。</p><p>scanf()的格式控制字符串要求使用者在输入数据时原封不动地将普通字符也打上去，所以，下面的代码就有点傻逼了：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">scanf(“请输入一个数字：<span class="hljs-comment">%d”，&amp;a);</span><br></code></pre></td></tr></table></figure><p>本意是想作为提示，结果最后用户还要把“请输入一个数字：”打上去，自己以前的做法有点搞笑。</p><p>一般scanf()的格式控制字符串都使用空格或逗号分隔：<code>&quot;%d %d&quot;</code>或<code>&quot;%d,%d&quot;</code>,不分隔的话就要说明长度，就要用到scanf_s。</p><hr><p>最后再回去看看上面的问题，是不是要清楚一些了？</p>]]></content>
      
      
      <categories>
          
          <category> 大二上 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符编码</title>
      <link href="/post/ebfb97d0.html"/>
      <url>/post/ebfb97d0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>本文主要解决以下几个问题：</strong></p><ul><li>常用的字符编码方式有哪些？</li><li>Visual Stdio的默认编码方式是什么？vscode的编码方式是什么？gcc/g++编译后显示结果时编码方式是什么？</li><li>跨编辑器和编译器导致的中文乱码改怎么解决？</li><li>你敢用这段代码:<code>printf(&quot;%c%c%c%c%c%c\n&quot;,206,210,176,174,196,227);</code>去表白吗？</li><li>编译结果为烫烫烫烫烫是怎么回事？系统过热警告？</li></ul><p><strong>如果大神们都知道，也请继续看下去。希望能找出本文的一些错误或者给本萌新一些建议。</strong></p><span id="more"></span><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>有的人可能知道，我会玩一些需要转区的游戏。调整windows的地区，再重启电脑后，许多文档的内容都变成了一堆乱码——这就是不同地区的编码方式不同所产生的问题。然而我之前都忽视了这个问题。</p><p><img src="https://cloud.fullcomb.top/private/source/image/encoding/2.png" alt="2.png"></p><p>最近开始了解编码的契机，就是我从VS转用vscode的时候，发现以前写的和Github上克隆一些代码在vscode中中文显示乱码，或者显示正常但gcc编译后中文乱码。</p><p><img src="https://cloud.fullcomb.top/private/source/image/encoding/1.png" alt="1.png"></p><p>本文最终将会给出这个问题的解决方案。</p><h1 id="字符编码方式"><a href="#字符编码方式" class="headerlink" title="字符编码方式"></a>字符编码方式</h1><p>先来看看编码的定义（摘自维基百科）：</p><blockquote><p>编码是<strong>信息 从一种 形式 或 格式 转换为另一种形式的过程</strong></p></blockquote><p>字符编码当然就是针对字符的转换。常用的字符编码方式有ASCII，GBK，ANSI，utf-8。</p><h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p>ASCII的全称是American Standard Code for Information Interchange，即美国信息交换标准码。（小白注意缩写的后两位是ii不是LL也不是Ⅱ，会出大丑的。）ASCII码定义了128个字符，用到了7位二进制位。而我们知道，C语言中的char位一个字节，多出来的最高位MSB通常填0，或者作为奇偶校检位。</p><p>ASCII码的出现年代较早。后来制定的大多数编码都是向下兼容ASCII码的。</p><p>经常用到的ASCII码：</p><ul><li>A to Z：65 to 90</li><li>a to z：97 to 122</li></ul><h2 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h2><p>GB想必都不会陌生了，而K是扩（充）的拼音首字母。GBK是我国制定的针对中文的字符编码，从GB2312扩充而来。</p><p>中国汉字博大精深，GBK的编码方式也比较复杂。要用的时候直接查表即可。下面给出查找GBK编码并进行转化的一个实例。</p><ol><li>首先在网上查到<strong>“我”</strong>的GBK16进制内码为CED2。</li><li>将CED2拆分，分别求十进制码。</li><li>用windows自带的程序员计算器得出CE[16]=206[10]，D2[16]=210[10].</li><li>206,210分别转化为二进制后拼接在一起即为“我”的二进制编码。</li></ol><h2 id="ANSI"><a href="#ANSI" class="headerlink" title="ANSI"></a>ANSI</h2><p>ANSI准确来说并不能算字符编码，而应该说是一组兼容ASCII码字符编码的集合，包括了GBK。</p><p>windows设置的地区不同，ANSI指的编码方式也不同。比如我们的电脑现在的地区为中国大陆，那么此时ANSI=GBK；如果设置为台湾，那么ANSI=Big5。当然，如果设置为日本，其编码就是日本语的编码。这就是玩某些游戏需要转区的原因，不然你的文字显示就是一团乱码。</p><h2 id="utf-8"><a href="#utf-8" class="headerlink" title="utf-8"></a>utf-8</h2><p>utf-8是国际统一的编码方式，用于应对世界各地的编码太乱的统一方案。对应的字符集为unicode。</p><p>utf-8的编码方式有点麻烦，不做介绍。</p><p>utf-8可跨语言，具有很强的兼容性。实际上，现在很多程序员都坚持使用的utf-8编码。</p><h2 id="各种工具的编码方式"><a href="#各种工具的编码方式" class="headerlink" title="各种工具的编码方式"></a>各种工具的编码方式</h2><p>VS的默认编码方式，经过我的测试，为下面的规则：</p><ul><li>全英文为utf-8编码</li><li>有中文为ANSI(GBK)编码</li></ul><p>VS的编译器MSVC对于中文的编码方式为ANSI，所以ANSI编辑的代码运行时不会中文乱码。</p><hr><p>vscode的编码方式可以通过<strong>首选项—设置—搜索“encoding”</strong>进行修改。这时vscode只是相当于一个编辑器，用于读写文件。比如：用vscode编辑的文件为自己通过上面方式设置的编码（写）。而来自外部的文件，如果为该编码方式，就能正确显示；不是该编码，则会出现乱码。</p><p><img src="https://cloud.fullcomb.top/private/source/image/encoding/3.png" alt="3.png"></p><hr><p>vscode要编译C语言只能借助插件和外部的编译器。我使用的是GNU套件，clang应该也一样。下面说说gcc编译后显示的编码。</p><p>如你所想，gcc显示的编码和你的windows编码同步，毕竟结果就在命令行显示。比如你的windows默认编码方式为GBK，那么结果显示的编码就是GBK编码。你用utf-8编码方式编辑的文件在运行后就会出现中文乱码。</p><p><strong>然而，坚持使用utf-8编码仍是一个好的选择。那么，utf-8编码的.c文件怎么用gcc编译而不乱码呢？</strong></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>gcc有一条命令可以控制编译后按哪种编码来显示：<code>-fexec-charset=GBK</code></p><p>在编译命令后面加一条这个命令就可以了:<code>g++ &#39;a.cpp&#39; -o a -fexec-charset=GBK</code> 。</p><p>但是，如果每次都这样输入，肯定十分麻烦。我们可以把这句命令加进vscode的插件Code Runner的编译命令中去。具体操作方式如下：</p><ol><li>打开Code Runner的setting.json，找到<strong>“code-runner.executorMap”</strong>。</li><li>将C语言的命令修改为：<code>&quot;c&quot;: &quot;cd $dir &amp;&amp; gcc &#39;$fileName&#39; -o &#39;$fileNameWithoutExt.exe&#39; -Wall -g -O2 -static-libgcc -std=c11 -fexec-charset=GBK &amp;&amp; &amp;&#39;$dir$fileNameWithoutExt&#39;&quot;,</code></li><li>将C++的命令修改为：<code>&quot;cpp&quot;: &quot;cd $dir &amp;&amp; g++ &#39;$fileName&#39; -o &#39;$fileNameWithoutExt.exe&#39; -Wall -g -O2 -static-libgcc -std=c++17 -fexec-charset=GBK &amp;&amp; &amp;&#39;$dir$fileNameWithoutExt&#39;&quot;,</code></li></ol><p>上面的命令直接整行粘贴就可以了，没有问题。</p><h1 id="开始使用GBK编码"><a href="#开始使用GBK编码" class="headerlink" title="开始使用GBK编码"></a>开始使用GBK编码</h1><p><code>printf(&quot;%c%c%c%c%c%c\n&quot;,206,210,176,174,196,227);</code></p><p>如果你看了上面关于GBK编码的内容，你很快就会发现，这条语句使用了GBK编码。</p><p>按照我之前演示的方式的逆操作，就可以知道，打印的结果为：我爱你（♂）</p><p><img src="https://cloud.fullcomb.top/private/source/image/encoding/4.jpg" alt="4.JPG"></p><p>这样是不是格局一下子就大起来了。</p><p>这里把每两个数识别为一组，因为%c%c%c%c%c%c是没有断开的，如果在中间断开，就会出问题。</p><p><img src="https://cloud.fullcomb.top/private/source/image/encoding/5.jpg" alt="5.JPG"></p><h1 id="烫烫烫"><a href="#烫烫烫" class="headerlink" title="烫烫烫"></a>烫烫烫</h1><p>有一对对联对得好，</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">手持两把锟斤拷, <span class="hljs-comment">(GBK与UTF-8)</span><br>口中疾呼烫烫烫。<span class="hljs-comment">(VC++)</span><br>脚踏千朵屯屯屯, <span class="hljs-comment">(VC++)</span><br>笑看万物锘锘锘。<span class="hljs-comment">(HTML)</span><br></code></pre></td></tr></table></figure><p>锟斤拷就是GBK与UTF-8转换时的问题。然而现在电脑已经被调教得太好了所以我弄半天都弄不出来。详见<a href="https://baike.baidu.com/item/锟斤拷?fr=aladdin">锟斤拷_百度百科 </a></p><p>而其中的烫烫烫大概就是和我一样的初学者一定遇到过的问题。</p><p>在Visual Studio中的Debug模式下，如果声明一个变量，但是没有初始化，微软会给未初始化的内存复制为0xCC。给为初始化的内存赋0xCC是有原因的，0xCC其实是INT3中断指令，所以如果在Debug模式下试图去执行这块未初始化的内存的话就会中断程序。但VS中调试器默认的字符集是MBCS，而在MBCS中0xCCCC正好就是中文中的“烫”，所以显示出来就都是烫……</p><p>所以烫烫烫是只有VS或VC会出现的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 大二上 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/4a17b156.html"/>
      <url>/post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 大二上 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> C++程序设计 </tag>
            
            <tag> 计算机图形学 </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
